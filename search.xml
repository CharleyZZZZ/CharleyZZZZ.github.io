<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo + Github搭建免费个人博客</title>
    <url>/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Hexo-Github搭建免费个人博客"><a href="#Hexo-Github搭建免费个人博客" class="headerlink" title="Hexo + Github搭建免费个人博客"></a>Hexo + Github搭建免费个人博客</h1><h2 id="什么是-Hexo"><a href="#什么是-Hexo" class="headerlink" title="什么是 Hexo"></a>什么是 Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><blockquote>
<ul>
<li>注册Github账号，熟悉github基本使用</li>
<li>安装nodejs、npm，了解相关使用</li>
<li>安装git客户端</li>
</ul>
</blockquote>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1. 创建仓库"></a>1. 创建仓库</h3><blockquote>
<ul>
<li>github新建仓库：仓库名必须是 <strong>username.github.io</strong> 格式，其中 <strong>username</strong> 是你的github用户名</li>
<li>完成后 <strong><em><a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a></em></strong> 即为博客网站地址，github提供页面访问（Hexo会在项目路径生成index.html）</li>
</ul>
</blockquote>
<h3 id="2-设置SSHKey（已经设置的可跳过本步骤）"><a href="#2-设置SSHKey（已经设置的可跳过本步骤）" class="headerlink" title="2. 设置SSHKey（已经设置的可跳过本步骤）"></a>2. 设置SSHKey（已经设置的可跳过本步骤）</h3><h4 id="1）生成SSHKey"><a href="#1）生成SSHKey" class="headerlink" title="1）生成SSHKey"></a>1）生成SSHKey</h4><pre><code>ssh-keygen -t rsa -C &quot;邮件地址&quot; -f ~/.ssh/秘钥名称（rsa_example）</code></pre><blockquote>
<ul>
<li>-C 指定邮件地址</li>
<li>-f 指定秘钥名称，因为一台机器可能存有多个git仓库的秘钥（例如github和公司gitlab），区别名称可在 <strong>config</strong> 文件中设置特定的仓库地址使用指定的秘钥</li>
</ul>
</blockquote>
<h4 id="2）将公钥复制到github上"><a href="#2）将公钥复制到github上" class="headerlink" title="2）将公钥复制到github上"></a>2）将公钥复制到github上</h4><p>​    打开github设置，进入 <strong>SSH and GPG keys</strong>,点击  <strong>New SSH key</strong>  复制 <code>rsa_example.pub</code>  里的公钥，保存</p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_01.png" alt="copy_sshKey_to_github"></p>
<h4 id="3）编辑-ssh-config-文件"><a href="#3）编辑-ssh-config-文件" class="headerlink" title="3）编辑  ~/.ssh/config 文件"></a>3）编辑  ~/.ssh/config 文件</h4><p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_02.png" alt="edit_ssh_config"></p>
<ul>
<li>​    <strong>Hostname</strong>   : 仓库地址</li>
<li>​    <strong>Port</strong>：端口</li>
<li>​    <strong>IdentityFile</strong>： 密钥文件</li>
<li>​    <strong>User</strong>： 邮箱地址</li>
</ul>
<h4 id="4）测试连接"><a href="#4）测试连接" class="headerlink" title="4）测试连接"></a>4）测试连接</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hi xxx! You've successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<p>说明已经配置成功，可以新建个文件夹推点东西测试下了</p>
<h3 id="3-hexo安装"><a href="#3-hexo安装" class="headerlink" title="3. hexo安装"></a>3. hexo安装</h3><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p>
<p>官网： <a href="http://hexo.io/" target="_blank" rel="noopener">http://hexo.io</a></p>
<p>github: <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a></p>
<ol>
<li><p>打开命令行（Windows建议使用git bash）全局安装hexo</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个hexo安装目录，f:/hexo ,并切换到该目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化hexo，自动下载一些文件到该目录，包括node_modules</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g #生成相关文件</span><br><span class="line">hexo s #启动本地预览，默认访问地址http://localhost:4000</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一次初始化，hexo会生成示例 Hello World，使用默认主题，可通过配置文件更改主题。</p>
</li>
</ol>
<h3 id="4-更改主题"><a href="#4-更改主题" class="headerlink" title="4. 更改主题"></a>4. 更改主题</h3><p>官网主题地址：<strong><em><a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></em></strong></p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_03.png" alt="hexo_themes"></p>
<ul>
<li><p>选择一款自己喜欢的主题进入主题，去github上复制地址</p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_04.png" alt="get_theme_code"></p>
</li>
</ul>
<ul>
<li><p>然后进入<strong>hexo/theme</strong> 目录下，打开 <code>git bash</code> 输入<code>git clone</code> 地址 拉取主题，或者 在 <strong>github</strong> 上直接下载项目，然后复制到 <strong>theme</strong> 文件夹下</p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_05.png" alt="pull_theme_code"></p>
</li>
</ul>
<ul>
<li><p>修改hexo主题配置: 修改hexo配置文件 <code>hexo/_config.yml</code></p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_06.png" alt="theme_setting"></p>
</li>
</ul>
<ul>
<li><p>重新生成，本地预览在<code>hexo/</code>目录打开<code>git bash</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g #打包</span><br><span class="line">hexo s #本地启动</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="5-查看效果"><a href="#5-查看效果" class="headerlink" title="5. 查看效果"></a>5. 查看效果</h3><p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_07.png" alt></p>
<h2 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h2><p><strong>安装部署插件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure>



<p><strong>配置 <code>_config.yml</code> 中关于 <code>deploy</code> 的部分</strong></p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_08.png" alt></p>
<p>其中涂鸦部分是你的 github 用户名</p>
<p><code>repository: git@github.com:username/username.github.io.git</code></p>
<p><strong>部署到github</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_09.png" alt></p>
<p><strong>访问Github Page: <a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a></strong></p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_10.png" alt></p>
<h2 id="Hexo-补充"><a href="#Hexo-补充" class="headerlink" title="Hexo 补充"></a>Hexo 补充</h2><ul>
<li><p>常用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new “postName” #新建文章</span><br><span class="line">hexo new page “pageName” #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help # 查看帮助hexo version #查看Hexo的版本</span><br><span class="line">以上均可简写 例：hexo deploy可写成 hexo d</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>tags 使用</p>
<p>在<code>hexo</code>主目录，使用 <code>hexo n &quot;new-blog&quot;</code> 创建名为 <code>new-blog</code> 的博客。</p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_11.png" alt="img"></p>
<p>会在 hexo/source/_posts文件夹下生成 相应 md文件，md文件自带title信息</p>
<p>使用md编辑器打开如下：</p>
<ul>
<li>title：博客标题</li>
</ul>
</li>
<li><p>date：生成日期</p>
<ul>
<li>tags：标签，多标签格式：[tag,tag，…]</li>
</ul>
</li>
</ul>
<ul>
<li><p>hexo图片引入</p>
<p>编写博文时想要插入图片怎么办，由于最终要在<code>Github Page</code>上显示，所以图片也要上传至<code>github</code>上去，md博文中引入，这里使用<code>hexo</code>的一个插件</p>
<p><strong>安装插件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image –save</span><br></pre></td></tr></table></figure>

<p><strong>更改配置文件_config.yml</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder</span>:<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p><strong>这时运行 <code>hexo n &quot;second-blog&quot;</code>创建新博文时，就会在相同目录下创建一个 同名文件夹<code>second-blog/</code>，将图片资源放入该文件夹下，就可以在博文中引用了</strong></p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_12.png" alt></p>
</li>
</ul>
<p><strong>如果你觉得写的还不错，请给我个 star 吧：<a href="https://github.com/CharleyZZZZ/CharleyZZZZ.github.io" target="_blank" rel="noopener">https://github.com/CharleyZZZZ/CharleyZZZZ.github.io</a></strong></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>[游玩] 五一崇明之行</title>
    <url>/2020/05/07/%E6%B8%B8%E7%8E%A9-%E4%BA%94%E4%B8%80%E5%B4%87%E6%98%8E%E4%B9%8B%E8%A1%8C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>[SpringBoot] SpringBoot学习之自动配置原理</title>
    <url>/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h3><p>SpringBoot给我们开发项目带来了很多方便，其中很大归功于其自动配置功能，但是一直以来我对其实现原理没有仔细探究，这里我们将通过查看源码的方式理解SpringBoot自动配置原理，以及如何优雅的实现自动配置。</p>
<h3 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h3><p>​    <strong>SpringBoot</strong> 项目在启动时会便会自动配置项目的配置项以及加载依赖项目的配置项，其入口在注解<strong>@SpringBootApplication</strong>中的 <strong>@EnabledAutoConfiguration</strong> 注解中</p>
<p>而具体获取需要自动配置的配置类则在 *<em>AutoConfigurationImportSelector *</em>类获取中：</p>
<p><img src="/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/autoconfig_01.png" alt></p>
<p>观察 <strong>AutoConfigurationImportSelector</strong>类的<strong>selectImports</strong> 方法可知：</p>
<p>获取<strong>autoconfigures</strong> 的方式是从 <strong>META-INF/spring.factories</strong> 文件中获取键值为 <strong>EnableAutoConfiguration</strong>类名的自动配置类列表：</p>
<p><img src="/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/autoconfig_02.png" alt></p>
<p><img src="/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/autoconfig_03.png" alt></p>
<p><strong>META-INF/spring.factories:</strong></p>
<p><img src="/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/autoconfig_04.png" alt></p>
<p>任意点开一个自动配置类：</p>
<p>  可以看出来虽然获取到各个模块的自动配置类，但真正是否配置还需取决于注解 <strong>@ConditionalOnXXXX</strong></p>
<p>该类注解判断在配置文件中项目是否开启该功能，或者是否存在某些类（即引入该依赖）才决定自动配置属性或者自动注入相关对象。</p>
<p><strong>@ConditionalOnXXXX</strong> 常用注解如下：</p>
<ul>
<li>@ConditionalOnBean（仅仅在当前上下文中存在某个对象时，才会实例化一个Bean）</li>
<li>@ConditionalOnClass（某个class位于类路径上，才会实例化一个Bean）</li>
<li>@ConditionalOnExpression（当表达式为true的时候，才会实例化一个Bean</li>
<li>@ConditionalOnMissingBean（仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean</li>
<li>@ConditionalOnMissingClass（某个class类路径上不存在的时候，才会实例化一个Bean</li>
<li>@ConditionalOnNotWebApplication（不是web应用)</li>
<li>@ConditionalOnProperty （控制某个configuration是否生效。具体操作是通过其两个属性name以及havingValue来实现的，其中name用来从application.properties中读取某个属性值，如果该值为空，则返回false;如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。如果返回值为false，则该configuration不生效；为true则生效）</li>
</ul>
<p><img src="/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/autoconfig_05.png" alt></p>
<p>综上可知，<strong>SpringBoot</strong>在项目启动时，通过注解 <strong>@EnabledAutoConfiguration</strong> 从 <strong>META-INF/spring.factories</strong> 中获取需要配置的配置类，这些配置类都是各个常用模块的自动配置，例如<strong>jdbc</strong>，<strong>aop</strong>，<strong>redis</strong>，<strong>amqp</strong>等，而配置类中通过<strong>@ConditionalOnXXXX</strong>注解判断项目是否引入或者开启该功能，如果确认项目引入或开启了该功能则自动配置相关项到上下文中。而不需要人工再配置，大大节省了工作量。</p>
<h3 id="自定义starter自动配置"><a href="#自定义starter自动配置" class="headerlink" title="自定义starter自动配置"></a>自定义starter自动配置</h3><h4 id="META-INF-spring-factories配置"><a href="#META-INF-spring-factories配置" class="headerlink" title="META-INF/spring.factories配置"></a>META-INF/spring.factories配置</h4><p>如果我们要引入自定义starter ，该如何使其自动配置呢。</p>
<p>思路很简单：</p>
<p>​    在自定义<strong>starter</strong>中添加<strong>AutoConfiguration</strong>配置类，将该<strong>starter</strong>需要的相关配置放在里面，然后再resources目录下新建 <strong>META-INF/spring.factories</strong>文件，仿照<strong>spring-boot-autoconfiguration</strong> 项目将我们的自动配置类配置进去，然后在主项目中引入就可以实现自动配置了，</p>
<p>当然我们也可以给该自定义功能添加开关，例如添加配置 <strong>xxxx.enabled = true</strong> 开启</p>
<p>在 <strong>AutoConfiguration</strong> 配置类上添加注解 <strong>@ConditionalOnProperty</strong> 控制当<strong>xxxx.enabled = true</strong> 时才自动配置</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.autoconfiguration.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.autoconfiguration.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> demo自动配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/5/8 15:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(</span><br><span class="line">        prefix = <span class="string">"demo.admin"</span>,</span><br><span class="line">        value = &#123;<span class="string">"enabled"</span>&#125;,</span><br><span class="line">        havingValue = <span class="string">"true"</span>,</span><br><span class="line">        matchIfMissing = <span class="keyword">false</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动注入Bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">userDetails</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDetails(<span class="string">"张三"</span>, <span class="number">21</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.autoconfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 用户动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/5/8 15:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISpeak</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给用户一个说的动作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.autoconfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/5/8 15:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetails</span> <span class="keyword">implements</span> <span class="title">ISpeak</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDetails</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello，我叫"</span> + <span class="keyword">this</span>.name + <span class="string">", 我今年"</span> + <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在resources下新建 目录 META-INF目录：</p>
<p>分别添加如下文件：配置数据元数据配置，当输入该属性时会有自动提示</p>
<p><strong>spring-configuration-metadata.json</strong>  ：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"demo.admin.enabled"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"java.lang.Boolean"</span>,</span><br><span class="line">      <span class="attr">"defaultValue"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>spring.factories</strong> :</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">com.demo.autoconfiguration.config.DemoAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<p><strong>pom.xml</strong> :</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>autoconfiguration<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>autoconfiguration<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;optional&gt;true&lt;/optional&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而在主项目中只需要引入该依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>autoconfiguration<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.properties 中开启功能：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">demo.admin.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>启动项目，Controller中测试，Postman模拟调用结果：</p>
<p><img src="/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/autoconfig_06.png" alt></p>
<h4 id="注解的方式配置"><a href="#注解的方式配置" class="headerlink" title="注解的方式配置"></a>注解的方式配置</h4><p>除了上面的方式也可以通过注解的方式，那就不用在 <strong>META-INF/spring.factories</strong> 中添加配置类了。</p>
<p><strong>starter</strong> 项目中添加注解 <strong>@EnabledDemoAutoconfiguration</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.autoconfiguration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.autoconfiguration.config.DemoAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 自动配置注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/5/8 17:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;DemoAutoConfiguration<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnabledDemoAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解上添加 <strong>@Import({DemoAutoConfiguration.class})</strong> 将我们的自动配置类导入进来</p>
<p>而在主项目中 启动类或已加载的配置类上添加 该注解即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 添加Demo-starter自动配置</span></span><br><span class="line"><span class="meta">@EnabledDemoAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootLogging02Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(SpringBootLogging02Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SpringBoot自动配置说明就到这了，谢谢。。。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>自动配置</tag>
      </tags>
  </entry>
  <entry>
    <title>[SpringBoot] SpringBoot学习之日志管理</title>
    <url>/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h2><p>对于一个应用程序来说日志记录是必不可少的一部分，线上问题追踪，基于日志的业务逻辑统计分析等都离不开日志。</p>
<p>java中常见的的日志框架有：Log4j、Log4j2、Logback、JCL(Jakarta Commons Logging)、Slf4j(Simple Logging Façade for Java)、JUL(java.util.logging)、Jboss-logging ,这些框架有些是日志的抽象层，例如 JCL、SLF4J、Jboss-logging,而另一部分则是日志的实现 :Log4j、Log4j2、JUL、Logback</p>
<p><strong>在srpingBoot中使用的是 SLF4j + Logback 组合</strong></p>
<p><strong>准备：</strong></p>
<p>知识储备：</p>
<ul>
<li>熟练掌握SPRING，SPRINGMVC</li>
<li>了解springBoot的基本开发</li>
<li>了解至少一种日志框架的简单使用、应用场景以及基本配置</li>
</ul>
<p>环境条件：</p>
<ul>
<li>jdk1.8</li>
<li>maven4.0.0</li>
<li>IntelliJ IDEA 2017</li>
<li>Spring Boot 1.5.9.RELEASE</li>
</ul>
<p>学习计划：</p>
<ul>
<li>了解当前主流日志框架，优缺点对比，选型方案</li>
<li>学习springBoot日志框架原理</li>
<li>学习对springBoot日志管理的使用、基本配置以及高级特性</li>
<li>特定需求下，如何统一、更换项目日志框架。</li>
</ul>
<h2 id="日志框架简介"><a href="#日志框架简介" class="headerlink" title="日志框架简介"></a>日志框架简介</h2><h3 id="1-Java日志框架的发展与选择"><a href="#1-Java日志框架的发展与选择" class="headerlink" title="1. Java日志框架的发展与选择"></a>1. Java日志框架的发展与选择</h3><h4 id="日志框架的发展"><a href="#日志框架的发展" class="headerlink" title="日志框架的发展"></a>日志框架的发展</h4><blockquote>
<p>1996年早期，欧洲安全电子市场项目组决定编写它自己的程序跟踪API(Tracing API)。经过不断的完善，这个API终于成为一个十分受欢迎的Java日志软件包，即Log4j。后来Log4j成为Apache基金会项目中的一员。</p>
<p>期间Log4j近乎成了Java社区的日志标准。据说Apache基金会还曾经建议sun引入Log4j到java的标准库中，但Sun拒绝了。</p>
<p>2002年Java1.4发布，Sun推出了自己的日志库JUL(Java Util Logging),其实现基本模仿了Log4j的实现。在JUL出来以前，log4j就已经成为一项成熟的技术，使得log4j在选择上占据了一定的优势。</p>
<p>接着，Apache推出了Jakarta Commons Logging，JCL只是定义了一套日志接口(其内部也提供一个Simple Log的简单实现)，支持运行时动态加载日志组件的实现，也就是说，在你应用代码里，只需调用Commons Logging的接口，底层实现可以是log4j，也可以是Java Util Logging。</p>
<p>后来(2006年)，Ceki Gülcü不适应Apache的工作方式，离开了Apache。然后先后创建了slf4j(日志门面接口，类似于Commons Logging)和Logback(Slf4j的实现)两个项目，并回瑞典创建了QOS公司，QOS官网上是这样描述Logback的：The Generic，Reliable Fast&amp;Flexible Logging Framework(一个通用，可靠，快速且灵活的日志框架)。</p>
<p>现今，Java日志领域被划分为两大阵营：Commons Logging阵营和SLF4J阵营。</p>
<p>Commons Logging在Apache大树的笼罩下，有很大的用户基数。但有证据表明，形式正在发生变化。2013年底有人分析了GitHub上30000个项目，统计出了最流行的100个Libraries，可以看出slf4j的发展趋势更好：</p>
<p>Apache眼看有被Logback反超的势头，于2012-07重写了log4j 1.x，成立了新的项目Log4j 2。Log4j 2具有logback的所有特性。</p>
<p>​                                                                                                                                                       —– 引用自Internet</p>
</blockquote>
<p><strong>总结：</strong></p>
<table>
<thead>
<tr>
<th>日志门面（日志抽象层）</th>
<th align="left">日志实现</th>
</tr>
</thead>
<tbody><tr>
<td>JCL(Jakarta Commons Logging)          SLF4j(Simple Logging Facade for Java)       jboss-logging</td>
<td align="left">Log4j     JUL(java.util.logging)  Log4j2      Logback</td>
</tr>
</tbody></table>
<ul>
<li><p>当前Java日志领域分为俩大阵营，SLF4J 和 Commons-Logging阵营。这俩种都是日志门面，SLF4J本身并无日志的实现，JCL定义了一套日志接口，其内部提供了Simple Log的实现。</p>
</li>
<li><p>log4j和Logback则是具体的日志实现方案。可以简单的理解为接口与接口的实现，调用这只需要关注接口而无需关注具体的实现，做到解耦。</p>
</li>
<li><p>比较常用的组合是 Slf4j 与Logback 组合，Commons-logging 与Log4j的组合。</p>
</li>
<li><p>Log4j2与Log4j发生了很大的变化，log4j2不兼容log4j。</p>
</li>
<li><p>Logback必须配合Slf4j，因为他们是同一作者兼容性好。</p>
</li>
</ul>
<h4 id="日志框架的选择"><a href="#日志框架的选择" class="headerlink" title="日志框架的选择"></a>日志框架的选择</h4><p><strong>目前在新的项目中建议使用   Slf4j + Logback   的组合做为日志管理。</strong></p>
<ul>
<li><p>从日志门面上比较。<strong>Slf4j</strong> 的实现机制决定其限制较少，适用范围更广，通用性高。同时，相比于Commons-logging，<strong>Slf4j</strong>对于内存和CPU等资源的开销更小。</p>
</li>
<li><p>在日志的实现上比较，<strong>Logback</strong> 相比于其他日志实现框架拥有更好的性能，其次<strong>Logback</strong>的文档免费，对于开发者而言，相对有利。</p>
</li>
</ul>
<h3 id="2-SLF4j-框架的使用"><a href="#2-SLF4j-框架的使用" class="headerlink" title="2. SLF4j 框架的使用"></a>2. SLF4j 框架的使用</h3><p><strong>SLF4j 官网</strong>：<strong><em><a href="https://www.slf4j.org" target="_blank" rel="noopener">https://www.slf4j.org</a></em></strong></p>
<p>开发中，日志记录方法的调用，不应该直接调用日志的实现类，而是调用日志抽象层里的方法。</p>
<h4 id="SLF4j-框架的简单使用"><a href="#SLF4j-框架的简单使用" class="headerlink" title="SLF4j 框架的简单使用"></a>SLF4j 框架的简单使用</h4><p>导入SLF4j和 Logback 的jar 包。</p>
<p>SLF4j本身并无实现，所以得导入实现类jar 包，这里使用Logback，参照<code>spring-boot-starter-logging</code>：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_01.png" alt="spring-boot-starter-logging"></p>
<p>代码中使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SLF4j-与其他日志组件的桥接"><a href="#SLF4j-与其他日志组件的桥接" class="headerlink" title="SLF4j 与其他日志组件的桥接"></a>SLF4j 与其他日志组件的桥接</h4><p>SLF4j不仅可以与Logback组合，还可以与其他日志的实现框架组合，实现方法，可以参照官方文档：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_02.png" alt></p>
<ul>
<li><p>只导入slf4j 的jar包，没有实现类，指向<strong>/dev/null</strong></p>
</li>
<li><p>导入slf4j 的 jar包，也导入和其实现类的jar包，例如<strong>logback</strong>、<strong>slf4j-simple</strong>等，可以正常使用，</p>
</li>
<li><p>如果要使用<strong>log4j</strong>、<strong>JUL</strong>等非<strong>sfl4j</strong>阵营的实现类，只需要多导入一个适配层 的jar包即可，例如：slf4j-log412.jar 、slf4j-jdk14.jar等</p>
</li>
<li><p>每个日志的实现框架都有自己的配置文件。选用什么实现框架，就配置相关的配置文件，与<strong>SLF4j</strong>无关。</p>
</li>
</ul>
<h4 id="SLF4j-统一项目日志框架"><a href="#SLF4j-统一项目日志框架" class="headerlink" title="SLF4j 统一项目日志框架"></a>SLF4j 统一项目日志框架</h4><p><strong>问题记录：</strong>项目使用（SLF4j+Logback）作为日志框架，而项目中依赖的其他框架，例如Spring、Hibernate、Mybits等，他们的底层都使用了日志框架，而且各不相同：</p>
<table>
<thead>
<tr>
<th>其他框架</th>
<th>日志选型</th>
</tr>
</thead>
<tbody><tr>
<td>Spring</td>
<td>Commons-logging</td>
</tr>
<tr>
<td>Hibernate</td>
<td>Jboss-logging</td>
</tr>
<tr>
<td>Mybatis</td>
<td>Log4j</td>
</tr>
<tr>
<td>….</td>
<td>….</td>
</tr>
</tbody></table>
<p><strong>如何统一日志框架，SLF4j官方文档也给出了解决办法：</strong></p>
<img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_03.png" style="zoom:120%;">



<p><strong>以 Spring为例：</strong></p>
<p><strong>项目：SLF4J + Logback</strong> </p>
<p><strong>Spring：Commons-logging API</strong></p>
<p>那么如果我们想在项目中统一使用Logback去统一日志管理</p>
<p>只需要用jcl-over-slf4j.jar  包去替换 commons-logging.jar包即可。</p>
<p>步骤：</p>
<ul>
<li><p>将系统中其他日志框架先排除出去</p>
</li>
<li><p>用中间包来替换原有的日志框架</p>
</li>
<li><p>导入slf4j 其他的实现包</p>
</li>
</ul>
<p><strong>同样的，如果 项目中使用的是 Slf4j + 其他日志框架 的也可以使用这种方式统一日志框架。</strong></p>
<ul>
<li><p>首先将系统中其他日志框架先排除出去</p>
</li>
<li><p>用中间包来替换原有的日志框架</p>
</li>
<li><p>导入slf4j 其他的实现包</p>
</li>
</ul>
<img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_04.png">



<h4 id="问题：为什么导入替换这些包就可以统一日志框架？"><a href="#问题：为什么导入替换这些包就可以统一日志框架？" class="headerlink" title="问题：为什么导入替换这些包就可以统一日志框架？"></a>问题：为什么导入替换这些包就可以统一日志框架？</h4><p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_05.png" alt></p>
<p>查看 <code>jcl-over-slf4j.jar</code> 包可以看到，虽然 jar 包名称叫 <code>jcl-over-slf4j.jar</code> ，但是内部的包名确是<code>org.apache.commons.logging</code> ,项目中排除了jcl的依赖，当Spring框架去寻找日志部分的代码时会走到这里，而这里的<code>LogFactory</code> 实例化时创建的也是<code>SLF4JlogFactory</code>。作者就是通过这种方式实现了偷梁换柱，以此做到日志框架的统一的目的。</p>
<h2 id="SpringBoot中的日志框架"><a href="#SpringBoot中的日志框架" class="headerlink" title="SpringBoot中的日志框架"></a>SpringBoot中的日志框架</h2><p><strong>Spring-boot-starter-logging</strong> 使用 <strong>SLF4j + Logback</strong>。当然SpringBoot也能自动适配<strong>（jul、log4j、logback）</strong>并简化配置。</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_06.png" alt></p>
<h3 id="1-新建SpringBoot项目"><a href="#1-新建SpringBoot项目" class="headerlink" title="1. 新建SpringBoot项目"></a>1. 新建SpringBoot项目</h3><p>选择 Spring Initializer 快速创建。</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_07.png" alt></p>
<p>选择web 模块，方便测试，SpringBoot 版本选择 1.5.9，也可以再pom.xml中更改。</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_08.png" alt></p>
<p>点击Next ，再 点击Finish。</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_09.png" alt></p>
<h3 id="2-SpringBoot默认日志级别以及配置方法"><a href="#2-SpringBoot默认日志级别以及配置方法" class="headerlink" title="2. SpringBoot默认日志级别以及配置方法"></a>2. SpringBoot默认日志级别以及配置方法</h3><p>在自带的Test 方法中 <code>LoggerFactory.getLogger(getClass());</code> 创建创建日志对象。分别输出 trace、debug、info、warn、error级别的日志，右键运行Test ：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_10.png" alt></p>
<p>SpringBoot 默认输出日志级别是info 及以后的级别：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_11.png" alt></p>
<p><strong>想要更改默认输出级别，可以在application.properties文件中配置。</strong></p>
<h4 id="1）logging-level-root-debug-更改更改springBoot-默认级别"><a href="#1）logging-level-root-debug-更改更改springBoot-默认级别" class="headerlink" title="1）logging.level.root=debug 更改更改springBoot 默认级别"></a>1）logging.level.root=debug 更改更改springBoot 默认级别</h4><p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_12.png" alt></p>
<h4 id="2）-还可以设置指定的包文件下的日志级别："><a href="#2）-还可以设置指定的包文件下的日志级别：" class="headerlink" title="2） 还可以设置指定的包文件下的日志级别："></a>2） 还可以设置指定的包文件下的日志级别：</h4><p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_13.png" alt></p>
<h3 id="3-配置日志导出到文件"><a href="#3-配置日志导出到文件" class="headerlink" title="3. 配置日志导出到文件"></a>3. 配置日志导出到文件</h3><h4 id="1）只指定文件名"><a href="#1）只指定文件名" class="headerlink" title="1）只指定文件名"></a>1）只指定文件名</h4><p>使用 <code>logging-file</code> 指定文件名：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_14.png" alt></p>
<h4 id="2）指定文件名-路径"><a href="#2）指定文件名-路径" class="headerlink" title="2）指定文件名  + 路径"></a>2）指定文件名  + 路径</h4><p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_15.png" alt></p>
<h4 id="3）指定文件路径"><a href="#3）指定文件路径" class="headerlink" title="3）指定文件路径"></a>3）指定文件路径</h4><p>使用 <code>logging.path</code> 指定日志文件生成路径，默认文件名：<code>spring.log</code></p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_16.png" alt></p>
<h3 id="4-配置日志格式"><a href="#4-配置日志格式" class="headerlink" title="4. 配置日志格式"></a>4. 配置日志格式</h3><h4 id="1）控制台日志格式"><a href="#1）控制台日志格式" class="headerlink" title="1）控制台日志格式"></a>1）控制台日志格式</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_17.png" alt></p>
<p>我们也可以自定义格式，例如：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_18.png" alt></p>
<p><strong>格式设置说明：</strong></p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_19.png" alt></p>
<h4 id="2）更改输出文件日志格式"><a href="#2）更改输出文件日志格式" class="headerlink" title="2）更改输出文件日志格式"></a>2）更改输出文件日志格式</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_20.png" alt></p>
<h2 id="SpringBoot日志默认配置原理及高级特性"><a href="#SpringBoot日志默认配置原理及高级特性" class="headerlink" title="SpringBoot日志默认配置原理及高级特性"></a>SpringBoot日志默认配置原理及高级特性</h2><h3 id="1-Spring-Boot-日志默认配置及原理"><a href="#1-Spring-Boot-日志默认配置及原理" class="headerlink" title="1. Spring Boot 日志默认配置及原理"></a>1. Spring Boot 日志默认配置及原理</h3><p>为什么Spring Boot 默认配置了日志级别、日志默认文件名、日志格式等属性，查看SpringBoot源码可解：</p>
<img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_21.png" style="zoom: 50%;">

<p>以<strong>Logback</strong>为例，在<code>org.springframework.boot</code> 包里，已经配置好了相关日志框架的基本配置。</p>
<p><strong>base.xml:</strong></p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_22.png" alt></p>
<p><strong>defaut.xml:</strong></p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_23.png" alt></p>
<p><strong>此外，在<code>LoggingSystemProperties</code>中也设置了相关属性的默认值。</strong></p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_24.png" alt></p>
<h3 id="3-添加指定配置"><a href="#3-添加指定配置" class="headerlink" title="3. 添加指定配置"></a>3. 添加指定配置</h3><h4 id="问题：SpringBoot中只记录了日志实现框架的基本功能，如果我们要使用日志框架的高级功能该怎么做？"><a href="#问题：SpringBoot中只记录了日志实现框架的基本功能，如果我们要使用日志框架的高级功能该怎么做？" class="headerlink" title="问题：SpringBoot中只记录了日志实现框架的基本功能，如果我们要使用日志框架的高级功能该怎么做？"></a>问题：SpringBoot中只记录了日志实现框架的基本功能，如果我们要使用日志框架的高级功能该怎么做？</h4><p><strong>参考官方文档：</strong></p>
<table>
<thead>
<tr>
<th>Logging System</th>
<th>Customization</th>
</tr>
</thead>
<tbody><tr>
<td>Logback</td>
<td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code> ,<code>logback.xml</code>  or <code>logback.groovy</code></td>
</tr>
<tr>
<td>Log4j2</td>
<td><code>log4j2-spring.xml</code>  or  <code>log4j2.xml</code></td>
</tr>
<tr>
<td>JUL(Java Util Logging)</td>
<td><code>logging.properties</code></td>
</tr>
</tbody></table>
<p>我们只需要在资源文件夹下添加相关框架的配置文件即可：</p>
<p>以Logback 为例：添加logback-spring.xml, logback-spring.groovy, logback.xml 或者logback.groovy 文件，然后在里面编写相关配置即可。</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_25.png" alt></p>
<p>运行项目看是否已更改</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_26.png" alt></p>
<h3 id="4-Spring-Boot-日志管理高级特性"><a href="#4-Spring-Boot-日志管理高级特性" class="headerlink" title="4. Spring Boot 日志管理高级特性"></a>4. Spring Boot 日志管理高级特性</h3><p>​      上面提到添加指定配置可以引入<code>logback.xml</code> 也可以是 <code>logback-spring.xml</code> (以Logback为例)，那么俩者的区别是什么？</p>
<p>​      区别在于 <code>logback.xml</code> 其实是直接被底层框架<strong>Logback</strong>识别，而 <code>logback-spring.xml</code> 是被<strong>SpringBoot</strong>识别加载，这样的好处是<strong>SpringBoot</strong>可以添加一些日志实现框架以外的高级功能。</p>
<p>例如：</p>
<p><strong>SpringBoot</strong>支持添加 <springProfile> 标签设置不同环境的日志配置。</springProfile></p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_27.png" alt></p>
<p>默认不是dev环境：</p>
<p>设置：<strong><code>spring.profile.active=dev</code></strong>  激活dev环境后</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_28.png" alt></p>
<h2 id="切换SpringBoot日志实现框架"><a href="#切换SpringBoot日志实现框架" class="headerlink" title="切换SpringBoot日志实现框架"></a>切换SpringBoot日志实现框架</h2><p><strong>SpringBoot</strong> 默认使用的是 <strong>SLF4J + Logback *<em>的方式实现日志管理，如果我们想用 *</em>SLF4j + Log4j</strong> 的方式该如何实现。</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_02.png" alt></p>
<p>依据官方文档：</p>
<h4 id="1-排除-Logback-相关-jar-包"><a href="#1-排除-Logback-相关-jar-包" class="headerlink" title="1.  排除 Logback 相关 jar 包"></a>1.  排除 Logback 相关 jar 包</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--排除Logback相关jar包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--排除log4j转换包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-导入-Log4j-相关-jar-包"><a href="#2-导入-Log4j-相关-jar-包" class="headerlink" title="2. 导入 Log4j 相关 jar 包"></a>2. 导入 Log4j 相关 jar 包</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-查看依赖树"><a href="#3-查看依赖树" class="headerlink" title="3. 查看依赖树"></a>3. 查看依赖树</h4><p>右键 -&gt; Diagrams -&gt; Show Dependencies</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_29.png" alt></p>
<p>运行项目Test，查看日志输出格式，已更改为log4j默认输出格式：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_30.png" alt></p>
<h4 id="4-统一日志框架"><a href="#4-统一日志框架" class="headerlink" title="4. 统一日志框架"></a>4. 统一日志框架</h4><p>方式如1.2 SLF4j统一日志记录  方式相同。</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_04.png" alt></p>
<h4 id="5-另一种切换方式"><a href="#5-另一种切换方式" class="headerlink" title="5. 另一种切换方式"></a>5. 另一种切换方式</h4><p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_31.png" alt></p>
<p><strong>SpringBoot</strong> 默认使用<code>spring-boot-starter-logging</code> ，其底层使用的是 <strong>Slf4j + logback</strong></p>
<p>而官方提供另外的 starter：<code>spring-boot-starter-log4j2</code>，其使用的则是 <strong>log4j2</strong> 作为日志的实现。所以我们只需排除掉 <code>spring-boot-starter-logging</code>，然后再引入<code>spring-boot-starter-log4j2</code>，就可以做到由 <strong>Logback</strong> 到 <strong>log4j2</strong> 的切换。</p>
<p>排除 spring-boot-starter-logging：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_32.png" alt></p>
<p><strong>pom.xml</strong></p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_33.png" alt></p>
<p>再看下 依赖树：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_34.png" alt></p>
<p>以上就是关于 Spring Boot 日志框架学习的全部内容，从相识到相知，希望你看过这篇文章后对springBoot日志部分有个更深入了解，谢谢！</p>
<p><strong>如果你觉得写的还不错，请给我个 star 吧：<a href="https://github.com/CharleyZZZZ/CharleyZZZZ.github.io" target="_blank" rel="noopener">https://github.com/CharleyZZZZ/CharleyZZZZ.github.io</a></strong></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>日志管理</tag>
      </tags>
  </entry>
  <entry>
    <title>[SpringBoot] SpringBoot学习之启动配置原理</title>
    <url>/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h2><p><strong>为了更深入掌握SpringBoot的核心技术，我们需要从第一步项目启动开始，了解SpringBoot的启动原理，运行流程，自动配置原理。</strong></p>
<p><strong>知识储备：</strong></p>
<ul>
<li><p>熟练掌握SPRING，SPRINGMVC，掌握各种监听器的作用和使用方法。</p>
</li>
<li><p>掌握使用SpringBoot创建简单项目</p>
</li>
<li><p>熟练使用Eclipse或者IDEA</p>
</li>
</ul>
<p><strong>环境条件：</strong></p>
<ul>
<li><p>jdk1.8</p>
</li>
<li><p>maven4.0.0</p>
</li>
<li><p>IntelliJ IDEA 2017</p>
</li>
<li><p>Spring Boot 1.5.9.RELEASE；</p>
</li>
</ul>
<p><strong>学习计划：</strong></p>
<ul>
<li><p>Debug方式跑完启动流程。</p>
</li>
<li><p>了解SpringBoot启动原理以及自动配置原理</p>
</li>
<li><p>自定义监听器</p>
</li>
</ul>
<h2 id="Spring-Boot-启动配置原理剖析"><a href="#Spring-Boot-启动配置原理剖析" class="headerlink" title="Spring Boot 启动配置原理剖析"></a>Spring Boot 启动配置原理剖析</h2><p><strong>新建SpringBoot项目，在main方法里打断点，通过调试的方法一步一步分析SpringBoot启动流程。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootLogging02Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在此处打断点进入</span></span><br><span class="line">		SpringApplication.run(SpringBootLogging02Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>F7进入方法，可以看到主要分为俩大步：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Static helper that can be used to run a &#123;<span class="doctag">@link</span> SpringApplication&#125; from the</span></span><br><span class="line"><span class="comment"> * specified sources using default settings and user supplied arguments.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sources the sources to load</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Object[] sources, String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(sources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>new SpringApplication(sources)   创建SpringApplication</strong></p>
</li>
<li><p><strong>run(args)  运行SpringApplication</strong></p>
</li>
</ul>
<p>接下来将分别来看：</p>
<h3 id="1-创建-SpringApplication"><a href="#1-创建-SpringApplication" class="headerlink" title="1.创建 SpringApplication"></a>1.创建 SpringApplication</h3><p><strong>进入SpringApplication的构造器内：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new &#123;<span class="doctag">@link</span> SpringApplication&#125; instance. The application context will load</span></span><br><span class="line"><span class="comment"> * beans from the specified sources (see &#123;<span class="doctag">@link</span> SpringApplication class-level&#125;</span></span><br><span class="line"><span class="comment"> * documentation for details. The instance can be customized before calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #run(String...)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sources the bean sources</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #run(Object, String[])</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #SpringApplication(ResourceLoader, Object...)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(Object... sources)</span> </span>&#123;</span><br><span class="line">	initialize(sources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Object[] sources)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sources != <span class="keyword">null</span> &amp;&amp; sources.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 添加 source</span></span><br><span class="line">		<span class="keyword">this</span>.sources.addAll(Arrays.asList(sources));</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 判断web环境</span></span><br><span class="line">	<span class="keyword">this</span>.webEnvironment = deduceWebEnvironment();</span><br><span class="line">       <span class="comment">// 设置Initializers</span></span><br><span class="line">	setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">			ApplicationContextInitializer<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">       <span class="comment">// 设置Listeners</span></span><br><span class="line">	setListeners(</span><br><span class="line">           (Collection) getSpringFactoriesInstances(ApplicationListener<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">       <span class="comment">// 判断main方法</span></span><br><span class="line">	<span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由初始化方法分析以下步骤：</p>
<h4 id="配置资源-：读取主配置类"><a href="#配置资源-：读取主配置类" class="headerlink" title="配置资源 ：读取主配置类"></a>配置资源 ：读取主配置类</h4><p><img src="/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/springboot_start_01.png" alt></p>
<h4 id="判断Web环境"><a href="#判断Web环境" class="headerlink" title="判断Web环境"></a>判断Web环境</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] WEB_ENVIRONMENT_CLASSES = &#123; <span class="string">"javax.servlet.Servlet"</span>,</span><br><span class="line">		<span class="string">"org.springframework.web.context.ConfigurableWebApplicationContext"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">deduceWebEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (String className : WEB_ENVIRONMENT_CLASSES) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>即通过判断是否存在以下类，来判断是否是web应用：</strong></p>
<ul>
<li><p>javax.servlet.Servlet</p>
</li>
<li><p>org.springframework.web.context.ConfigurableWebApplicationContext</p>
</li>
</ul>
<h4 id="保存-ApplicationContextInitializer"><a href="#保存-ApplicationContextInitializer" class="headerlink" title="保存 ApplicationContextInitializer"></a>保存 ApplicationContextInitializer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123;</span><br><span class="line">	<span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,</span><br><span class="line">		Class&lt;?&gt;[] parameterTypes, Object... args) &#123;</span><br><span class="line">	ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">	<span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">       <span class="comment">// 加载 ApplicationContextInitializer 类型的类</span></span><br><span class="line">	Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(</span><br><span class="line">			SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">       <span class="comment">// 创建实例</span></span><br><span class="line">	List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">			classLoader, args, names);</span><br><span class="line">       <span class="comment">// 排序</span></span><br><span class="line">	AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">	<span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里通过<strong>SpringFactoriesLoaler</strong>加载 <strong>ApplicationContextInitializer</strong> 类型的类<br>        Set<String> names = new LinkedHashSet<String>(<br>                SpringFactoriesLoader.loadFactoryNames(type, classLoader));</String></String></p>
<p>进入 <strong>SpringFactoriesLoader.loadFactoryNames</strong> 方法后发现，就是从类路径<strong>META-INF/spring.factories</strong> 内加载所有的 <strong>ApplicationContextInitializer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The location to look for factories.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Can be present in multiple JAR files.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-	INF/spring.factories"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载META-INF/spring.factories 文件中定义的类</span></span><br><span class="line">Enumeration&lt;URL&gt; urls = </span><br><span class="line">    (classLoader != <span class="keyword">null</span> ?classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">				ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">	URL url = urls.nextElement();</span><br><span class="line">	Properties properties=PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(url));</span><br><span class="line">	String factoryClassNames = properties.getProperty(factoryClassName);</span><br><span class="line">	result.addAll(Arrays.asList(</span><br><span class="line">        StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>



<p>在源码包中可以找到：<strong>META-INF/spring.factories</strong>：</p>
<p><img src="/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/springboot_start_02.png" alt></p>
<h4 id="保存-ApplicationListener"><a href="#保存-ApplicationListener" class="headerlink" title="保存 ApplicationListener"></a>保存 ApplicationListener</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与上一步类似，也是从 META-INF/spring.factories 中读取类，并实例化，</span></span><br><span class="line"><span class="comment">// 最后放到SpringApplication的 listeners 属性中</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/springboot_start_03.png" alt></p>
<h4 id="获取main方法"><a href="#获取main方法" class="headerlink" title="获取main方法"></a>获取main方法</h4><p><img src="/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/springboot_start_04.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 main入口 的方法</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line">		<span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">"main"</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">				<span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">		<span class="comment">// Swallow and continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此，SpringApplication对象创建完成了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>保存主配置类</p>
</li>
<li><p>判断web应用</p>
</li>
<li><p><strong>从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后实例化，保存起来</strong></p>
</li>
<li><p><strong>从类路径下找到META-INF/spring.factories配置的所有ApplicationListener；然后实例化，保存起来</strong></p>
</li>
<li><p>获取main方法位置</p>
</li>
</ul>
<h3 id="2-运行SpringApplication-run-String…-args"><a href="#2-运行SpringApplication-run-String…-args" class="headerlink" title="2. 运行SpringApplication.run(String… args)"></a>2. 运行SpringApplication.run(String… args)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the Spring application, creating and refreshing a new</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">	StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">	stopWatch.start();</span><br><span class="line">	ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">	FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">	configureHeadlessProperty();</span><br><span class="line">       <span class="comment">// 获取SpringApplicationRunListener</span></span><br><span class="line">	SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">       <span class="comment">// 回调 starting() 方法</span></span><br><span class="line">	listeners.starting();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 获取命令行参数</span></span><br><span class="line">		ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">				args);</span><br><span class="line">           <span class="comment">// 准备环境</span></span><br><span class="line">		ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">				applicationArguments);</span><br><span class="line">           <span class="comment">// 打印控制台</span></span><br><span class="line">		Banner printedBanner = printBanner(environment);</span><br><span class="line">           <span class="comment">// 创建上下文 context</span></span><br><span class="line">		context = createApplicationContext();</span><br><span class="line">           <span class="comment">// 启动异常拦截</span></span><br><span class="line">		analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">           <span class="comment">// 准备上下文 </span></span><br><span class="line">		prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">				printedBanner);</span><br><span class="line">           <span class="comment">// 刷新（初始化）上下文</span></span><br><span class="line">		refreshContext(context);</span><br><span class="line">		afterRefresh(context, applicationArguments);</span><br><span class="line">           <span class="comment">// 回调 listeners 的 finished 方法</span></span><br><span class="line">		listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">		stopWatch.stop();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">			<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">					.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析该方法得知 run方法 主要做了以下几件事：</strong></p>
<ul>
<li><p>获取SpringApplicationRunListener，并回调starting方法</p>
</li>
<li><p>准备、配置环境信息</p>
</li>
<li><p>创建上下文（IOC容器）</p>
</li>
<li><p>准备（初始化）上下文</p>
</li>
<li><p>初始化 IOC 容器</p>
</li>
<li><p>IOC容器中获取ApplicationRunner和CommandLineRunner并回调</p>
</li>
<li><p>所有的SpringApplicationRunListener，回调finished方法</p>
</li>
<li><p>返回ioc容器</p>
</li>
</ul>
<h4 id="获取SpringApplicationRunListener，并回调starting-方法"><a href="#获取SpringApplicationRunListener，并回调starting-方法" class="headerlink" title="获取SpringApplicationRunListener，并回调starting()方法"></a>获取SpringApplicationRunListener，并回调starting()方法</h4><p>进入getRunListeners（args）方法内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title">getRunListeners</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">    <span class="comment">// getSpringFactoriesInstance  与上面一样是从 META-INF/factories 文件中加载</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</span><br><span class="line">        SpringApplicationRunListener<span class="class">.<span class="keyword">class</span>, <span class="title">types</span>, <span class="title">this</span>, <span class="title">args</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/springboot_start_05.png" alt></p>
<p>回调 listener.starting() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 循环回调 starting()方法</span></span><br><span class="line">	<span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="keyword">this</span>.listeners) &#123;</span><br><span class="line">		listener.starting();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="准备、配置环境信息"><a href="#准备、配置环境信息" class="headerlink" title="准备、配置环境信息"></a>准备、配置环境信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">prepareEnvironment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">		ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Create and configure the environment</span></span><br><span class="line">       <span class="comment">// 获取或创建环境</span></span><br><span class="line">	ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">       <span class="comment">// 配置环境</span></span><br><span class="line">	configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">       <span class="comment">// 循环回调 listener.environmentPrepared(environment); 方法</span></span><br><span class="line">	listeners.environmentPrepared(environment);</span><br><span class="line">       <span class="comment">// 判断 web环境，是否进行环境转换</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.webEnvironment) &#123;</span><br><span class="line">		environment = <span class="keyword">new</span> EnvironmentConverter(getClassLoader())</span><br><span class="line">				.convertToStandardEnvironmentIfNecessary(environment);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取或者创建环境：</p>
<ul>
<li>当前环境不为空就返回当前环境，</li>
<li>当前是web环境就返回new StandarServletEnvironment，</li>
<li>否则返回StandardEnvironment</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">getOrCreateEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.webEnvironment) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StandardServletEnvironment();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置环境</p>
<p>这里主要是加载properties 文件和 profiles</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureEnvironment</span><span class="params">(ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">		String[] args)</span> </span>&#123;</span><br><span class="line">	configurePropertySources(environment, args);</span><br><span class="line">	configureProfiles(environment, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断非web环境，返回 StandardEnvironment</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StandardEnvironment convertToStandardEnvironmentIfNecessary(</span><br><span class="line">		ConfigurableEnvironment environment) &#123;</span><br><span class="line">	if (environment instanceof StandardEnvironment</span><br><span class="line">			&amp;&amp; !isWebEnvironment(environment, this.classLoader)) &#123;</span><br><span class="line">		return (StandardEnvironment) environment;</span><br><span class="line">	&#125;</span><br><span class="line">	return convertToStandardEnvironment(environment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建上下文-context"><a href="#创建上下文-context" class="headerlink" title="创建上下文 context"></a>创建上下文 context</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The class name of application context that will be used by default for non-web</span></span><br><span class="line"><span class="comment">	 * environments.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONTEXT_CLASS = <span class="string">"org.springframework.context."</span></span><br><span class="line">    + <span class="string">"annotation.AnnotationConfigApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The class name of application context that will be used by default for web</span></span><br><span class="line"><span class="comment">	 * environments.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_WEB_CONTEXT_CLASS = <span class="string">"org.springframework."</span></span><br><span class="line">    + <span class="string">"boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">    <span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断web环境，选择不同上下文类型，</span></span><br><span class="line">            contextClass = Class.forName(</span><br><span class="line">                <span class="keyword">this</span>.webEnvironment ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"Unable create a default ApplicationContext, "</span></span><br><span class="line">                + <span class="string">"please specify an ApplicationContextClass"</span>,</span><br><span class="line">                ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据反射获取上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="准备（初始化）上下文"><a href="#准备（初始化）上下文" class="headerlink" title="准备（初始化）上下文"></a>准备（初始化）上下文</h4><p>这里简单来说就是对上下文环境做简单配置，并触发相关监听器的回调方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">			ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 设置环境信息</span></span><br><span class="line">    	context.setEnvironment(environment);</span><br><span class="line">    	<span class="comment">// 注册beanNameGenerator，设置 ResourceLoader</span></span><br><span class="line">		postProcessApplicationContext(context);</span><br><span class="line">    	<span class="comment">// 获取SpringApplication 中的 initializers ,回调 initialize() 方法</span></span><br><span class="line">		applyInitializers(context);</span><br><span class="line">		listeners.contextPrepared(context);</span><br><span class="line">    	</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">			logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">			logStartupProfileInfo(context);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">    	<span class="comment">// 注册一些简单组件</span></span><br><span class="line">		context.getBeanFactory().registerSingleton(<span class="string">"springApplicationArguments"</span>,</span><br><span class="line">				applicationArguments);</span><br><span class="line">		<span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">			context.getBeanFactory().registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Load the sources</span></span><br><span class="line">		Set&lt;Object&gt; sources = getSources();</span><br><span class="line">		Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">		load(context, sources.toArray(<span class="keyword">new</span> Object[sources.size()]));</span><br><span class="line">    	<span class="comment">// listener 回调 contextLoaded 方法</span></span><br><span class="line">		listeners.contextLoaded(context);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="初始化-IOC-容器"><a href="#初始化-IOC-容器" class="headerlink" title="初始化 IOC 容器"></a>初始化 IOC 容器</h4><p>初始化IOC容器（context）主要分为以下两步：</p>
<ul>
<li><p>初始化容器内所有的bean</p>
</li>
<li><p>Web应用还会创建嵌入式的tomcat（或其他中间件）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">       Object var1 = <span class="keyword">this</span>.startupShutdownMonitor;</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 刷新上下文环境</span></span><br><span class="line"><span class="comment">            * 初始化上下文环境，对系统环境变量或系统属性进行准备和校验</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// 创建 BeanFactory ,解析XML，相当于之前的XmlBeanFactory操作</span></span><br><span class="line">           ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// 初始化 beanFactory</span></span><br><span class="line">           <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 提供子类覆盖的额外处理</span></span><br><span class="line">               <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">               <span class="comment">// 激活各种BeanFactory处理器</span></span><br><span class="line">               <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">               <span class="comment">// 注册各种处理器</span></span><br><span class="line">               <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">               <span class="comment">// 初始化上下文资源文件，国际化文件</span></span><br><span class="line">               <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">               <span class="comment">// 注册事件广播器，并放入上下文</span></span><br><span class="line">               <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">               <span class="comment">// 提供子类扩展的额外处理</span></span><br><span class="line">               <span class="keyword">this</span>.onRefresh();</span><br><span class="line">               <span class="comment">// 获取Listeners，并放入 applicationEventMulticaster（事件广播器）</span></span><br><span class="line">               <span class="keyword">this</span>.registerListeners();</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 设置转换器</span></span><br><span class="line"><span class="comment">                * 注册一个默认的属性值解析器</span></span><br><span class="line"><span class="comment">                * 冻结所有bean定义，说明注册的bean定义将不能被修改或进一步处理</span></span><br><span class="line"><span class="comment">                * 初始化剩余的非惰性的bean，即初始化非延迟加载的bean</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">        		<span class="comment">// 完成初始化后续操作</span></span><br><span class="line">               <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (BeansException var9) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">               <span class="keyword">this</span>.cancelRefresh(var9);</span><br><span class="line">               <span class="keyword">throw</span> var9;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">this</span>.resetCommonCaches();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中 this.finishRefresh() 方法详细说明一下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化Spring 生命周期处理类</span></span><br><span class="line">    <span class="keyword">this</span>.initLifecycleProcessor();</span><br><span class="line">    <span class="comment">// 生命周期处理类开始生命周期</span></span><br><span class="line">    <span class="keyword">this</span>.getLifecycleProcessor().onRefresh();</span><br><span class="line">    <span class="comment">// 事件发布</span></span><br><span class="line">    <span class="keyword">this</span>.publishEvent((ApplicationEvent)(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>)));</span><br><span class="line">    LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>初始化生命周期处理器 <strong>DefaultLifecycleProcessor</strong>，<strong>DefaultLifecycleProcessor</strong>含有<strong>start</strong>方法和<strong>stop</strong>方法</p>
</li>
<li><p><strong>spring</strong> 启动的时候调用 <strong>start</strong> 方法开始生命周期</p>
</li>
<li><p><strong>spring</strong> 关闭的时候调用 <strong>stop</strong> 方法来结束生命周期，</p>
</li>
<li><p>启动所有实现了<strong>Lifecycle</strong> 接口的类</p>
</li>
<li><p>通过<strong>spring</strong> 的事件发布机制发布 <strong>ContextRefreshedEvent</strong> 事件，以保证对应的监听器做进一步处理，即对那种在<strong>spring</strong> 启动后需要处理的一些类，实现了<strong>ApplicationListener</strong><ContextRefreshedEvent>,这里即是触发这些类的执行（执行<strong>onApplicationEvent</strong>方法），除此之外，<strong>spring</strong> 内置 <strong>Event</strong> 有 <strong>ContextClosedEvent</strong> 、<strong>ContextRefreshedEvent</strong> 、<strong>ContextStartedEvent</strong> 、<strong>ContextStopedEvent</strong> 、<strong>ContextHandleEvent</strong></ContextRefreshedEvent></p>
</li>
<li><p>最后完成初始化，通知生命周期处理器 <strong>LifecycleProcessor</strong> 刷新过程，同时发出事件通知其他 类</p>
</li>
</ul>
<h4 id="IOC容器中获取ApplicationRunner和CommandLineRunner并回调"><a href="#IOC容器中获取ApplicationRunner和CommandLineRunner并回调" class="headerlink" title="IOC容器中获取ApplicationRunner和CommandLineRunner并回调"></a>IOC容器中获取ApplicationRunner和CommandLineRunner并回调</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRefresh</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">		ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">	callRunners(context, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">	List&lt;Object&gt; runners = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">       <span class="comment">// 从IOC容器中获取 ApplicationRunner 和 CommandLineRunner</span></span><br><span class="line">	runners.addAll(context.getBeansOfType(ApplicationRunner<span class="class">.<span class="keyword">class</span>).<span class="title">values</span>())</span>;</span><br><span class="line">	runners.addAll(context.getBeansOfType(CommandLineRunner<span class="class">.<span class="keyword">class</span>).<span class="title">values</span>())</span>;</span><br><span class="line">	AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">	<span class="keyword">for</span> (Object runner : <span class="keyword">new</span> LinkedHashSet&lt;Object&gt;(runners)) &#123;</span><br><span class="line">           <span class="comment">// 一次 调用ApplicationRunner 和 CommandLineRunner 的 run() 方法</span></span><br><span class="line">		<span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) &#123;</span><br><span class="line">			callRunner((ApplicationRunner) runner, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) &#123;</span><br><span class="line">			callRunner((CommandLineRunner) runner, args);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunner</span><span class="params">(ApplicationRunner runner, ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		(runner).run(args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to execute ApplicationRunner"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunner</span><span class="params">(CommandLineRunner runner, ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		(runner).run(args.getSourceArgs());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to execute CommandLineRunner"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与前面获取 <strong>ApplicationContextInitializer</strong> 和 <strong>ApplicationListener</strong> 不同的是，<strong>ApplicationRunner</strong> 和<strong>CommandLineRunner</strong> 的获取是从context（即IOC容器）中获取的。</p>
<p>然后依次回调，这里要注意回调先后顺序（<strong>优先级</strong>） <strong>ApplicationRunner</strong>  <strong>&gt;</strong>  <strong>CommandLineRunner</strong></p>
<h4 id="所有的SpringApplicationRunListener，回调finished方法"><a href="#所有的SpringApplicationRunListener，回调finished方法" class="headerlink" title="所有的SpringApplicationRunListener，回调finished方法"></a>所有的SpringApplicationRunListener，回调finished方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finished</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="keyword">this</span>.listeners) &#123;</span><br><span class="line">		callFinishedListener(listener, context, exception);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="返回ioc容器"><a href="#返回ioc容器" class="headerlink" title="返回ioc容器"></a>返回ioc容器</h4><p>至此，SpringAppication 的run方法就运行完了，Spring Boot也启动完成了。</p>
<h2 id="Spring-Boot-启动过程中的时间回调机制"><a href="#Spring-Boot-启动过程中的时间回调机制" class="headerlink" title="Spring Boot 启动过程中的时间回调机制"></a>Spring Boot 启动过程中的时间回调机制</h2><h3 id="1-SpringBoot启动过程中的监听器"><a href="#1-SpringBoot启动过程中的监听器" class="headerlink" title="1. SpringBoot启动过程中的监听器"></a>1. SpringBoot启动过程中的监听器</h3><p>在分析完SpringBoot启动原理后我们发现，SpringBoot启动过程中使用了如下4个监听器：</p>
<ul>
<li><p><strong>配置在 META-INF/spring.factories 中：</strong></p>
<p>​        -  ApplicationContextInitializer</p>
<p>​        -  SpringApplicationRunListener</p>
<ul>
<li><p><strong>从IOC容器中获取的：</strong></p>
<p>​        -  ApplicationRunner</p>
<p>​        -  CommandLineRunner</p>
</li>
</ul>
</li>
</ul>
<p><strong>思考</strong>：在SpringBoot启动过程中都有注册并回调上述监听器，那么我们可否自定义上述监听器，已完成在项目启动过程中需要实现的功能</p>
<h3 id="2-自定义事件监听器"><a href="#2-自定义事件监听器" class="headerlink" title="2. 自定义事件监听器"></a>2. 自定义事件监听器</h3><p>新建 <strong>HelloApplicationContextInitializer</strong> 、<strong>HelloSpringApplicationRunListener</strong> 类，分别实现 <strong>ApplicationContextInitializer</strong> 和 <strong>SpringApplicationRunListener</strong> 接口</p>
<p><strong>HelloApplicationContextInitializer：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextInitializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/4/28 14:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationContextInitailizer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ConfigurableApplicationContext configurableApplicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=== &gt;&gt;&gt; HelloApplicationContextInitailizer.initialize === "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HelloSpringApplicationRunListener：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplicationRunListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.ConfigurableEnvironment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/4/28 15:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSpringApplicationRunListener</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意该类必须实现一个有参的构造器，否则报错</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> application</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> HelloSpringApplicationRunListener</span><br><span class="line">        (SpringApplication application,String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloSpringApplicationRunListener.starting... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloSpringApplicationRunListener.environmentPrepared... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloSpringApplicationRunListener.contextPrepared... "</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloSpringApplicationRunListener.contextLoaded... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finished</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloSpringApplicationRunListener.finished... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建 <strong>HelloApplicationRunner</strong>：实现 <strong>ApplicationRunner</strong> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/4/28 15:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloApplicationRunner.run "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建 <strong>HelloCommandLineRunner</strong>，实现 <strong>CommandLineRunner</strong> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/4/28 15:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloCommandLineRunner.run... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 <strong>ApplicationContextInitializer</strong>、<strong>SpringApplicationRunListener</strong> 的实现类配置在类路径下的<strong>META-INF/spring.factories</strong>里：</p>
<p><img src="/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/springboot_start_06.png" alt></p>
<p><strong>HelloApplicationRunner</strong> 和 <strong>HelloCommandLineRunner</strong> 是从上下文中获取，只需要在类上添加<strong>@Component</strong> 注解即可</p>
<p><strong>启动项目，查看控制台日志</strong></p>
<img src="/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/springboot_start_07.png" style="zoom: 80%;">





<p><strong>如果你觉得写的还不错，请给我个 star 吧：<a href="https://github.com/CharleyZZZZ/CharleyZZZZ.github.io" target="_blank" rel="noopener">https://github.com/CharleyZZZZ/CharleyZZZZ.github.io</a></strong></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>[Spring] Spring 常用注解(一)</title>
    <url>/2020/05/13/Spring-Spring-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3-%E4%B8%80/</url>
    <content><![CDATA[<h3 id="1-Bean相关"><a href="#1-Bean相关" class="headerlink" title="1. Bean相关"></a>1. Bean相关</h3><h4 id="1-1-Autowired"><a href="#1-1-Autowired" class="headerlink" title="1.1 @Autowired"></a>1.1 @Autowired</h4><p>依赖注入，自动导入对象到类中，该类同样要求被 <strong>Spring</strong> 容器管理，例如 <strong>Controller</strong> 中注入 <strong>Service</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserService userService;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-2-Bean-注册"><a href="#1-2-Bean-注册" class="headerlink" title="1.2 Bean 注册"></a>1.2 Bean 注册</h4><ul>
<li><p>*<em>@Component *</em> 注解表明一个类会作为组件类，并告知Spring要为这个类创建bean</p>
</li>
<li><p><strong>@Repository</strong>  对应持久层即 Dao 层，主要用于数据库相关操作</p>
</li>
<li><p><strong>@Service</strong>  对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p>
</li>
<li><p><strong>@Controller</strong>  对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</p>
</li>
<li><p>*<em>@Bean *</em> 注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑；</p>
</li>
<li><p><strong>@Configuration</strong>  与 <strong>@Component</strong> 功能类似，语义上是声明配置类，也可用 <strong>@Component</strong> 替代</p>
</li>
</ul>
<h4 id="1-3-Scope-Bean做用域"><a href="#1-3-Scope-Bean做用域" class="headerlink" title="1.3 @Scope Bean做用域"></a>1.3 <strong>@Scope</strong> Bean做用域</h4><p>声明 Spring Bean 的作用域，使用方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">personSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>四种常见的 Spring Bean 的作用域：</strong></p>
<ul>
<li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</li>
<li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
</ul>
<h3 id="2-Controller层常用"><a href="#2-Controller层常用" class="headerlink" title="2. Controller层常用"></a>2. Controller层常用</h3><h4 id="2-1-基本注解"><a href="#2-1-基本注解" class="headerlink" title="2.1 基本注解"></a>2.1 基本注解</h4><ul>
<li><p>@<strong>RequestMapping(“url”)</strong>  这里的 url写的是请求路径的一部分，一般作用在 Controller的方法上，作为请求的映射地址。</p>
</li>
<li><p>@<strong>RestController</strong>  该注解是  @<strong>ResponseBody</strong>  和 @<strong>Controller</strong> 注解的集合，</p>
</li>
<li><p>@<strong>RequestBody</strong>  作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 <strong>JavaBean</strong> 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上。</p>
</li>
<li><p>@<strong>ResponseBody</strong>  作用在方法上，将方法的返回结果直接写入 <strong>HTTP response body</strong> 中，用<strong>json</strong>的格式 返回</p>
</li>
</ul>
<h4 id="2-2-Http请求相关注解"><a href="#2-2-Http请求相关注解" class="headerlink" title="2.2 Http请求相关注解"></a>2.2 Http请求相关注解</h4><p><strong>五种常见的请求类型:</strong></p>
<ul>
<li><p><strong>GET</strong> ：请求从服务器获取特定资源。举个例子：GET /users（获取所有学生）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价于@RequestMapping(value="/users",method=RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"users"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>POST</strong> ：在服务器</p>
</li>
<li><p>创建一个新的资源。举个例子：POST /users（创建学生）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价于@RequestMapping(value="/users",method=RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"users"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>PUT</strong> ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：PUT /users/12（更新编号为 12 的学生）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价于@RequestMapping(value="/users/&#123;userId&#125;",method=RequestMethod.PUT)</span></span><br><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/users/&#123;userId&#125;"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DELETE</strong> ：从服务器删除特定的资源。举个例子：DELETE /users/12（删除编号为 12 的学生）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价于@RequestMapping(value="/users/&#123;userId&#125;",method=RequestMethod.DELETE)</span></span><br><span class="line"><span class="meta">@DeleteMapping</span>(<span class="string">"/users/&#123;userId&#125;"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>PATCH</strong> ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般实际项目中，我们都是 PUT 不够用了之后才用 PATCH 请求去更新数据。</span></span><br><span class="line"><span class="meta">@PatchMapping</span>(<span class="string">"/profile"</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="2-3-前后端传值相关"><a href="#2-3-前后端传值相关" class="headerlink" title="2.3 前后端传值相关"></a>2.3 前后端传值相关</h4><ol>
<li><p><strong>@PathVariable</strong> <strong>和</strong> <strong>@RequestParam</strong></p>
<p>@<strong>PathVariable</strong>用于获取路径参数，@<strong>RequestParam</strong>用于获取查询参数。</p>
<p>具体见示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;userId&#125;/name"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         @PathVariable(<span class="string">"userId"</span>)</span> Long userId,</span></span><br><span class="line"><span class="function">         @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"employeeId"</span>, required = <span class="keyword">false</span>)</span> Long employeeId ) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><strong>@RequestBody</strong></p>
<p>作用在形参列表上，读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且<strong>Content-Type 为 application/json</strong> 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用<strong>HttpMessageConverter</strong>或者自定义的<strong>HttpMessageConverter</strong>将请求的 body 中的 json 字符串转换为 java 对象。</p>
<p>简单来说就是 将 前台的 传来的 <strong>json</strong> 字符串 自动转成 对象。</p>
<p>可与 @<strong>ResponseBody</strong> 同时记忆</p>
</li>
</ol>
<h5 id="知识点：ajax-中-DataType-和-ContentType-的区别"><a href="#知识点：ajax-中-DataType-和-ContentType-的区别" class="headerlink" title="知识点：ajax 中 DataType 和 ContentType 的区别"></a>知识点：ajax 中 DataType 和 ContentType 的区别</h5><ul>
<li><strong>contentType</strong>   告诉服务器，我要发什么类型的数据，对于后台接口来说就是请求参数</li>
<li><strong>dataType</strong>  告诉服务器，我要想什么类型的数据，对于后台接口来说就是请求返回值</li>
</ul>
<h4 id="2-4-参数校验相关注解"><a href="#2-4-参数校验相关注解" class="headerlink" title="2.4 参数校验相关注解"></a>2.4 参数校验相关注解</h4><p><strong>JSR(Java Specification Requests）</strong> 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了，校验的时候我们实际用的是 <strong>Hibernate Validator</strong> 框架。</p>
<table>
<thead>
<tr>
<th><strong>Hibernate Validator</strong></th>
<th>JSR标准</th>
</tr>
</thead>
<tbody><tr>
<td>Hibernate Validator 4.x</td>
<td>Bean Validation 1.0（JSR 303）</td>
</tr>
<tr>
<td>Hibernate Validator 5.x</td>
<td>Bean Validation 1.1（JSR 349）</td>
</tr>
<tr>
<td>Hibernate Validator 6.x</td>
<td>Bean Validation 2.0（JSR 380）</td>
</tr>
</tbody></table>
<p>而SpringBoot 项目的 spring-boot-starter-web 依赖中已经有 hibernate-validator 包，不需要引用相关依赖。</p>
<p><strong>所有的注解，推荐使用 JSR 注解，即</strong> <strong>javax.validation.constraints</strong>，而不是<strong>org.hibernate.validator.constraints</strong></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>@AssertTrue</td>
<td>用于boolean字段，该字段只能为true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>该字段的值只能为false</td>
</tr>
<tr>
<td>@CreditCardNumber</td>
<td>对信用卡号进行一个大致的验证</td>
</tr>
<tr>
<td>@DecimalMax</td>
<td>只能小于或等于该值</td>
</tr>
<tr>
<td>@DecimalMin</td>
<td>只能大于或等于该值</td>
</tr>
<tr>
<td>@Digits(integer=,fraction=)</td>
<td>检查是否是一种数字的整数、分数,小数位数的数字</td>
</tr>
<tr>
<td>@Email</td>
<td>检查是否是一个有效的email地址</td>
</tr>
<tr>
<td>@Future</td>
<td>检查该字段的日期是否是属于将来的日期</td>
</tr>
<tr>
<td>@Length(min=,max=)</td>
<td>检查所属的字段的长度是否在min和max之间,只能用于字符串</td>
</tr>
<tr>
<td>@Max</td>
<td>该字段的值只能小于或等于该值</td>
</tr>
<tr>
<td>@Min</td>
<td>该字段的值只能大于或等于该值</td>
</tr>
<tr>
<td>@NotNull</td>
<td>不能为null</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>不能为空，检查时会将空格忽略</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>不能为空，这里的空是指空字符串</td>
</tr>
<tr>
<td>@Null</td>
<td>检查该字段为空</td>
</tr>
<tr>
<td>@Past</td>
<td>检查该字段的日期是在过去</td>
</tr>
<tr>
<td>@Pattern(regex=,flag=)</td>
<td>被注释的元素必须符合指定的正则表达式</td>
</tr>
<tr>
<td>@Range(min=,max=,message=)</td>
<td>被注释的元素必须在合适的范围内</td>
</tr>
<tr>
<td>@Size(min=, max=)</td>
<td>检查该字段的size是否在min和max之间，可以是字符串、数组、集合、Map等</td>
</tr>
<tr>
<td>@URL(protocol=,host,port)</td>
<td>检查是否是一个有效的URL，如果提供了protocol，host等，则该URL还需满足提供的条件</td>
</tr>
<tr>
<td>@Valid</td>
<td>该注解主要用于字段为一个包含其他对象的集合或map或数组的字段，或该字段直接为一个其他对象的引用，这样在检查当前对象的同时也会检查该字段所引用的对象</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.NotEmpty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/5/9 17:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty</span>(message = <span class="string">"姓名不能为空！"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"年龄不能为空！"</span>)</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Controller</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/person"</span>)</span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@RequestBody @Valid Person person)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ResponseEntity.ok().body(person);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>在需要验证的参数上加上了@Valid注解，如果验证失败，它将抛出MethodArgumentNotValidException，同时配合ExceptionHandler,捕捉异常，封装统一出错返回信息给前端。</strong></p>
<p>对于请求参数不是对象类型的，可直接在 请求参数上添加校验注解，</p>
<p><strong>但是在类上一定要加上</strong> <strong>Validated</strong> <strong>注解了，这个参数可以告诉 Spring 去校验方法参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/4/27 17:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/person/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="title">getPersonByID</span><span class="params">(@Valid @PathVariable(<span class="string">"id"</span>)</span> @<span class="title">Max</span><span class="params">(value = <span class="number">5</span>,message = <span class="string">"超过 id 的范围了"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-5-全局Controller异常相关注解"><a href="#2-5-全局Controller异常相关注解" class="headerlink" title="2.5 全局Controller异常相关注解"></a>2.5 全局Controller异常相关注解</h4><h5 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a><strong>@ExceptionHandler</strong></h5><p>单独使用<strong>@ExceptionHandler</strong>时一般写在控制器的内部，在控制器的某个方法上加上<strong>@ExceptionHandler</strong>注解。</p>
<p>在<strong>ExceptionController</strong>内部如果抛出了指定<strong>XXXXException</strong>异常，就会被这个控制器内部的<strong>handleError</strong>捕捉到。然后进行处理。</p>
<p>但是这样就很麻烦，需要在每个控制器上添加这样一个方法。</p>
<p>通常的做法是 项目添加<strong>BaseController</strong>，在其他控制器继承<strong>BaseController</strong>，此外 <strong>BaseController</strong> 还可以封装控制器通用方法，常量等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> <span class="keyword">implements</span> <span class="title">IBaseConstants</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(BaseController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分页常量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PAGE = <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PAGE_SIZE = <span class="string">"10"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JSP_500 = <span class="string">"500"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR_MESSAGE = <span class="string">"errorMsg"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Object</span> <span class="title">exceptionHandler</span>(<span class="title">Exception</span> <span class="title">exception</span>, <span class="title">HttpServletRequest</span> <span class="title">request</span>) </span>&#123;</span><br><span class="line">        LOGGER.error(exception.getMessage(), exception);</span><br><span class="line">        Throwable rootCause = <span class="keyword">this</span>.getRootCause(exception);</span><br><span class="line">        IBaseException baseException;</span><br><span class="line">        <span class="comment">// 这里判断是否是 ajax 请求，来判断是返回json ，还是 modelAndView视图</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isAjaxRequest(request) &amp;&amp; !<span class="keyword">this</span>.isApiRequest(request) &amp;&amp; !ServletFileUpload.isMultipartContent(request)) &#123;</span><br><span class="line">            ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(JSP_500);</span><br><span class="line">            <span class="keyword">if</span> (rootCause <span class="keyword">instanceof</span> IBaseException) &#123;</span><br><span class="line">                modelAndView.addObject(ERROR_MESSAGE, exception.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> modelAndView;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BaseResponseDTO baseResponseDTO = <span class="keyword">new</span> BaseResponseDTO(<span class="keyword">false</span>);</span><br><span class="line">            baseResponseDTO.setMessage(exception.getMessage());</span><br><span class="line">            <span class="keyword">if</span> (rootCause <span class="keyword">instanceof</span> IBaseException) &#123;</span><br><span class="line">                baseException = (IBaseException) rootCause;</span><br><span class="line">                baseResponseDTO.setCode(baseException.getCode());</span><br><span class="line">                baseResponseDTO.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baseResponseDTO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h5><p>@ExceptionHandler + @ControllerAdvice</p>
<p>Spring 3.2版本中添加了 新的注解 <strong>@ControllerAdvice</strong> 支持全局的异常处理，这样就可以单独用一个类处理异常了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;ExceptionException<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">String</span> <span class="title">handleError</span>(<span class="title">Exception</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        <span class="keyword">return</span> e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span>&lt;<span class="title">Object</span>&gt; <span class="title">handleAllException</span>(<span class="title">Exception</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(...); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充：</strong></p>
<p>​    全局异常捕捉还有一种方式，即实现 <strong>HandlerExceptionResolver</strong> 接口，要求实现其 <strong>resolveException</strong></p>
<p>方法，返回<strong>ModelAndView</strong>对象，要想返回 <strong>Json</strong> 对象，需要定制化，例如 直接在response 中回写，或者 用<strong>MappingJackson2JsonView</strong> 对象，但是 不推荐这样使用。</p>
<h3 id="3-配置文件相关"><a href="#3-配置文件相关" class="headerlink" title="3. 配置文件相关"></a>3. 配置文件相关</h3><h5 id="Value"><a href="#Value" class="headerlink" title="@Value"></a><strong>@Value</strong></h5><p>读取简单配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">String serverPort;</span><br></pre></td></tr></table></figure>



<h5 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a><strong>@ConfigurationProperties</strong></h5><p>读取配置信息，并且配合 <strong>@Configuration</strong> 或者 <strong>@Component</strong> 注解注册到上下文</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigurationProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a>@EnableConfigurationProperties</h5><p>如果未添加 <strong>@Configuration</strong> 或者 <strong>@Component</strong> 注解 ，可以 在使用的地方 添加<strong>@EnableConfigurationProperties</strong> 注解指定配置类将其注入到 上下文中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnabledDemoAutoConfiguration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MyConfigurationProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringBootLogging02Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> MyConfigurationProperties configurationProperties;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SpringBootLogging02Application</span><span class="params">(MyConfigurationProperties configurationProperties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.configurationProperties = configurationProperties;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(SpringBootLogging02Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a><strong>@PropertySource</strong></h5><p><strong>读取指定 properties 文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:myself.properties"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myselfConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-JPA相关"><a href="#4-JPA相关" class="headerlink" title="4. JPA相关"></a>4. JPA相关</h3><table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@<strong>Entity</strong></td>
<td>声明一个类对应一个数据库实体。</td>
</tr>
<tr>
<td>@<strong>Table</strong></td>
<td>设置表名</td>
</tr>
<tr>
<td>@<strong>Id</strong></td>
<td>声明主键</td>
</tr>
<tr>
<td>@<strong>GeneratedValue</strong></td>
<td><strong>JPA</strong> 使用枚举定义了 4 中常见的主键生成策略：<strong>TABLE</strong>（特定表格存储），<strong>SEQUENCE</strong>（序列），<strong>IDENTITY</strong>（自增长），<strong>AUTO</strong>（交给持久化引擎决定，他会在以上三种选一个，默认使用这个）</td>
</tr>
<tr>
<td>@<strong>GenericGenerator</strong></td>
<td>声明一个主键策略，然后@<strong>GeneratedValue</strong>使用这个策略</td>
</tr>
<tr>
<td>@<strong>Column</strong></td>
<td>声明字段</td>
</tr>
<tr>
<td>@<strong>Transient</strong></td>
<td>声明指定不持久化字段</td>
</tr>
<tr>
<td>@<strong>Lob</strong></td>
<td>声明某个字段为大字段</td>
</tr>
<tr>
<td>@<strong>Basic</strong>(fetch = FetchType.EAGER)</td>
<td>指定 <strong>Lob</strong> 类型数据的获取策略， <strong>FetchType.EAGER</strong> 表示非延迟 加载，而 <strong>FetchType. LAZY</strong> 表示延迟加载</td>
</tr>
<tr>
<td>@<strong>Enumerated</strong></td>
<td>声明使用枚举类型的字段</td>
</tr>
<tr>
<td>@<strong>CreatedBy</strong></td>
<td>声明审计字段  创建者</td>
</tr>
<tr>
<td>@<strong>LastModifiedBy</strong></td>
<td>声明审计字段  上次修改者</td>
</tr>
<tr>
<td>@<strong>CreatedDate</strong></td>
<td>声明审计字段  上次修改时间</td>
</tr>
<tr>
<td>@<strong>LastModifiedDate</strong></td>
<td>声明审计字段  最后修改时间</td>
</tr>
<tr>
<td>@<strong>EnableJpaAuditing</strong></td>
<td>开启JPA审计功能，一般放启动类上</td>
</tr>
<tr>
<td>@<strong>EntityListeners</strong>(AuditingEntityListener.class)</td>
<td>设置实体类监听器，指定审计相关监听器</td>
</tr>
<tr>
<td>@<strong>OneToOne</strong></td>
<td>声明关联关系：一对一</td>
</tr>
<tr>
<td>@<strong>OneToMany</strong></td>
<td>声明关联关系：一对多</td>
</tr>
<tr>
<td>@<strong>ManyToOne</strong></td>
<td>声明关联关系：多对一</td>
</tr>
<tr>
<td>@<strong>ManyToMany</strong></td>
<td>声明关联关系：多对多</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"sys_user"</span>)</span><br><span class="line"><span class="meta">@ApiModel</span>(<span class="string">"用户表"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysUser</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="meta">@Enumerated</span>(EnumType.STRING)</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="meta">@Column</span>(updatable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> Instant createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="keyword">private</span> Instant updatedAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedBy</span></span><br><span class="line">    <span class="meta">@Column</span>(updatable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String createdBy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedBy</span></span><br><span class="line">    <span class="keyword">private</span> String updatedBy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 暂存字段，不持久化</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> String depatmentName;</span><br><span class="line">   </span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-JSON处理相关"><a href="#5-JSON处理相关" class="headerlink" title="5. JSON处理相关"></a>5. JSON处理相关</h3><h4 id="5-1-Json过滤"><a href="#5-1-Json过滤" class="headerlink" title="5.1 Json过滤"></a>5.1 Json过滤</h4><h5 id="JsonIgnoreProperties"><a href="#JsonIgnoreProperties" class="headerlink" title="@JsonIgnoreProperties"></a><strong>@JsonIgnoreProperties</strong></h5><p>作用在类上用于过滤掉特定字段不返回或者不解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonIgnoreProperties</span>(&#123;<span class="string">"userRoles"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysUser</span> <span class="keyword">extends</span> <span class="title">BaseDTO</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户角色关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="JsonIgnore"><a href="#JsonIgnore" class="headerlink" title="@JsonIgnore"></a><strong>@JsonIgnore</strong></h5><p>用于类的<strong>属性</strong>上，作用和上面的*<em>@JsonIgnoreProperties *</em>一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonIgnoreProperties</span>(&#123;<span class="string">"userRoles"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysUser</span> <span class="keyword">extends</span> <span class="title">BaseDTO</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-2-格式化Json数据"><a href="#5-2-格式化Json数据" class="headerlink" title="5.2 格式化Json数据"></a>5.2 格式化Json数据</h4><h5 id="JsonFormat"><a href="#JsonFormat" class="headerlink" title="@JsonFormat"></a><strong>@JsonFormat</strong></h5><p>一般用来格式化 json 数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonFormat</span>(pattern=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>,timezone=<span class="string">"GMT+8"</span>)</span><br><span class="line"><span class="keyword">private</span> Date endTime;</span><br></pre></td></tr></table></figure>



<h5 id="JsonUnwrapped"><a href="#JsonUnwrapped" class="headerlink" title="@JsonUnwrapped"></a>@<strong>JsonUnwrapped</strong></h5><p>Json数据扁平化处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Country</span><span class="params">(String name, Province province)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 国家名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省会</span></span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> Province province;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Province <span class="title">getProvince</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProvince</span><span class="params">(Province province)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Province</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Province</span><span class="params">(String capital)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capital = capital;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 省会</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String capital;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCapital</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> capital;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCapital</span><span class="params">(String capital)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capital = capital;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JsonInclude"><a href="#JsonInclude" class="headerlink" title="@JsonInclude"></a>@JsonInclude</h5><p>指定字段的序列化条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonInclude</span>(JsonInclude.Include.NON_NULL)</span><br><span class="line"><span class="keyword">private</span> String code;</span><br><span class="line"><span class="meta">@JsonInclude</span>(JsonInclude.Include.NON_NULL)</span><br><span class="line"><span class="keyword">private</span> String message;</span><br></pre></td></tr></table></figure>

<p><strong>JsonJsonInclude.Include.ALWAYS</strong> 默认策略，任何情况下都序列化该字段，和不写这个注解是一样的效果。<br><strong>JsonJsonInclude.Include.NON_NULL</strong> 最常用，即如果加该注解的字段为null,那么就不序列化这个字段了。<br><strong>JsonJsonInclude.Include.NON_ABSENT</strong> 包含NON_NULL，即为null的时候不序列化</p>
<p><strong>JsonJsonInclude.Include.NON_EMPTY</strong>  属性包含NON_NULL，NON_ABSENT之后还包含如果字段为空也不序列化。这个也比较常用<br><strong>JsonJsonInclude.Include.NON_DEFAULT</strong>如果字段是默认值的话就不序列化。</p>
<h5 id="JsonProperty"><a href="#JsonProperty" class="headerlink" title="@JsonProperty"></a><strong>@JsonProperty</strong></h5><p>此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，</p>
<p>例如如把positionCode属性序列化为postCode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonProperty</span>(value=<span class="string">"postCode"</span>)</span><br><span class="line"><span class="keyword">private</span> String positionCode;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonProperty</span>(value=<span class="string">"postName"</span>)</span><br><span class="line"><span class="keyword">private</span> String positionName;</span><br></pre></td></tr></table></figure>





<h3 id="6-SpringBoot常用注解"><a href="#6-SpringBoot常用注解" class="headerlink" title="6. SpringBoot常用注解"></a>6. SpringBoot常用注解</h3><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><p>该注解是在创建SpringBoot项目后自动添加在主类上的，在项目启动时生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">		@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由代码可知，该注解其实是由 <strong>@Configuration</strong>  、 <strong>@EnableAutoConfiguration</strong> 和 <strong>@ComponentScan</strong> 三个注解组成，这三个注解的含义是：</p>
<ul>
<li>@<strong>EnableAutoConfiguration</strong>：启用 <strong>SpringBoot</strong> 的自动配置机制</li>
<li>@<strong>ComponentScan</strong>： 扫描被 <strong>@Component (@Service,@Controller,@Repository)</strong> 注解的 <strong>bean</strong>，注解默认会扫描该类所在的包下所有的类。</li>
<li>@<strong>Configuration</strong>：允许在 <strong>Spring</strong> 上下文中注册额外的 <strong>bean</strong> 或导入其他配置类</li>
</ul>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式架构之基础理论学习</title>
    <url>/2020/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="分布式系统特点"><a href="#分布式系统特点" class="headerlink" title="分布式系统特点"></a>分布式系统特点</h3><p>​        随着移动互联网的快速发展，互联网的用户数量越来越多，产生的数据规模也越来越大，对应用系统提出了更高的要求，我们的系统必须支持高并发访问和海量数据处理。</p>
<p>分布式系统技术就是用来解决集中式架构的性能瓶颈问题，来适应快速发展的业务规模，一般来说，分布式系统是建立在网络之上的硬件或者软件系统，<strong>彼此之间通过消息等方式进行通信和协调</strong>。</p>
<p>分布式系统的核心是<strong>可扩展性</strong>，通过对服务、存储的扩展，来提高系统的处理能力，通过对多台服务器协同工作，来完成单台服务器无法处理的任务，尤其是高并发或者大数据量的任务。</p>
<p>除了对可扩展性的需求，分布式系统还有<strong>不出现单点故障、服务或者存储无状态</strong>等特点。</p>
<ul>
<li><p><strong>单点故障</strong>（Single Point Failure）是指在系统中某个组件一旦失效，这会让整个系统无法工作，而不出现单点故障，单点不影响整体，就是分布式系统的设计目标之一；</p>
</li>
<li><p><strong>无状态</strong>，是因为无状态的服务才能满足部分机器宕机不影响全部，可以随时进行扩展的需求。</p>
</li>
</ul>
<h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><p>由于分布式系统的特点，在分布式环境中更容易出现问题，比如<strong>节点之间通信失败、网络分区故障、多个副本的数据不一致</strong>等，为了更好的在分布式系统下进行开发，出现了一系列的理论，其中具有代表性的就是 <strong>CAP 理论</strong>。</p>
<p><strong>CAP 理论</strong>可以表述为，一个分布式系统最多只能同时满足<strong>一致性</strong>（Consistency）、<strong>可用性</strong>（Availability）和<strong>分区容忍性</strong>（Partition Tolerance）这三项中的两项。</p>
<p><img src="/2020/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/CAP.png" alt></p>
<ul>
<li><p><strong>一致性</strong>是指“所有节点同时看到相同的数据”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，等同于所有节点拥有数据的最新版本。</p>
</li>
<li><p><strong>可用性</strong>是指“任何时候，读写都是成功的”，即服务一直可用，而且是正常响应时间。我们平时会看到一些 IT 公司的对外宣传，比如系统稳定性已经做到 3 个 9、4 个 9，即 99.9%、99.99%，这里的 N 个 9 就是对可用性的一个描述，叫做 SLA，即服务水平协议。比如我们说月度 99.95% 的 SLA，则意味着每个月服务出现故障的时间只能占总时间的 0.05%，如果这个月是 30 天，那么就是 21.6 分钟。</p>
</li>
<li><p><strong>分区容忍性</strong>具体是指“当部分节点出现消息丢失或者分区故障的时候，分布式系统仍然能够继续运行”，即系统容忍网络出现分区，并且在遇到某节点或网络分区之间网络不可达的情况下，仍然能够对外提供满足一致性和可用性的服务。</p>
</li>
</ul>
<p>在分布式系统中，由于系统的各层拆分，<strong>P</strong> 是确定的，CAP 的应用模型就是 <strong>CP 架构</strong>和 <strong>AP 架构</strong>。</p>
<h3 id="CP-和-AP-架构的取舍"><a href="#CP-和-AP-架构的取舍" class="headerlink" title="CP 和 AP 架构的取舍"></a>CP 和 AP 架构的取舍</h3><p>在通常的分布式系统中，为了保证数据的高可用，通常会将数据保留多个副本（Replica），<strong>网络分区</strong>是既成的现实，于是只能在<strong>可用性</strong>和<strong>一致性</strong>两者间做出选择。CAP 理论关注的是在绝对情况下，在工程上，<strong>可用性和一致性并不是完全对立的，我们关注的往往是如何在保持相对一致性的前提下，提高系统的可用性。</strong></p>
<p>业务上对一致性的要求会直接反映在系统设计中，典型的就是 <strong>CP</strong> 和 <strong>AP</strong> 架构。</p>
<p><strong>CP 架构：</strong>放弃可用性，追求一致性和分区容错性。</p>
<p>​    我们熟悉的 <strong>ZooKeeper</strong>，就是采用了 <strong>CP</strong> 一致性，ZooKeeper 是一个分布式的服务框架，主要用来解决分布式集群中应用系统的协调和一致性问题。Zookeeper 采用 数据一致性算法 <strong>ZAB</strong> （基于Paxos）保证数据一致性。在 Zookeeper中，当<strong>master</strong> 节点因为网络故障与其他节点失去联系时，其余节点会重新进行<strong>leader</strong> 选举，一般选举时间为 <strong>30~120 s</strong>，且选举期间整个zk集群都是<strong>不可用的</strong>，这会导致在选举期间注册服务瘫痪。失去可用性。</p>
<p><strong>AP 架构：</strong>放弃强一致性，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的 Base 也是根据 AP 来扩展的。</p>
<p>​    和 ZooKeeper 相对的是 Eureka，Eureka 是 Spring Cloud 微服务技术栈中的服务发现组件，Eureka 的各个节点都是平等的，几个节点挂掉不影响正常节点的工作，剩余的节点依然可以提供注册和查询服务，只要有一台 Eureka 还在，就能保证注册服务可用，只不过查到的信息可能不是最新的版本，不保证一致性。</p>
<h3 id="Base-理论"><a href="#Base-理论" class="headerlink" title="Base 理论"></a>Base 理论</h3><p>对于 CAP 来说，放弃<strong>强一致性</strong>（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择。在工程实践中，基于 CAP 定理逐步演化，就提出了 Base 理论。</p>
<p>Base 是三个短语的简写，即<strong>基本可用</strong>（Basically Available）、<strong>软状态</strong>（Soft State）和<strong>最终一致性</strong>（Eventually Consistent）。</p>
<img src="/2020/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/Base.png" style="zoom:70%;">

<p><strong>Base 理论</strong>的核心思想是<strong>最终一致性</strong>，即使无法做到强一致性（Strong Consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到<strong>最终一致性</strong>（Eventual Consistency）。</p>
<ul>
<li><strong>基本可用：</strong> 就是不追求 CAP 中的「任何时候，读写都是成功的」，而是系统能够基本运行，一直提供服务。基本可用强调了分布式系统在出现不可预知故障的时候，允许损失部分可用性，相比正常的系统，可能是响应时间延长，或者是服务被降级。</li>
<li><strong>软状态：</strong>软状态可以对应 ACID 事务中的原子性（在 ACID 的事务中，实现的是强制一致性，要么全做要么不做，所有用户看到的数据一致。其中的原子性（Atomicity）要求多个节点的数据副本都是一致的，强调数据的一致性，可以理解为一种“硬状态”），软状态则是允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</li>
<li><strong>最终一致性：</strong>数据不可能一直是软状态，必须在一个时间期限之后达到各个节点的一致性，在期限过后，应当保证所有副本保持数据一致性，也就是达到数据的最终一致性。在系统设计中，最终一致性实现的时间取决于网络延时、系统负载、不同的存储选型、不同数据复制方案设计等因素。</li>
</ul>
<p><strong>不同数据一致性模型</strong></p>
<p>一般来说，数据一致性模型可以分为<strong>强一致性</strong>和<strong>弱一致性</strong>，强一致性也叫做线性一致性，除此以外，所有其他的一致性都是弱一致性的特殊情况。弱一致性根据不同的业务场景，又可以分解为更细分的模型，不同一致性模型又有不同的应用场景。</p>
<p>在互联网领域的绝大多数场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p>
<img src="/2020/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/Consistency.png" style="zoom: 67%;">

<p>对于一致性，可以分为从服务端和客户端两个不同的视角，结合全局时钟概念，这里关注的主要是外部一致性。</p>
<p><strong>强一致性</strong></p>
<p>当更新操作完成之后，任何多个后续进程的访问都会返回最新的更新过的值，这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。</p>
<p><strong>弱一致性</strong></p>
<p>系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。用户读到某一操作对系统数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。</p>
<p><strong>最终一致性</strong></p>
<p>最终一致性是弱一致性的特例，强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<p>到达最终一致性的时间 ，就是不一致窗口时间，在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。</p>
<p>最终一致性模型根据其提供的不同保证可以划分为更多的模型，包括因果一致性和会话一致性等。</p>
<ul>
<li><p><strong>因果一致性</strong> ： 因果一致性要求有因果关系的操作顺序得到保证，非因果关系的操作顺序则无所谓。例如：进程 A 在更新完某个数据项后通知了进程 B，那么进程 B 之后对该数据项的访问都应该能够获取到进程 A 更新后的最新值，并且如果进程 B 要对该数据项进行更新操作的话，务必基于进程 A 更新后的最新值。</p>
</li>
<li><p><strong>会话一致性</strong>：会话一致性将对系统数据的访问过程框定在了一个会话当中，约定了系统能保证在同一个有效的会话中实现“读己之所写”的一致性，就是在你的一次访问中，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。实际开发中有分布式的 Session 一致性问题，可以认为是会话一致性的一个应用。</p>
</li>
</ul>
<p><strong>CAP  和 Base  的关系</strong></p>
<p>Base 理论是在 CAP 上发展的，CAP 理论描述了分布式系统中数据一致性、可用性、分区容错性之间的制约关系，当你选择了其中的两个时，就不得不对剩下的一个做一定程度的牺牲。</p>
<p>Base 理论则是对 CAP 理论的实际应用，也就是在分区和副本存在的前提下，通过一定的系统设计方案，放弃强一致性，实现基本可用，这是大部分分布式系统的选择，比如 NoSQL 系统、微服务架构。在这个前提下，如何把基本可用做到最好，就是分布式工程师们追求的。</p>
<p>除了 CAP 和 Base，还有 ACID 原理，ACID 是一种强一致性模型，强调原子性、一致性、隔离性和持久性，主要用于在<strong>数据库</strong>实现中。Base 理论面向的是高可用、可扩展的分布式系统，ACID 适合传统金融等业务，在实际场景中，不同业务对数据的一致性要求不一样，ACID 和 Base 理论往往会结合使用。</p>
<h3 id="全局时钟和逻辑时钟"><a href="#全局时钟和逻辑时钟" class="headerlink" title="全局时钟和逻辑时钟"></a>全局时钟和逻辑时钟</h3><p>​    分布式系统解决了<strong>传统单体架构的单点问题和性能容量问题</strong>，另一方面也带来了很多新的问题，其中一个问题就是<strong>多节点的时间同步问题</strong>：不同机器上的物理时钟难以同步，导致无法区分在分布式系统中多个节点的事件时序。</p>
<p>没有全局时钟，绝对的<strong>内部一致性</strong>是没有意义的，一般来说，我们讨论的一致性都是外部一致性，而外部一致性主要指的是多并发访问时更新过的数据如何获取的问题。</p>
<p>和全局时钟相对的，是<strong>逻辑时钟</strong>，逻辑时钟描绘了分布式系统中事件发生的时序，是为了区分现实中的物理时钟提出来的概念。</p>
<p>一般情况下我们提到的时间都是指物理时间，但实际上很多应用中，只要所有机器有相同的时间就够了，这个时间不一定要跟实际时间相同。更进一步解释：如果两个节点之间不进行交互，那么它们的时间甚至都不需要同步。 因此问题的关键点在于节点间的交互要在事件的发生顺序上达成一致，而不是对于时间达成一致。</p>
<p>逻辑时钟的概念也被用来解决分布式一致性问题。</p>
<p><strong>以上学习内容均来自邴越老师《分布式技术原理与实战》课程，用于学习记录，希望大家共同进步，欧耶。</strong></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式架构之事务管理</title>
    <url>/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><blockquote>
<p>事务（Transaction），一般是指要做的或所做的事情。在计算机<a href="https://baike.baidu.com/item/术语" target="_blank" rel="noopener">术语</a>中是指访问并可能更新数据库中各种<a href="https://baike.baidu.com/item/数据项/3227309" target="_blank" rel="noopener">数据项</a>的一个程序执行单元(unit)。事务通常由<a href="https://baike.baidu.com/item/高级数据库/1439366" target="_blank" rel="noopener">高级数据库</a>操纵语言或编程语言（如SQL，C++或Java）书写的<a href="https://baike.baidu.com/item/用户程序/7450916" target="_blank" rel="noopener">用户程序</a>的执行所引起，并用形如<strong>begin transaction</strong>和<strong>end transaction</strong>语句（或<a href="https://baike.baidu.com/item/函数调用/4127405" target="_blank" rel="noopener">函数调用</a>）来界定。事务由事务开始(<strong>begin transaction</strong>)和事务结束(<strong>end transaction</strong>)之间执行的全体操作组成。</p>
<p>— 来自百度百科</p>
</blockquote>
<h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><p>数据库事务的特性包括<strong>原子性</strong>（Atomicity）、<strong>一致性</strong>（Consistency）、<strong>隔离性</strong>（Isolation）和<strong>持久性</strong>（Durabilily），简称 <strong>ACID</strong>。</p>
<p>在数据库执行中，多个并发执行的事务如果涉及到同一份数据的读写就容易出现数据不一致的情况，不一致的异常现象有以下几种。</p>
<p><strong>脏读</strong>，是指一个事务中访问到了另外一个事务未提交的数据。</p>
<p>例如事务 T1 中修改的数据项在尚未提交的情况下被其他事务（T2）读取到，如果 T1 进行回滚操作，则 T2 刚刚读取到的数据实际并不存在。</p>
<p><strong>不可重复读</strong>，是指一个事务读取同一条记录 2 次，得到的结果不一致。</p>
<p>例如事务 T1 第一次读取数据，接下来 T2 对其中的数据进行了更新或者删除，并且 Commit 成功。这时候 T1 再次读取这些数据，那么会得到 T2 修改后的数据，发现数据已经变更，这样 T1 在一个事务中的两次读取，返回的结果集会不一致。</p>
<p><strong>幻读</strong>，是指一个事务读取 2 次，得到的记录条数不一致。</p>
<p>例如事务 T1 查询获得一个结果集，T2 插入新的数据，T2 Commit 成功后，T1 再次执行同样的查询，此时得到的结果集记录数不同。</p>
<p>脏读、不可重复读和幻读有以下的包含关系，如果发生了脏读，那么幻读和不可重复读都有可能出现。</p>
<img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_01.png" style="zoom:80%;">

<h3 id="不同隔离级别"><a href="#不同隔离级别" class="headerlink" title="不同隔离级别"></a>不同隔离级别</h3><p>SQL 标准根据三种不一致的异常现象，将隔离性定义为<strong>四个隔离级别</strong>（Isolation Level），<strong>隔离级别和数据库的性能呈反比，隔离级别越低，数据库性能越高；而隔离级别越高，数据库性能越差</strong>，具体如下：</p>
<img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_02.png" style="zoom: 50%;">

<h4 id="Read-uncommitted-读未提交"><a href="#Read-uncommitted-读未提交" class="headerlink" title="Read uncommitted 读未提交"></a>Read uncommitted 读未提交</h4><p>在该级别下，一个事务对数据修改的过程中，不允许另一个事务对该行数据进行修改，但允许另一个事务对该行数据进行读，不会出现更新丢失，但会出现<strong>脏读、不可重复读</strong>的情况。</p>
<h4 id="Read-committed-读已提交"><a href="#Read-committed-读已提交" class="headerlink" title="Read committed 读已提交"></a>Read committed 读已提交</h4><p>在该级别下，未提交的写事务不允许其他事务访问该行，不会出现脏读，但是读取数据的事务允许其他事务访问该行数据，因此会出现<strong>不可重复读</strong>的情况。</p>
<h4 id="Repeatable-read-可重复读"><a href="#Repeatable-read-可重复读" class="headerlink" title="Repeatable read 可重复读"></a>Repeatable read 可重复读</h4><p>在该级别下，在同一个事务内的查询都是和事务开始时刻一致的，保证对同一字段的多次读取结果都相同，除非数据是被本身事务自己所修改，不会出现同一事务读到两次不同数据的情况。因为没有约束其他事务的新增Insert操作，所以 SQL 标准中可重复读级别会出现<strong>幻读</strong>。</p>
<p>值得一提的是，可重复读是 MySQL InnoDB 引擎的默认隔离级别，但是在 MySQL 额外添加了间隙锁（Gap Lock），可以防止幻读。</p>
<h4 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h4><p>该级别要求所有事务都必须串行执行，可以避免各种并发引起的问题，效率也最低。</p>
<p>对不同隔离级别的解释，其实是为了保持数据库事务中的隔离性（Isolation），目标是使并发事务的执行效果与串行一致，隔离级别的提升带来的是并发能力的下降，两者是负相关的关系。</p>
<h3 id="分布式事务产生的原因"><a href="#分布式事务产生的原因" class="headerlink" title="分布式事务产生的原因"></a>分布式事务产生的原因</h3><p>分布式事务是伴随着系统拆分出现的，分布式系统解决了海量数据服务对扩展性的要求，但是增加了架构上的复杂性，在这一点上，分布式事务就是典型的体现。</p>
<p>在实际开发中，分布式事务产生的原因主要来源于<strong>存储和服务的拆分</strong>。</p>
<h4 id="存储层拆分"><a href="#存储层拆分" class="headerlink" title="存储层拆分"></a>存储层拆分</h4><p>存储层拆分，最典型的就是数据库分库分表，一般来说，当单表容量达到千万级，就要考虑数据库拆分，从单一数据库变成多个分库和多个分表。在业务中如果需要进行跨库或者跨表更新，同时要保证数据的一致性，就产生了分布式事务问题。</p>
<img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_03.png" style="zoom:67%;">

<h4 id="服务层拆分"><a href="#服务层拆分" class="headerlink" title="服务层拆分"></a>服务层拆分</h4><p>服务层拆分也就是业务的服务化，系统架构的演进是从集中式到分布式，业务功能之间越来越解耦合。</p>
<p>比如电商网站系统，业务初期可能是一个单体工程支撑整套服务，但随着系统规模进一步变大，参考康威定律，大多数公司都会将核心业务抽取出来，以作为独立的服务。商品、订单、库存、账号信息都提供了各自领域的服务，业务逻辑的执行散落在不同的服务器上。</p>
<p>用户如果在某网站上进行一个下单操作，那么会同时依赖订单服务、库存服务、支付扣款服务，这几个操作如果有一个失败，那下单操作也就完不成，这就需要分布式事务来保证了。</p>
<img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_04.png" style="zoom: 67%;">

<h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><p>分布式事务的解决方案，典型的有<strong>两阶段和三阶段提交协议</strong>、 <strong>TCC 分段提交</strong>，和<strong>基于消息队列的最终一致性</strong>设计。</p>
<h4 id="2PC-两阶段提交"><a href="#2PC-两阶段提交" class="headerlink" title="2PC 两阶段提交"></a>2PC 两阶段提交</h4><p>两阶段提交（2PC，Two-phase Commit Protocol）是非常经典的<strong>强一致性</strong>、<strong>中心化的原子提交协议</strong>，在各种事务和一致性的解决方案中，都能看到两阶段提交的应用。</p>
<p>二阶段提交算法的成立是基于以下假设的：</p>
<ul>
<li>在该分布式系统中，存在一个节点作为<strong>协调者</strong>（Coordinator），其他节点作为<strong>参与者</strong>（Participants），且节点之间可以进行网络通信；</li>
<li>所有节点都采用<strong>预写式</strong>日志，日志被写入后被保存在可靠的存储设备上，即使节点损坏也不会导致日志数据的丢失；</li>
<li>所有节点不会永久性损坏，即使损坏后仍然可以恢复。</li>
</ul>
<p>两阶段提交中的两个阶段，指的是 <strong>Commit-request</strong> 阶段和 <strong>Commit</strong> 阶段，两阶段提交的流程如下：</p>
<p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_07.png" alt></p>
<h5 id="提交请求阶段"><a href="#提交请求阶段" class="headerlink" title="提交请求阶段"></a>提交请求阶段</h5><p>在提交请求阶段，协调者将通知事务参与者准备提交事务，然后进入表决过程。在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地事务执行成功）或取消（本地事务执行故障），在第一阶段，参与节点并没有进行Commit操作。</p>
<h5 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h5><p>在提交阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消这个事务。这个结果的处理和前面基于半数以上投票的一致性算法不同，必须<strong>当且仅当所有的参与者同意提交</strong>，协调者才会通知各个参与者提交事务，否则协调者将通知各个参与者取消事务。</p>
<p>参与者在接收到协调者发来的消息后将执行对应的操作，也就是本地 Commit 或者 Rollback。</p>
<h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h5><p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_08.png" alt></p>
<p>两阶段提交协议有几个明显的问题：</p>
<ul>
<li>资源被同步阻塞<br>在执行过程中，所有参与节点都是事务独占状态，当参与者占有公共资源时，那么第三方节点访问公共资源会被阻塞。</li>
<li>协调者可能出现单点故障<br>一旦协调者发生故障，参与者会一直阻塞下去。</li>
<li>在 Commit 阶段出现数据不一致<br>在第二阶段中，假设协调者发出了事务 Commit 的通知，但是由于网络问题该通知仅被一部分参与者所收到并执行 Commit，其余的参与者没有收到通知，一直处于阻塞状态，那么，这段时间就产生了数据的不一致性。</li>
</ul>
<h4 id="3PC-三阶段提交"><a href="#3PC-三阶段提交" class="headerlink" title="3PC 三阶段提交"></a>3PC 三阶段提交</h4><p>三阶段提交协议（3PC，Three-phase_commit_protocol）是在 2PC 之上扩展的提交协议，主要是为了解决两阶段提交协议的阻塞问题，从原来的两个阶段扩展为三个阶段，增加了超时机制。<strong>并且把两阶段提交协议的第一个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。</strong></p>
<p>三阶段中的 Three Phase 分别为 <strong>CanCommit</strong>、<strong>PreCommit</strong>、<strong>DoCommit</strong> 阶段。</p>
<p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_09.png" alt></p>
<h5 id="CanCommit-阶段"><a href="#CanCommit-阶段" class="headerlink" title="CanCommit 阶段"></a>CanCommit 阶段</h5><p>3PC 的 CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 Commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。</p>
<h5 id="PreCommit-阶段"><a href="#PreCommit-阶段" class="headerlink" title="PreCommit 阶段"></a>PreCommit 阶段</h5><p>协调者根据参与者的反应情况来决定是否可以继续事务的 PreCommit 操作。根据响应情况，有以下两种可能。</p>
<ul>
<li><p>A. 假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会进行事务的预执行：</p>
<p>发送预提交请求，协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段；<br>事务预提交，参与者接收到 PreCommit 请求后，会执行事务操作；<br>响应反馈，如果参与者成功执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。</p>
</li>
<li><p>B. 假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就中断事务：</p>
<p>发送中断请求，协调者向所有参与者发送 abort 请求；<br>中断事务，参与者收到来自协调者的 abort 请求之后，执行事务的中断。</p>
</li>
</ul>
<h5 id="DoCommit-阶段"><a href="#DoCommit-阶段" class="headerlink" title="DoCommit 阶段"></a>DoCommit 阶段</h5><p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p>
<ul>
<li><p>A. 执行提交</p>
<p>发送提交请求。协调者接收到参与者发送的 ACK 响应后，那么它将从预提交状态进入到提交状态，并向所有参与者发送 doCommit 请求。<br>事务提交。参与者接收到 doCommit 请求之后，执行正式的事务提交，并在完成事务提交之后释放所有事务资源。<br>响应反馈。事务提交完之后，向协调者发送 ACK 响应。<br>完成事务。协调者接收到所有参与者的 ACK 响应之后，完成事务。</p>
</li>
<li><p>B. 中断事务<br>协调者没有接收到参与者发送的 ACK 响应，可能是因为接受者发送的不是 ACK 响应，也有可能响应超时了，那么就会执行中断事务。</p>
</li>
<li><p>C.超时提交<br>参与者如果没有收到协调者的通知，超时之后会执行 Commit 操作。</p>
</li>
</ul>
<h5 id="三阶段提交做的改进"><a href="#三阶段提交做的改进" class="headerlink" title="三阶段提交做的改进"></a>三阶段提交做的改进</h5><p><strong>引入超时机制</strong><br>在 2PC 中，只有协调者拥有超时机制，如果在一定时间内没有收到参与者的消息则默认失败，3PC 同时在协调者和参与者中都引入超时机制。</p>
<p><strong>添加预提交阶段</strong><br>在 2PC 的准备阶段和提交阶段之间，插入一个准备阶段，使 3PC 拥有 CanCommit、PreCommit、DoCommit 三个阶段，PreCommit 是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的</p>
<h5 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h5><p>三阶段提交协议同样存在问题，具体表现为，在阶段三中，如果参与者接收到了 PreCommit 消息后，出现了不能与协调者正常通信的问题，在这种情况下，参与者依然会进行事务的提交，这就出现了数据的不一致性。</p>
<h5 id="二阶段和三阶段提交的应用"><a href="#二阶段和三阶段提交的应用" class="headerlink" title="二阶段和三阶段提交的应用"></a>二阶段和三阶段提交的应用</h5><p>两阶段提交是一种比较精简的一致性算法/协议，很多关系型数据库都是采用两阶段提交协议来完成分布式事务处理的，典型的比如 MySQL 的 XA 规范。</p>
<p>在事务处理、数据库和计算机网络中，两阶段提交协议提供了分布式设计中的数据一致性的保障，整个事务的参与者要么一致性全部提交成功，要么全部回滚。MySQL Cluster 内部数据的同步就是用的 2PC 协议。</p>
<p><strong>MySQL 的主从复制</strong><br>    在 MySQL 中，二进制日志是 server 层，主要用来做主从复制和即时点恢复时使用的；而事务日志（Redo Log）是 InnoDB 存储引擎层，用来保证事务安全的。</p>
<p>​    在数据库运行中，需要保证 Binlog 和 Redo Log 的一致性，如果顺序不一致， 则意味着 Master-Slave 可能不一致。</p>
<p>​    在开启 Binlog 后，如何保证 Binlog 和 InnoDB redo 日志的一致性呢？MySQL 使用的就是二阶段提交，内部会自动将普通事务当做一个 XA 事务（内部分布式事务）来处理：</p>
<ul>
<li>Commit 会被自动的分成 Prepare 和 Commit 两个阶段；</li>
<li>Binlog 会被当做事务协调者（Transaction Coordinator），Binlog Event 会被当做协调者日志。</li>
</ul>
<h4 id="TCC-分段提交"><a href="#TCC-分段提交" class="headerlink" title="TCC 分段提交"></a>TCC 分段提交</h4><p>TCC 是一个分布式事务的处理模型，将事务过程拆分为 Try、Confirm、Cancel 三个步骤，在保证强一致性的同时，最大限度提高系统的可伸缩性与可用性。</p>
<p>TCC 提出了一种新的事务模型，基于<strong>业务层面的事务定义</strong>，锁粒度完全由业务自己控制，目的是解决复杂业务中，跨表跨库等大颗粒度资源锁定的问题。TCC 把事务运行过程分成 Try、Confirm / Cancel 两个阶段，每个阶段的逻辑由业务代码控制，避免了长事务，可以获取更高的性能。</p>
<h5 id="TCC-的各个阶段"><a href="#TCC-的各个阶段" class="headerlink" title="TCC 的各个阶段"></a>TCC 的各个阶段</h5><p>TCC 的具体流程如下图所示：</p>
<p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_10.png" alt></p>
<p><strong>Try 阶段</strong>：调用 Try 接口，尝试执行业务，完成所有业务检查，预留业务资源。</p>
<p><strong>Confirm 或 Cancel 阶段</strong>：两者是互斥的，只能进入其中一个，并且都满足幂等性，允许失败重试。</p>
<ul>
<li>Confirm 操作：对业务系统做确认提交，确认执行业务操作，不做其他业务检查，只使用 Try 阶段预留的业务资源。</li>
<li>Cancel 操作：在业务执行错误，需要回滚的状态下执行业务取消，释放预留资源。<br>Try 阶段失败可以 Cancel，如果 Confirm 和 Cancel 阶段失败了怎么办？</li>
</ul>
<p>TCC 中会添加事务日志，如果 Confirm 或者 Cancel 阶段出错，则会进行重试，所以这两个阶段需要支持幂等；如果重试失败，则需要人工介入进行恢复和处理等。</p>
<h5 id="应用-TCC-的优缺点"><a href="#应用-TCC-的优缺点" class="headerlink" title="应用 TCC 的优缺点"></a>应用 TCC 的优缺点</h5><p>实际开发中，TCC 的本质是把数据库的二阶段提交上升到微服务来实现，从而避免数据库二阶段中长事务引起的低性能风险。</p>
<p>所以说，TCC 解决了跨服务的业务操作原子性问题，比如下订单减库存，多渠道组合支付等场景，通过 TCC 对业务进行拆解，可以让应用自己定义数据库操作的粒度，可以降低锁冲突，提高系统的业务吞吐量。</p>
<p>TCC 的不足主要体现在对微服务的<strong>侵入性强</strong>，TCC 需要对业务系统进行改造，业务逻辑的每个分支都需要实现 try、Confirm、Cancel 三个操作，并且 Confirm、Cancel 必须保证幂等。</p>
<p>另外 TCC 的事务管理器要记录事务日志，也会损耗一定的性能。</p>
<h5 id="从真实业务场景分析-TCC"><a href="#从真实业务场景分析-TCC" class="headerlink" title="从真实业务场景分析 TCC"></a>从真实业务场景分析 TCC</h5><p>下面以一个电商中的支付业务来演示，用户在支付以后，需要进行更新订单状态、扣减账户余额、增加账户积分和扣减商品操作。</p>
<p>在实际业务中为了防止超卖，有下单减库存和付款减库存的区别，支付除了账户余额，还有各种第三方支付等，这里我们为了描述方便，统一使用扣款减库存，扣款来源是用户账户余额。</p>
<p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_11.png" alt></p>
<p><strong>业务逻辑拆解</strong></p>
<p>我们把订单业务拆解为以下几个步骤：</p>
<ul>
<li>订单更新为支付完成状态</li>
<li>扣减用户账户余额</li>
<li>增加用户账户积分</li>
<li>扣减当前商品的库存</li>
</ul>
<p>​    如果不使用事务，上面的几个步骤都可能出现失败，最终会造成大量的数据不一致，比如订单状态更新失败，扣款却成功了；或者扣款失败，库存却扣减了等情况，这个在业务上是不能接受的，会出现大量的客诉。</p>
<p>如果直接应用事务，不使用分布式事务，比如在代码中添加 Spring 的声明式事务 @Transactional 注解，这样做实际上是在事务中嵌套了远程服务调用，一旦服务调用出现超时，事务无法提交，就会导致数据库连接被占用，出现大量的阻塞和失败，会导致服务宕机。另一方面，如果没有定义额外的回滚操作，比如遇到异常，非 DB 的服务调用失败时，则无法正确执行回滚。</p>
<p><strong>业务系统改造</strong></p>
<p>下面应用 TCC 事务，需要对业务代码改造，抽象 Try、Confirm 和 Cancel 阶段。</p>
<p><strong>Try 操作</strong><br>    Try 操作一般都是锁定某个资源，设置一个预备的状态，冻结部分数据。比如，订单服务添加一个预备状态，修改为 UPDATING，也就是更新中的意思，冻结当前订单的操作，而不是直接修改为支付成功。</p>
<p>​    库存服务设置冻结库存，可以扩展字段，也可以额外添加新的库存冻结表。积分服务和库存一样，添加一个预增加积分，比如本次订单积分是 100，添加一个额外的存储表示等待增加的积分，账户余额服务等也是一样的操作。</p>
<p><strong>Confirm 操作</strong><br>    Confirm 操作就是把前边的 Try 操作锁定的资源提交，类比数据库事务中的 Commit 操作。在支付的场景中，包括订单状态从准备中更新为支付成功；库存数据扣减冻结库存，积分数据增加预增加积分。</p>
<p><strong>Cancel 操作</strong><br>    Cancel 操作执行的是业务上的回滚处理，类比数据库事务中的 Rollback 操作。首先订单服务，撤销预备状态，还原为待支付状态或者已取消状态，库存服务删除冻结库存，添加到可销售库存中，积分服务也是一样，将预增加积分扣减掉。</p>
<p><strong>执行业务操作</strong></p>
<p>​    下面来分析业务的实际执行操作，首先业务请求过来，开始执行 Try 操作，如果 TCC 分布式事务框架感知到各个服务的 Try 阶段都成功了以后，就会执行各个服务的 Confirm 逻辑。</p>
<p>如果 Try 阶段有操作不能正确执行，比如订单失效、库存不足等，就会执行 Cancel 的逻辑，取消事务提交。</p>
<h5 id="TCC-对比-2PC-两阶段提交"><a href="#TCC-对比-2PC-两阶段提交" class="headerlink" title="TCC 对比 2PC 两阶段提交"></a>TCC 对比 2PC 两阶段提交</h5><p>TCC 事务模型的思想类似 2PC 提交，对比 TCC 和基于 2PC 事务 XA 规范：</p>
<p><strong>对比 2PC 提交</strong></p>
<p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_12.png" alt></p>
<p><strong>第一阶段</strong><br>    在 XA 事务中，各个 RM 准备提交各自的事务分支，事实上就是准备提交资源的更新操作（insert、delete、update 等）；而在 TCC 中，是主业务操作请求各个子业务服务预留资源。</p>
<p><strong>第二阶段</strong><br>    XA 事务根据第一阶段每个 RM 是否都 prepare 成功，判断是要提交还是回滚。如果都 prepare 成功，那么就 commit 每个事务分支，反之则 rollback 每个事务分支。</p>
<p>​    在 TCC 中，如果在第一阶段所有业务资源都预留成功，那么进入 Confirm 步骤，提交各个子业务服务，完成实际的业务处理，否则进入 Cancel 步骤，取消资源预留请求。</p>
<p><strong>与 2PC/XA 两阶段提交的区别</strong></p>
<p>​    2PC/XA 是数据库或者存储资源层面的事务，实现的是强一致性，在两阶段提交的整个过程中，一直会持有数据库的锁。<br>​    TCC 关注业务层的正确提交和回滚，在 Try 阶段不涉及加锁，是业务层的分布式事务，关注最终一致性，不会一直持有各个业务资源的锁。<br>​    TCC 的核心思想是针对每个业务操作，都要添加一个与其对应的确认和补偿操作，同时把相关的处理，从数据库转移到业务中，以此实现跨数据库的事务。</p>
<h5 id="TCC-分布式服务组件"><a href="#TCC-分布式服务组件" class="headerlink" title="TCC 分布式服务组件"></a>TCC 分布式服务组件</h5><p>在业务中引入 TCC 一般是依赖单独的 TCC 事务框架，可以选择自研或者应用开源组件。TCC 框架扮演了资源管理器的角色，常用的 TCC 开源组件有 Tcc-transaction、ByteTCC、Spring-cloud-rest-tcc 等。</p>
<p>前面介绍过的 Seata，可以选择 <strong>TCC 事务模式</strong>，也支持了 <strong>AT 模式</strong>及 <strong>Saga 模式</strong>。（这俩种模式及框架解决方案可自行查阅）</p>
<h4 id="基于消息补偿的最终一致性"><a href="#基于消息补偿的最终一致性" class="headerlink" title="基于消息补偿的最终一致性"></a>基于消息补偿的最终一致性</h4><p>异步化在分布式系统设计中随处可见，基于消息队列的最终一致性就是一种异步事务机制，在业务中广泛应用。</p>
<p>在具体实现上，基于消息补偿的一致性主要有<strong>本地消息表</strong>和<strong>第三方可靠消息队列</strong>等。</p>
<h5 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h5><p>本地消息表的方案最初是由 ebay 的工程师提出，核心思想是将分布式事务拆分成本地事务进行处理，通过消息日志的方式来异步执行。</p>
<p>本地消息表是一种业务耦合的设计，消息生产方需要额外建一个事务消息表，并记录消息发送状态，消息消费方需要处理这个消息，并完成自己的业务逻辑，另外会有一个异步机制来定期扫描未完成的消息，确保最终一致性。</p>
<p>下面我们用下单减库存业务来简单模拟本地消息表的实现过程：</p>
<p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_05.png" alt></p>
<p>（1）系统收到下单请求，将订单业务数据存入到订单库中，并且同时存储该订单对应的消息数据，比如购买商品的 ID 和数量，消息数据与订单库为同一库，更新订单和存储消息为一个本地事务，要么都成功，要么都失败。</p>
<p>（2）库存服务通过消息中间件收到库存更新消息，调用库存服务进行业务操作，同时返回业务处理结果。</p>
<p>（3）消息生产方，也就是订单服务收到处理结果后，将本地消息表的数据删除或者设置为已完成。</p>
<p>（4）设置异步任务，定时去扫描本地消息表，发现有未完成的任务则重试，保证最终一致性。</p>
<p>以上就是基于本地消息表一致性的主流程，在具体实践中，还有许多分支情况，比如消息发送失败、下游业务方处理失败等。</p>
<h5 id="不要求最终一致性的柔性事务"><a href="#不要求最终一致性的柔性事务" class="headerlink" title="不要求最终一致性的柔性事务"></a>不要求最终一致性的柔性事务</h5><p>除了上述几种，还有一种不保证最终一致性的柔性事务，也称为尽最大努力通知，这种方式适合可以接受部分不一致的业务场景。</p>
<h3 id="分布式事务有哪些开源组件"><a href="#分布式事务有哪些开源组件" class="headerlink" title="分布式事务有哪些开源组件"></a>分布式事务有哪些开源组件</h3><p>分布式事务开源组件应用比较广泛的是蚂蚁金服开源的 <strong>Seata</strong>，也就是 <strong>Fescar</strong>，前身是阿里中间件团队发布的 TXC（Taobao Transaction Constructor）和升级后的 GTS（Global Transaction Service）。</p>
<p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_06.png" alt></p>
<p>Seata 的设计思想是把一个分布式事务拆分成一个包含了若干分支事务（Branch Transaction）的全局事务（Global Transaction）。分支事务本身就是一个满足 ACID 的 本地事务，全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚。 </p>
<p>在 Seata 中，全局事务对分支事务的协调基于两阶段提交协议，类似数据库中的 XA 规范，XA 规范定义了三个组件来协调分布式事务，分别是 AP 应用程序、TM 事务管理器、RM 资源管理器、CRM 通信资源管理器。关于 XA 规范的详细内容，将会在后面的课时中介绍。</p>
<p><strong>以上学习内容均来自邴越老师《分布式技术原理与实战》课程，用于学习记录，希望大家共同进步，欧耶。</strong></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式架构之分布式锁</title>
    <url>/2020/06/10/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h3 id="分布式锁应用场景"><a href="#分布式锁应用场景" class="headerlink" title="分布式锁应用场景"></a>分布式锁应用场景</h3><p>​    电商网站都会遇到秒杀、特价之类的活动，大促活动有一个共同特点就是访问量激增，在高并发下会出现成千上万人抢购一个商品的场景。虽然在系统设计时会通过限流、异步、排队等方式优化，但整体的并发还是平时的数倍以上，参加活动的商品一般都是限量库存，如何防止库存超卖，避免并发问题呢？分布式锁就是一个解决方案。</p>
<h3 id="如何理解分布式锁"><a href="#如何理解分布式锁" class="headerlink" title="如何理解分布式锁"></a>如何理解分布式锁</h3><p>​    在业务开发中，为了保证在多线程下处理共享数据的安全性，需要保证同一时刻只有一个线程能处理共享数据。</p>
<p>​    <strong>Java</strong> 语言给我们提供了线程锁，开放了处理锁机制的 API，比如 <strong>Synchronized</strong>、<strong>Lock</strong> 等。当一个锁被某个线程持有的时候，另一个线程尝试去获取这个锁会失败或者阻塞，直到持有锁的线程释放了该锁。</p>
<p>在单台服务器内部，可以通过线程加锁的方式来同步，避免并发问题，那么在分布式场景下呢？</p>
<p><img src="/2020/06/10/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/lock_01.png" alt></p>
<p>​    分布式场景下解决并发问题，需要应用分布式锁技术。如上图所示，分布式锁的目的是保证在分布式部署的应用集群中，多个服务在请求同一个方法或者同一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行，避免出现并发问题。</p>
<h3 id="分布式锁的常用实现"><a href="#分布式锁的常用实现" class="headerlink" title="分布式锁的常用实现"></a>分布式锁的常用实现</h3><h5 id="一个完备的分布式锁，需要支持哪些特性？"><a href="#一个完备的分布式锁，需要支持哪些特性？" class="headerlink" title="一个完备的分布式锁，需要支持哪些特性？"></a>一个完备的分布式锁，需要支持哪些特性？</h5><p><img src="/2020/06/10/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/lock_03.png" alt></p>
<p>一般来说，生产环境可用的分布式锁需要满足以下几点：</p>
<ul>
<li>互斥性，互斥是锁的基本特征，同一时刻只能有一个线程持有锁，执行临界操作；</li>
<li>超时释放，超时释放是锁的另一个必备特性，可以对比 MySQL InnoDB 引擎中的 innodb_lock_wait_timeout 配置，通过超时释放，防止不必要的线程等待和资源浪费；</li>
<li>可重入性，在分布式环境下，同一个节点上的同一个线程如果获取了锁之后，再次请求还是可以成功；</li>
<li>高性能和高可用，加锁和解锁的开销要尽可能的小，同时也需要保证高可用，防止分布式锁失效；</li>
<li>支持阻塞和非阻塞性，对比 Java 语言中的 wait() 和 notify() 等操作，这个一般是在业务代码中实现，比如在获取锁时通过 while(true) 或者轮询来实现阻塞操作。</li>
</ul>
<p>​    可以看到，实现一个相对完备的分布式锁，并不是锁住资源就可以了，还需要满足一些额外的特性，否则会在业务开发中出现各种各样的问题。</p>
<p>实现分布式锁目前有三种流行方案，即基于<strong>数据库</strong>、<strong>Redis</strong>、<strong>ZooKeeper</strong> 的方案。</p>
<h4 id="基于关系型数据库"><a href="#基于关系型数据库" class="headerlink" title="基于关系型数据库"></a>基于关系型数据库</h4><p>​    基于关系型数据库实现分布式锁，是依赖数据库的唯一性来实现资源锁定，比如主键和唯一索引等。</p>
<p>​    以唯一索引为例，创建一张锁表，定义方法或者资源名、失效时间等字段，同时针对加锁的信息添加唯一索引，比如方法名，当要锁住某个方法或资源时，就在该表中插入对应方法的一条记录，插入成功表示获取了锁，想要释放锁的时候就删除这条记录。</p>
<p>下面创建一张基于数据库的分布式锁表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line"><span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法或者资源'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'对方法加锁'</span>;</span><br></pre></td></tr></table></figure>

<p>当希望对某个方法加锁时，执行以下 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name) <span class="keyword">values</span> (<span class="string">'method_name'</span>);</span><br></pre></td></tr></table></figure>

<p>​    在数据表定义中，我们对 <strong>method_name</strong> 做了唯一性约束，如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么就可以认为操作成功的那个线程获得了该方法的锁，可以执行后面的业务逻辑。</p>
<p>当方法执行完毕之后，想要释放锁的话，在数据库中删除对应的记录即可。</p>
<p>基于数据库实现分布式锁操作简单，<strong>但是并不是一个可以落地的方案，有很多地方需要优化</strong>。</p>
<ul>
<li><p><strong>存在单点故障风险</strong></p>
<p>数据库实现方式强依赖数据库的可用性，一旦数据库挂掉，则会导致业务系统不可用，为了解决这个问题，需要配置数据库主从机器，防止单点故障。</p>
</li>
<li><p><strong>超时无法失效</strong></p>
<p>如果一旦解锁操作失败，则会导致锁记录一直在数据库中，其他线程无法再获得锁，解决这个问题，可以添加独立的定时任务，通过时间戳对比等方式，删除超时数据。</p>
</li>
<li><p><strong>不可重入</strong></p>
<p>可重入性是锁的一个重要特性，以 Java 语言为例，常见的 <strong>Synchronize</strong>、<strong>Lock</strong> 等都支持可重入。在数据库实现方式中，同一个线程在没有释放锁之前无法再次获得该锁，因为数据已经存在，再次插入会失败。实现可重入，需要改造加锁方法，额外存储和判断线程信息，不阻塞获得锁的线程再次请求加锁。</p>
</li>
<li><p><strong>无法实现阻塞</strong></p>
<p>其他线程在请求对应方法时，插入数据失败会直接返回，不会阻塞线程，如果需要阻塞其他线程，需要不断的重试 insert 操作，直到数据插入成功，这个操作是服务器和数据库资源的极大浪费。</p>
<p>可以看到，借助数据库实现一个完备的分布式锁，存在很多问题，并且读写数据库需要一定的性能，可能会影响业务执行的耗时。</p>
</li>
</ul>
<h4 id="基于Redis实现"><a href="#基于Redis实现" class="headerlink" title="基于Redis实现"></a>基于Redis实现</h4><p>​    相比基于数据库实现分布式锁，缓存的性能更好，并且各种缓存组件也提供了多种集群方案，可以解决单点问题。</p>
<p>​    常见的开源缓存组件都支持分布式锁，包括 Redis、Memcached 及 Tair。以常见的 Redis 为例，应用 Redis 实现分布式锁，最直接的想法是利用 <strong>setnx</strong> 和 <strong>expire</strong> 命令实现加锁。</p>
<h5 id="使用-setnx-实现分布式锁"><a href="#使用-setnx-实现分布式锁" class="headerlink" title="使用 setnx 实现分布式锁"></a>使用 setnx 实现分布式锁</h5><p>​    Redis 支持 setnx 指令，只在 key 不存在的情况下，将 key 的值设置为 value，若 key 已经存在，则 setnx 命令不做任何动作。使用 setnx 实现分布式锁的方案，获取锁的方法很简单，只要以该锁为 key，设置一个随机的值即可。如果 setnx 返回 1，则说明该进程获得锁；如果 setnx 返回 0，则说明其他进程已经获得了锁，进程不能进入临界区；如果需要阻塞当前进程，可以在一个循环中不断尝试 setnx 操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(setnx(key,value)==<span class="number">1</span>)&#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//业务处理</span></span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">       <span class="comment">//释放锁</span></span><br><span class="line">       del(key)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    释放锁时只要删除对应的 key 就可以，为了防止系统业务进程出现异常导致锁无法释放，使用 Java 中的 try-catch-finally 来完成锁的释放。</p>
<p>​    对比一下上面说的分布式锁特性，使用这种方式实现分布式锁的问题很明显：<strong>不支持超时释放锁</strong>，如果进程在加锁后宕机，则会导致锁无法删除，其他进程无法获得锁。</p>
<h5 id="使用-setnx-和-expire-实现"><a href="#使用-setnx-和-expire-实现" class="headerlink" title="使用 setnx 和 expire 实现"></a>使用 setnx 和 expire 实现</h5><p>​    在分布式锁的实现中，依赖业务线程进行锁的释放，如果进程宕机，那么就会出现死锁。Redis 在设置一个 key 时，支持设置过期时间，利用这一点，可以在缓存中实现锁的超时释放，解决死锁问题。</p>
<p>在使用 setnx 获取锁之后，通过 expire 给锁加一个过期时间，利用 Redis 的缓存失效策略，进行锁的超时清除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(setnx(key,value)==<span class="number">1</span>)&#123;</span><br><span class="line">     expire(key,expireTime)</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//业务处理</span></span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">       <span class="comment">//释放锁</span></span><br><span class="line">       del(key)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过设置过期时间，避免了占锁到释放锁的过程发生异常而导致锁无法释放的问题，但是在 Redis 中，setnx 和 expire 这两条命令不具备原子性。如果一个线程在执行完 setnx 之后突然崩溃，导致锁没有设置过期时间，那么这个锁就会一直存在，无法被其他线程获取。</p>
<h5 id="使用-set-扩展命令实现"><a href="#使用-set-扩展命令实现" class="headerlink" title="使用 set 扩展命令实现"></a>使用 set 扩展命令实现</h5><p>为了解决这个问题，在 Redis 2.8 版本中，扩展了 set 命令，支持 set 和 expire 指令组合的原子操作，解决了加锁过程中失败的问题。</p>
<p>set 扩展参数的语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET key value expireTime nx</span></span><br></pre></td></tr></table></figure>

<p><strong>nx</strong> 表示仅在键不存在时设置，这样可以在同一时间内完成设置值和设置过期时间这两个操作，防止设置过期时间异常导致的死锁。那么这种方式还存在问题吗？</p>
<p>​    使用 setex 方式看起来解决了锁超时的问题，但在实际业务中，如果对超时时间设置不合理，存在这样一种可能：在加锁和释放锁之间的业务逻辑执行的太长，以至于超出了锁的超时限制，缓存将对应 key 删除，其他线程可以获取锁，出现对加锁资源的并发操作。</p>
<p>我们来模拟下这种情况：</p>
<ul>
<li>客户端 A 获取锁的时候设置了 key 的过期时间为 2 秒，客户端 A 在获取到锁之后，业务逻辑方法执行了 3 秒；</li>
<li>客户端 A 获取的锁被 Redis 过期机制自动释放，客户端 B 请求锁成功，出现并发执行；</li>
<li>客户端 A 执行完业务逻辑后，释放锁，删除对应的 key；</li>
<li>对应锁已经被客户端 B 获取到了，客户端A释放的锁实际是客户端B持有的锁。</li>
</ul>
<p>​    可以看到，第一个线程的逻辑还没执行完，第二个线程也成功获得了锁，加锁的代码或者资源并没有得到严格的串行操作，同时由于叠加了删除和释放锁操作，导致了加锁的混乱。</p>
<p>​    如何避免这个问题呢？首先，基于 Redis 的分布式锁一般是用于耗时比较短的瞬时性任务，业务上超时的可能性较小；其次，在获取锁时，可以设置 value 为一个随机数，在释放锁时进行读取和对比，确保释放的是当前线程持有的锁，一般是通过 Redis 结合 Lua 脚本的方案实现；最后，需要添加完备的日志，记录上下游数据链路，当出现超时，则需要检查对应的问题数据，并且进行人工修复。</p>
<h5 id="分布式锁的高可用"><a href="#分布式锁的高可用" class="headerlink" title="分布式锁的高可用"></a>分布式锁的高可用</h5><p>​    上面分布式锁的实现方案中，都是针对单节点 Redis 而言的，在生产环境中，为了保证高可用，避免单点故障，通常会使用 Redis 集群。</p>
<h5 id="集群下分布式锁存在哪些问题"><a href="#集群下分布式锁存在哪些问题" class="headerlink" title="集群下分布式锁存在哪些问题"></a>集群下分布式锁存在哪些问题</h5><p>​    集群环境下，Redis 通过<strong>主从复制</strong>来实现数据同步，Redis 的主从复制（Replication）是异步的，所以单节点下可用的方案在集群的环境中可能会出现问题，在故障转移（Failover） 过程中丧失锁的安全性。</p>
<p>​    由于 Redis 集群数据同步是异步的，假设 Master 节点获取到锁后在未完成数据同步的情况下，发生节点崩溃，此时在其他节点依然可以获取到锁，出现多个客户端同时获取到锁的情况。</p>
<p>我们模拟下这个场景，按照下面的顺序执行：</p>
<ul>
<li>客户端 A 从 Master 节点获取锁；</li>
<li>Master 节点宕机，主从复制过程中，对应锁的 key 还没有同步到 Slave 节点上；</li>
<li>Slave 升级为 Master 节点，于是集群丢失了锁数据；</li>
<li>其他客户端请求新的 Master 节点，获取到了对应同一个资源的锁；</li>
<li>出现多个客户端同时持有同一个资源的锁，不满足锁的互斥性。</li>
</ul>
<p>可以看到，<strong>单实例场景和集群环境实现分布式锁是不同的</strong>，关于集群下如何实现分布式锁，Redis 的作者 Antirez（Salvatore Sanfilippo）提出了 Redlock 算法，我们一起看一下。</p>
<h5 id="Redlock-算法的流程"><a href="#Redlock-算法的流程" class="headerlink" title="Redlock 算法的流程"></a>Redlock 算法的流程</h5><p>Redlock 算法是在单 Redis 节点基础上引入的高可用模式，Redlock 基于 N 个完全独立的 Redis 节点，一般是大于 3 的奇数个（通常情况下 N 可以设置为 5），可以基本保证集群内各个节点不会同时宕机。</p>
<p>假设当前集群有 5 个节点，运行 Redlock 算法的客户端依次执行下面各个步骤，来完成获取锁的操作：</p>
<ul>
<li><p>客户端记录当前系统时间，以毫秒为单位；</p>
</li>
<li><p>依次尝试从 5 个 Redis 实例中，使用相同的 key 获取锁，当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，超时时间应该小于锁的失效时间，避免因为网络故障出现的问题；</p>
</li>
<li><p>客户端使用当前时间减去开始获取锁时间就得到了获取锁使用的时间，当且仅当从半数以上的 Redis 节点获取到锁，并且当使用的时间小于锁失效时间时，锁才算获取成功；</p>
</li>
<li><p>如果获取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间，减少超时的几率；</p>
</li>
<li><p>如果获取锁失败，客户端应该在所有的 Redis 实例上进行解锁，即使是上一步操作请求失败的节点，防止因</p>
<p>服务端响应消息丢失，但是实际数据添加成功导致的不一致。</p>
</li>
</ul>
<p>在 Redis 官方推荐的 Java 客户端 Redisson 中，内置了对 RedLock 的实现。</p>
<p>分布式系统设计是实现复杂性和收益的平衡，考虑到集群环境下的一致性问题，也要避免过度设计。在实际业务中，一般使用基于单点的 Redis 实现分布式锁就可以，出现数据不一致，通过人工手段去回补。</p>
<h4 id="基于-ZooKeeper-实现"><a href="#基于-ZooKeeper-实现" class="headerlink" title="基于 ZooKeeper 实现"></a>基于 ZooKeeper 实现</h4><p>​    ZooKeeper 有四种节点类型，包括<strong>持久节点</strong>、<strong>持久顺序节点</strong>、<strong>临时节点</strong>和<strong>临时顺序节点</strong>，利用 ZooKeeper 支持临时顺序节点的特性，可以实现分布式锁。</p>
<p>当客户端对某个方法加锁时，在 ZooKeeper 中该方法对应的指定节点目录下，生成一个唯一的临时有序节点。</p>
<p><img src="/2020/06/10/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/lock_02.png" alt></p>
<p>​    判断是否获取锁，只需要判断持有的节点是否是有序节点中序号最小的一个，当释放锁的时候，将这个临时节点删除即可，这种方式可以避免服务宕机导致的锁无法释放而产生的死锁问题。</p>
<p>下面描述使用 ZooKeeper 实现分布式锁的算法流程，根节点为 /lock：</p>
<ul>
<li>客户端连接 ZooKeeper，并在 /lock 下创建临时有序子节点，第一个客户端对应的子节点为 /lock/lock01/00000001，第二个为 /lock/lock01/00000002；</li>
<li>其他客户端获取 /lock01 下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；</li>
<li>如果是则认为获得锁，执行业务代码，否则通过 watch 事件监听 /lock01 的子节点变更消息，获得变更通知后重复此步骤直至获得锁；</li>
<li>完成业务流程后，删除对应的子节点，释放分布式锁。</li>
</ul>
<p>在实际开发中，可以应用 Apache Curator 来快速实现分布式锁，Curator 是 Netflix 公司开源的一个 ZooKeeper 客户端，对 ZooKeeper 原生 API 做了抽象和封装。</p>
<p><strong>以上学习内容均来自邴越老师《分布式技术原理与实战》课程，用于学习记录，希望大家共同进步，欧耶。</strong></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>复习计划</title>
    <url>/2021/01/05/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><ul>
<li><h4 id="Java知识点复习"><a href="#Java知识点复习" class="headerlink" title="Java知识点复习"></a>Java知识点复习</h4></li>
<li><h4 id="常用算法积累"><a href="#常用算法积累" class="headerlink" title="常用算法积累"></a>常用算法积累</h4></li>
<li><h4 id="现有项目理解"><a href="#现有项目理解" class="headerlink" title="现有项目理解"></a>现有项目理解</h4></li>
<li><h4 id="面试准备（目标公司、部门，面试题，时间安排）"><a href="#面试准备（目标公司、部门，面试题，时间安排）" class="headerlink" title="面试准备（目标公司、部门，面试题，时间安排）"></a>面试准备（目标公司、部门，面试题，时间安排）</h4></li>
</ul>
<h2 id="Java复习知识点"><a href="#Java复习知识点" class="headerlink" title="Java复习知识点"></a>Java复习知识点</h2><ul>
<li><p>操作系统与计算机网络</p>
</li>
<li><p>Java语言特性与设计模式</p>
</li>
<li><p>深入浅出JVM</p>
</li>
<li><p>并发与多线程</p>
</li>
<li><p>数据结构与算法</p>
</li>
<li><p>常用工具集</p>
</li>
<li><p>必会框架：Spring全家桶、RPC与ORM、Netty等</p>
</li>
<li><p>缓存（Redis、MonggoDB）</p>
</li>
<li><p>消息队列</p>
</li>
<li><p>Mysql调优（Oracle、PostgreSQL）</p>
</li>
<li><p>架构演进与前言技术（理念）</p>
</li>
<li><p>微服务、云原生（结合项目）</p>
</li>
</ul>
<h3 id="操作系统与计算机网络"><a href="#操作系统与计算机网络" class="headerlink" title="操作系统与计算机网络"></a>操作系统与计算机网络</h3><h5 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a><a href="http://blogsea.cn/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">操作系统</a></h5><ol>
<li>计算机组成原理：冯 · 诺依曼 模型、CPU亲和性、CPU位宽、程序执行过程、存储器分级（寄存器、L1\L2\L3 、内存、SSD）等</li>
<li>Linux指令入门：常用Linux命令( 网络、权限、日志操作)、（grep/sed/awk)</li>
<li>操作系统基础知识：内核、用户态与内核态、中断与中断向量、各操作系统区别、操作系统常用基础知识</li>
<li>进程与线程：区别联系、线程调度（切换、并发、协同）、进程调度（IPC）、协程</li>
<li>内存管理：内存分页管理与swap</li>
</ol>
<h5 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><a href="http://blogsea.cn/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="noopener">计算机网络</a></h5><ol>
<li>网络模型：4/7层网络模型</li>
<li>TCP协议：三次握手、四次挥手、滑动窗口与流量控制</li>
<li>UDP协议：优缺点，对比</li>
<li>HTTP协议：组成、状态码、https与http2</li>
<li>I/O模型：阻塞IO、非阻塞IO、IO复用、信号驱动IO、异步IO</li>
<li>I/O多路复用模型：select / poll / epoll 区别</li>
<li>虚拟化（了解）</li>
</ol>
<h3 id="Java语言特性与设计模式"><a href="#Java语言特性与设计模式" class="headerlink" title="Java语言特性与设计模式"></a>Java语言特性与设计模式</h3><h5 id="Java语言特性"><a href="#Java语言特性" class="headerlink" title="Java语言特性"></a><a href="http://blogsea.cn/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">Java语言特性</a></h5><ol>
<li>数据类型：空间占用、基本数据结构、拆箱装箱、自动转型与常用转型、特殊类型场景（String、Interge等）</li>
<li>对象引用：几种引用类型、Java类的特性</li>
<li>动态代理与反射</li>
<li>JUC：Java并发工具包</li>
<li>常用集合：Map（ConcurrentHashMap）、List、Set等</li>
<li>异常机制：异常处理、全局异常捕捉</li>
<li>注解机制：jdk内置注解，元注解，自定义注解</li>
<li>Jdk 版本差异与新特性：7、8、9、11</li>
</ol>
<p><strong>设计模式：</strong></p>
<p>设计模式分为 3 大类型共 23 种：</p>
<ul>
<li>创建型：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>
<li>结构型：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ul>
<p>提炼出最常见设计模式详细了解，主要分为俩个方向：</p>
<p>​        –    了解设计模式的实现</p>
<p>​        –    列举设计模式使用场景（框架）</p>
<p>最常见设计模式：</p>
<ul>
<li>单例模式（几种方式、线程安全）</li>
<li>工厂模式（Spring创建Bean）</li>
<li>代理模式（AOP）</li>
<li>建造者模式（Mybatis）</li>
<li>责任链模式（）</li>
<li>适配器模式（Slf4j 如何支持Log4J）</li>
<li>观察者模式</li>
</ul>
<h3 id="深入浅出JVM"><a href="#深入浅出JVM" class="headerlink" title="深入浅出JVM"></a>深入浅出JVM</h3><ol>
<li>内存模型：程序计数器、方法区、堆、栈、本地方法栈</li>
<li>类加载：双亲委派、Bootstrap类加载器、Extension类加载器、System类加载器、自定义类加载器</li>
<li>GC：分代回收、回收器</li>
<li>编译器优化：指令重排</li>
<li>性能调优：JVM参数、性能分析工具：jstat、jstack、JMC、MAT</li>
<li>其他</li>
</ol>
<h3 id="并发与多线程"><a href="#并发与多线程" class="headerlink" title="并发与多线程"></a>并发与多线程</h3><ol>
<li>线程状态切换</li>
<li>同步与互斥</li>
<li>线程通信</li>
<li>死锁</li>
<li>机制</li>
<li>常用工具类（JUC）</li>
<li>线程池</li>
</ol>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p><strong>数据结构：</strong></p>
<ol>
<li>队列</li>
<li>栈</li>
<li>表：数组、单链表、双链表、循环链表、散列表</li>
<li>图：有向图、无向图、带权图</li>
<li>二叉树：平衡二叉树、红黑树、哈夫曼树、堆</li>
<li>多叉树：B\B+树、字典树</li>
</ol>
<p><strong>算法：</strong></p>
<ol>
<li>常用算法思路</li>
<li>复杂度：时间、空间</li>
<li>字符串匹配：</li>
<li>排序：选择、交换、插入、</li>
<li>查找：二叉查找、二叉树排序、B树等</li>
</ol>
<h3 id="常用工具集"><a href="#常用工具集" class="headerlink" title="常用工具集"></a>常用工具集</h3><ul>
<li>团队协作：Ant、Maven、Gradle、Git、SVN</li>
<li>质量保证：CheckStyle、FindBugs、SonarQube、</li>
<li>压测：JMeter、JMH、AB、LoadRunner</li>
<li>容器与代理：Tomcat、Jetty、Nginx、Envoy、</li>
<li>CI/CD: Gitlab-CI、Jenkins、Travls、CircleCI</li>
<li>JVM工具：JMC、jstack、jmap、jstat、jinfo、jcmd、btrace、MAT</li>
<li>系统分析：vmstat、lostat &amp; lotop、ifstat &amp; iftop 、netstat、dstat、strace、GDB、losf、tcpdump、traceroute</li>
<li>文档管理：javaDoc、Swagger</li>
<li>网络工具：PostMan、WireShark、Fiddler、Charles</li>
</ul>
<h3 id="必会框架"><a href="#必会框架" class="headerlink" title="必会框架"></a>必会框架</h3><ul>
<li><p>Spring 主要知识点：</p>
<ul>
<li>Spring Framework  ：IOC、Context、Bean 管理、AOP、动态代理SpringMVC</li>
<li>SpringBoot：常用注解、自动配置、约定大于配置</li>
<li>SpringData：JDBC、Redis、MonggoDB等相关数据源操作</li>
<li>SpringCloud：微服务解决方案 </li>
</ul>
</li>
<li><p>NIO框架 Netty 、以及基于Netty实现的 主流RPC 框架Motan、Dubbo和gRPC</p>
</li>
<li><p>ORM 框架 Mybatis</p>
</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ol>
<li>类型：本地缓存、分布式缓存、多级缓存</li>
<li>淘汰策略：FIFO、LRU、LFU</li>
<li>缓存问题：缓存不一致、缓存更新、缓存击穿、缓存雪崩</li>
<li>Memcache</li>
<li>Redis</li>
</ol>
<h3 id="消息队列与数据库知识点"><a href="#消息队列与数据库知识点" class="headerlink" title="消息队列与数据库知识点"></a>消息队列与数据库知识点</h3><p><strong>消息队列：</strong></p>
<ul>
<li>使用场景：应用解耦合、服务通信、异步任务、削峰填谷、消息广播</li>
<li>消息协议：JMS、AMQP</li>
<li>常用队列：RabbitMQ、ActiveMQ、RocketMQ、Kafka</li>
</ul>
<p><strong>数据库知识点：</strong></p>
<ul>
<li>数据库中间件：Sharding-Sphere、mycat</li>
<li>关系数据库：Oracle、Mysql、PostgreSQL</li>
<li>NoSQL：Redis、MongoDB、Hbase、</li>
<li>NewSql：TiDB、OceanBase</li>
<li>事务特性：原子性、一致性、隔离性、持久性</li>
<li>事务类型：扁平事务、带包存点的扁平事务、嵌套事务、分布式事务</li>
</ul>
<h3 id="Mysql调优（Oracle、PostgreSQL）"><a href="#Mysql调优（Oracle、PostgreSQL）" class="headerlink" title="Mysql调优（Oracle、PostgreSQL）"></a>Mysql调优（Oracle、PostgreSQL）</h3><ol>
<li>常用语句：条件查询、关联查询、排序查询、分组查询、逻辑关键字、函数</li>
<li>数据类型：整数、浮点、日期、时间、字符、二进制</li>
<li>引擎：MyIASM、InnoDB</li>
<li>锁：表锁、行级锁、共享锁、排他锁</li>
<li>索引：<ul>
<li>类型：唯一索引、主键索引、普通索引、联合索引、全文索引</li>
<li>实现：B-Tree、R-Tree、Hash</li>
</ul>
</li>
<li>存储过程与函数</li>
<li>新特性：隐藏索引、通用表达式、窗口函数</li>
<li>SQL优化：查看慢日志、explain 查看执行计划、优化sql语句</li>
</ol>
<h3 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h3><ul>
<li>单体</li>
<li>微服务</li>
<li>云原生</li>
<li>Mesh Service  sidecar</li>
</ul>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统与计算机网络（二）</title>
    <url>/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="操作系统与计算机网络（二）"><a href="#操作系统与计算机网络（二）" class="headerlink" title="操作系统与计算机网络（二）"></a>操作系统与计算机网络（二）</h1><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><h4 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h4><p>OSI（Open System Interconnection）开放系统互连参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>把复杂的网络划分成为更容易管理的层（将整个庞大而复杂的问题划分为若干个容易处理的小问题）；</li>
<li>没有一个厂家能完整的提供整套解决方案和所有的设备，协议；</li>
<li>独立完成各自该做的任务，互不影响，分工明确，上层不关心下层具体细节，分层同样有益于网络排错<br>功能与代表设备。</li>
</ol>
<table>
<thead>
<tr>
<th>分层</th>
<th>名字</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>应用层</td>
<td>提供网络与用户软件之间的接口服务</td>
</tr>
<tr>
<td>6</td>
<td>表示层</td>
<td>提供格式化的表示和转换数据服务</td>
</tr>
<tr>
<td>5</td>
<td>会话层</td>
<td>提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制</td>
</tr>
<tr>
<td>4</td>
<td>传输层</td>
<td>提供建立、维护和取消传输连接功能，负责可靠或不可靠传输数据</td>
</tr>
<tr>
<td>3</td>
<td>网络层</td>
<td>处理网络间路由，确保数据及时传送</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层</td>
<td>负责无错传输数据，确认帧，发错重传等</td>
</tr>
<tr>
<td>1</td>
<td>物理层</td>
<td>负责最后将信息编码成电流脉冲或其它信号用于网上传输。</td>
</tr>
</tbody></table>
<h4 id="TCP-IP四层网络模型"><a href="#TCP-IP四层网络模型" class="headerlink" title="TCP/IP四层网络模型"></a>TCP/IP四层网络模型</h4><p>TCP/IP分层模型（TCP/IP Layening Model）被称作因特网分层模型(Internet Layering Model)、因特网参考模型(Internet Reference Model)。</p>
<p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/computer_network_01.png" alt="网络模型"></p>
<p>区别：</p>
<ul>
<li>OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型。</li>
<li>OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。</li>
<li>OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。</li>
</ul>
<p>常用协议的总结，这里是根据TCP/IP模型来的，因为通常应用层、表示层、会话层的协议可以共用。</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>网络接口层</td>
<td>以太网协议</td>
</tr>
<tr>
<td>网络层</td>
<td>IP协议、ARP协议（地址解析协议）、RARP协议反向地址转换协议）</td>
</tr>
<tr>
<td>传输层</td>
<td>UDP协议、TCP协议</td>
</tr>
<tr>
<td></td>
<td>TELNET、FPT、SFTP、SMTP、HTTP\HTTPS等</td>
</tr>
</tbody></table>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>TCP 协议是<strong>基于链接</strong>的，也就是传输数据前需要先建立好链接，然后再进行传输。TCP 链接一旦建立，就可以在链接上进行<strong>双向</strong>的通信。</li>
<li>TCP 的传输是<strong>基于字节流</strong>而不是报文，将数据按字节大小进行编号，接收端通过 ACK 来确认收到的数据编号。</li>
<li>通过这种机制，TCP 协议能够保证接收数据的有序性和完整性，因此 TCP 能够提供<strong>可靠性传输</strong>。</li>
<li>TCP 还能提供流量控制能力，通过<strong>滑动窗口</strong>来控制数据的发送速率。滑动窗口的本质是动态缓冲区，接收端根据自己的处理能力，在 TCP 的 Header 中动态调整窗口大小，通过 ACK 应答包通知给发送端，发送端根据窗口大小调整发送的的速度。</li>
<li>仅仅有了流量控制能力还不够，TCP 协议还考虑到了网络问题可能会导致大量重传，进而导致网络情况进一步恶化，因此 TCP 协议还提供<strong>拥塞控制</strong>。TCP 处理拥塞控制主要用到了慢启动、拥塞避免、拥塞发生、快速恢复四个算法。</li>
</ul>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>TCP 是<strong>基于链接</strong>的，所以在传输数据前需要先建立链接，TCP 在传输上是<strong>双工传输</strong>，不区分 Client 端与 Server 端，为了便于理解，我们把主动发起建连请求的一端称作 Client 端，把被动建立链接的一端称作 Server 端。</p>
<p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/computer_network_02.png" alt="网络模型"></p>
<p>首先建立链接前需要 Server 端先监听端口，因此 Server 端建立链接前的初始状态就是 LISTEN 状态，这时 Client 端准备建立链接，先发送一个 SYN 同步包，发送完同步包后，Client 端的链接状态变成了 SYN_SENT 状态。Server 端收到 SYN 后，同意建立链接，会向 Client 端回复一个 ACK。</p>
<p> 由于 TCP 是双工传输，Server 端也会同时向 Client 端发送一个 SYN，申请 Server 向 Client 方向建立链接。发送完 ACK 和 SYN 后，Server 端的链接状态就变成了 SYN_RCVD。 </p>
<p>Client 收到 Server 的 ACK 后，Client 端的链接状态就变成了 ESTABLISHED 状态，同时，Client 向 Server 端发送 ACK，回复 Server 端的 SYN 请求。</p>
<p> Server 端收到 Client 端的 ACK 后，Server 端的链接状态也就变成了的 ESTABLISHED 状态，此时建连完成，双方随时可以进行数据传输。</p>
<p><strong>问题：SYN 洪水攻击</strong></p>
<p>发生的原因，就是 Server 端收到 Client 端的 SYN 请求后，发送了 ACK 和 SYN，但是 Client 端不进行回复，导致 Server 端大量的链接处在 SYN_RCVD 状态，进而影响其他正常请求的建连。可以设置 tcp_synack_retries = 0 加快半链接的回收速度，或者调大 tcp_max_syn_backlog 来应对少量的 SYN 洪水攻击。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/computer_network_03.png" alt="网络模型"></p>
<p>TCP 链接的关闭，通信双方都可以先发起，我们暂且把先发起的一方看作 Client，从图中看出，通信中 Client 和 Server 两端的链接都是 ESTABLISHED 状态，然后 Client 先主动发起了关闭链接请求，Client 向 Server 发送了一个 FIN 包，表示 Client 端已经没有数据要发送了，然后 Client 进入了 FIN_WAIT_1 状态。</p>
<p> Server 端收到 FIN 后，返回 ACK，然后进入 CLOSE_WAIT 状态。此时 Server 属于<strong>半关闭状态</strong>，因为此时 Client 向 Server 方向已经不会发送数据了，可是 Server 向 Client 端可能还有数据要发送。</p>
<p> 当 Server 端数据发送完毕后，Server 端会向 Client 端发送 FIN，表示 Server 端也没有数据要发送了，此时 Server 进入 LAST_ACK 状态，就等待 Client 的应答就可以关闭链接了。 </p>
<p>Client 端收到 Server 端的 FIN 后，回复 ACK，然后进入 TIME_WAIT 状态。TIME_WAIT 状态下需要<strong>等待 2 倍的最大报文段生存时间</strong>，来保证链接的可靠关闭，之后才会进入 CLOSED 关闭状态。而 Server 端收到 ACK 后直接就进入 CLOSED 状态。</p>
<p><strong>问题1</strong>：为什么需要等待 2 倍最大报文段生存时间之后再关闭链接？</p>
<ul>
<li><p>保证 TCP 协议的全双工连接能够可靠关闭；</p>
</li>
<li><p>保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆。</p>
</li>
</ul>
<p><strong>问题2</strong>：大量 Socket 处在 TIME_WAIT 或者 CLOSE_WAIT 状态</p>
<p>一般开启 tcp_tw_reuse 和 tcp_tw_recycle 能够加快 TIME-WAIT 的 Sockets 回收；</p>
<p>而大量 CLOSE_WAIT 可能是被动关闭的一方存在代码 bug，没有正确关闭链接导致的。</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>建立连接时，各端分配一个缓冲区用来存储接收的数据，并将缓冲区的尺寸发送给另一端。</p>
<p>接收方发送的确认消息中包含了自己剩余的缓冲区尺寸。剩余缓冲区空间的数量叫做窗口。其实就是建立连接的双虎互相知道彼此剩余的缓冲区大小。</p>
<p>TCP的滑动窗口是动态的，<strong>应用根据自身的处理能力变化，通过本端TCP接收窗口大小控制来对对对端的发送窗口流量限制。</strong></p>
<p>应用程序在需要（如内存不足）时，通过API通知TCP协议栈缩小TCP的接收窗口。然后TCP协议栈在下个段发送时包含新的窗口大小通知给对端，对端按通知的窗口来改变发送窗口，以此达到减缓发送速率的目的。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做<strong>网络拥塞</strong>。</p>
<p>在计算机网络中数位链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。</p>
<p>TCP拥塞控制：</p>
<ul>
<li>慢开始：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</li>
<li>拥塞避免：拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li>
<li>快重传：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。</li>
<li>快恢复：当发送方连续收到三个重复确认时，说明网络也不那么糟糕，可以快速恢复。</li>
</ul>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>无连接协议，也称透明协议，也位于传输层。</p>
<p><strong>与TCP协议的区别</strong>：</p>
<ol>
<li><p>TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）； UDP提供无连接的传输，通信前不需要建立连接。</p>
</li>
<li><p>TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。</p>
</li>
<li><p>TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。</p>
</li>
<li><p>TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制。</p>
</li>
</ol>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ul>
<li>http协议是基于TCP/IP协议之上的应用层协议。</li>
<li>基于请求-响应模式</li>
<li>无状态保存：HTTP是一种不保存状态,即无状态(stateless)协议。</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
</ul>
<h4 id="请求消息Request"><a href="#请求消息Request" class="headerlink" title="请求消息Request"></a>请求消息Request</h4><p><strong>组成</strong>：<strong>请求行（request line）、请求头部（header）、空行</strong>和<strong>请求数据</strong>四个部分组成。</p>
<p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/computer_network_04.png" alt="网络模型"></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET /abc.jpg HTTP/<span class="number">1.1</span></span><br><span class="line">Host    img.mukewang.com</span><br><span class="line">User-Agent    Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; WOW64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">51.0</span><span class="number">.2704</span><span class="number">.106</span> Safari/<span class="number">537.36</span></span><br><span class="line">Accept    image/webp,image<span class="comment">/*,*/</span>*;q=<span class="number">0.8</span></span><br><span class="line">Referer    http:<span class="comment">//www.www.baidu.com/</span></span><br><span class="line">Accept-Encoding    gzip, deflate, sdch</span><br><span class="line">Accept-Language    zh-CN,zh;q=<span class="number">0.8</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>请求行：用来说明  请求类型,要访问的资源以及所使用的HTTP版本。</p>
</li>
<li><p>请求头部：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。常用属性如下：</p>
<ul>
<li><p><strong>Accept</strong>     报文头属性告诉服务端 客户端接受什么类型的响应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Accept:text/plain</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Cookie</strong>   浏览器cookie信息</p>
</li>
<li><p><strong>Referer</strong>   表示这个请求是从哪个URL过来的</p>
</li>
<li><p><strong>Cache-Control</strong>   对缓存进行控制，对响应返回的内容在客户端被缓存，或不希望被缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>空行：请求头部后面的空行是必须的</p>
</li>
<li><p>请求数据：也叫主体。</p>
</li>
</ul>
<h4 id="响应消息Response"><a href="#响应消息Response" class="headerlink" title="响应消息Response"></a>响应消息Response</h4><p><strong>组成：状态行、消息报头、空行和响应正文。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--body goes here--&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>状态行：由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>
</li>
<li><p>消息报头，用来说明客户端要使用的一些附加信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date: Fri, <span class="number">22</span> May <span class="number">2009</span> <span class="number">06</span>:<span class="number">07</span>:<span class="number">21</span> GMT <span class="comment">//生成响应的时间</span></span><br><span class="line">Content-Type: text/html; charset=UTF-<span class="number">8</span>  <span class="comment">//媒体类型信息</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>空行：消息报头后面的空行是必须的。</p>
</li>
<li><p>响应正文：服务器返回的正文文本。</p>
</li>
</ul>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><ul>
<li><p>1xx：指示信息–表示请求已接收，继续处理</p>
</li>
<li><p>2xx：成功–表示请求已被成功接收、理解、接受</p>
</li>
<li><p>3xx：重定向–要完成请求必须进行更进一步的操作</p>
</li>
<li><p>4xx：客户端错误–请求有语法错误或请求无法实现</p>
</li>
<li><p>5xx：服务器端错误–服务器未能实现合法的请求</p>
</li>
</ul>
<p>常见状态码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">200</span> OK                        <span class="comment">//客户端请求成功</span></span><br><span class="line"><span class="number">400</span> Bad Request               <span class="comment">//客户端请求有语法错误，不能被服务器所理解</span></span><br><span class="line"><span class="number">401</span> Unauthorized              <span class="comment">//请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span></span><br><span class="line"><span class="number">403</span> Forbidden                 <span class="comment">//服务器收到请求，但是拒绝提供服务</span></span><br><span class="line"><span class="number">404</span> Not Found                 <span class="comment">//请求资源不存在，eg：输入了错误的URL</span></span><br><span class="line"><span class="number">500</span> Internal Server Error     <span class="comment">//服务器发生不可预期的错误</span></span><br><span class="line"><span class="number">503</span> Server Unavailable        <span class="comment">//服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span></span><br></pre></td></tr></table></figure>

<h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET         <span class="comment">//请求指定的页面信息，并返回实体主体。</span></span><br><span class="line">HEAD        <span class="comment">//类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</span></span><br><span class="line">POST        <span class="comment">//向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</span></span><br><span class="line">PUT         <span class="comment">//从客户端向服务器传送的数据取代指定的文档的内容。</span></span><br><span class="line">DELETE      <span class="comment">//请求服务器删除指定的页面。</span></span><br><span class="line">CONNECT     <span class="comment">//HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</span></span><br><span class="line">OPTIONS     <span class="comment">//允许客户端查看服务器的性能。</span></span><br><span class="line">TRACE       <span class="comment">//回显服务器收到的请求，主要用于测试或诊断。</span></span><br></pre></td></tr></table></figure>



<h3 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h3><p>五种IO模型：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。</p>
<h4 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h4><p>最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。</p>
<p>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p>
<h4 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h4><p>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。</p>
<p>如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p>
<p> 所以事实上，在非阻塞IO模型中，用户线程需要<strong>不断地询问内核数据是否就绪</strong>，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p>
<h4 id="多路复用IO模型"><a href="#多路复用IO模型" class="headerlink" title="多路复用IO模型"></a>多路复用IO模型</h4><p>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p>
<p>不过要注意的是，多路复用IO模型是通过<strong>轮询</strong>的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
<p>多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。</p>
<h4 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h4><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p>
<h4 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h4><p>异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要关心实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。</p>
<p>异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。简称AIO。</p>
<h3 id="I-O多路复用模型"><a href="#I-O多路复用模型" class="headerlink" title="I/O多路复用模型"></a>I/O多路复用模型</h3><p>Linux 下有三种提供 I/O 多路复用的 API，分别是：</p>
<ul>
<li>select</li>
</ul>
<ul>
<li>poll</li>
</ul>
<ul>
<li>epoll</li>
</ul>
<p>一个 Socket 文件，可以由多个进程使用；而一个进程，也可以使用多个 Socket 文件。进程和 Socket 之间是<strong>多对多</strong>的关系。另一方面，一个 Socket 也会有不同的事件类型。因此操作系统很难判断，将哪样的事件给哪个进程。</p>
<p>这样在进程内部就需要一个数据结构来<strong>描述自己会关注哪些 Socket 文件的哪些事件</strong>（读、写、异常等）。通常有两种考虑方向，一种是利用<strong>线性结构</strong>，比如说数组、链表等，这类结构的查询需要遍历。每次内核产生一种消息，就<strong>遍历</strong>这个线性结构。另一种是<strong>索引结构</strong>，内核发生了消息可以通过索引结构马上知道这个消息进程关不关注。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h4><p><strong>select 和 poll 都采用线性结构</strong>，select 允许用户传入 3 个集合。如下面这段程序所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fd_set read_fd_set, write_fd_set, error_fd_set;</span><br><span class="line">while(true) &#123;</span><br><span class="line">  select(..., &amp;read_fd_set, &amp;write_fd_set, &amp;error_fd_set); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次 select 操作会阻塞当前线程，在阻塞期间所有操作系统产生的每个消息，都会通过遍历的手段查看是否在 3 个集合当中。上面程序<code>read_fd_set</code>中放入的是当数据可以读取时进程关心的 Socket；<code>write_fd_set</code>是当数据可以写入时进程关心的 Socket；<code>error_fd_set</code>是当发生异常时进程关心的 Socket。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><p>从写程序的角度来看，select 并不是一个很好的编程模型。<strong>一个好的编程模型应该是直接抽象成消息：用户不需要用 select 来设置自己的集合，而是可以通过系统的 API 直接拿到对应的消息，从而处理对应的文件描述符。</strong></p>
<p>比如下面这段伪代码就是一个更好的编程模型，具体的分析如下：</p>
<ol>
<li>poll 是一个阻塞调用，它将某段时间内操作系统内发生的且进程关注的消息告知用户程序；</li>
<li>用户程序通过直接调用 poll 函数拿到消息；</li>
<li>poll 函数的第一个参数告知内核 poll 关注哪些 Socket 及消息类型；</li>
<li>poll 调用后，经过一段时间的等待（阻塞），就拿到了是一个消息的数组；</li>
<li>通过遍历这个数组中的消息，能够知道关联的文件描述符和消息的类型；</li>
<li>通过消息类型判断接下来该进行读取还是写入操作；</li>
<li>通过文件描述符，可以进行实际地读、写、错误处理。</li>
</ol>
<p>poll 虽然优化了编程模型，但是从性能角度分析，它和 select 差距不大。因为内核在产生一个消息之后，依然需要遍历 poll 关注的所有文件描述符来确定这条消息是否跟用户程序相关。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll()"></a>epoll()</h4><p>为了解决上述问题，epoll 通过更好的方案实现了从操作系统订阅消息。epoll 将进程关注的文件描述符存入一棵二叉搜索树，通常是红黑树的实现。在这棵红黑树当中，Key 是 Socket 的编号，值是这个 Socket 关注的消息。</p>
<p>另外当有关注的事件发生时，epoll 会先放到一个队列当中。当用户调用epoll_wait时候，就会从队列中返回一个消息。epoll 函数本身是一个构造函数，只用来创建红黑树和队列结构。epoll_wait调用后，如果队列中没有消息，也可以马上返回。因此epoll是一个非阻塞模型。</p>
<blockquote>
<p>笔记来源：网络以及 林䭽 老师的《重学操作系统》课程</p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>面试复习</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统与计算机网络（一）</title>
    <url>/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="操作系统与计算机网络（一）"><a href="#操作系统与计算机网络（一）" class="headerlink" title="操作系统与计算机网络（一）"></a>操作系统与计算机网络（一）</h1><h3 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h3><h4 id="冯-·-诺依曼模型"><a href="#冯-·-诺依曼模型" class="headerlink" title="冯 · 诺依曼模型"></a>冯 · 诺依曼模型</h4><p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/operation_system_01.png" alt="冯·诺依曼模型"></p>
<p>1945 年冯诺依曼和其他几位科学家遵循图灵机的设计，提出用电子元件构造计算机，约定了用二进制进行计算和存储，并且将计算机结构分成以下 5 个部分：</p>
<ul>
<li>输入设备；</li>
</ul>
<ul>
<li>输出设备；</li>
</ul>
<ul>
<li>内存；</li>
</ul>
<ul>
<li>中央处理器；</li>
</ul>
<ul>
<li>总线</li>
</ul>
<h5 id="输入、输出设备"><a href="#输入、输出设备" class="headerlink" title="输入、输出设备"></a>输入、输出设备</h5><p>输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。</p>
<h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><p>在冯诺依曼模型中，程序和数据被存储在一个被称作<strong>内存</strong>的<strong>线性排列存储区域</strong>。</p>
<p>存储的数据单位是一个二进制位（bit）。最小的存储单位叫作字节（byte），也就是 8 位，每一个字节都对应一个内存地址。内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。</p>
<p>我们通常说的内存都是<strong>随机存取器</strong>，也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。</p>
<h5 id="中央处理器CPU"><a href="#中央处理器CPU" class="headerlink" title="中央处理器CPU"></a>中央处理器CPU</h5><p>冯诺依曼模型中 CPU 负责<strong>控制</strong>和<strong>计算</strong>。为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。</p>
<ul>
<li>如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；</li>
<li>如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU；</li>
</ul>
<p>这里的 32 和 64，称作 CPU 的<strong>位宽</strong>。</p>
<p>数据如何通过线路传递？其实是通过电压，低电压是 0，高电压是 1。如果只有一条线路，每次只能传递 1 个信号，因为你必须在 0,1 中选一个。比如你构造高高低低这样的信号，其实就是 1100，相当于你传了一个数字 10 过去。这种传递是相当慢的，因为你需要传递 4 次。</p>
<p>这种一个 bit 一个 bit 发送的方式，我们叫作<strong>串行</strong>。如果希望每次多传一些数据，就需要增加线路，也就是需要<strong>并行</strong>。</p>
<p>如果只有 1 条地址总线，那每次只能表示 0-1 两种情况，所以只能操作 2 个内存地址；如果有 10 条地址总线，一次就可以表示 2^10 种情况，也就是可以操作 10^24 个内存地址；如果你希望操作 4G 的内存，那么就需要 32 条线，因为 2^32 是 4G。所以通常32位CPU 支持最大内存容量为4G。</p>
<p><strong>CPU 三个主要参数：主频、总线频率、缓存容量</strong></p>
<ol>
<li><p>上面说过一次数据传输大小取决于位宽，那么单位时间数据传输频率就是<strong>主频</strong>，即<strong>CPU内核工作的时钟频率</strong>,代表一秒钟内脉冲信号运行了X个周期。主频对提高CPU运算速度至关重要。</p>
<p>主频的单位是 Hz（赫兹）、kHz（千赫）、兆赫（MHz）、吉赫（GHz）、太赫（THz）、拍赫（PHz）、艾赫（EHz）。Hz在电子技术中，是指一个按一定电压幅度，一定时间间隔连续发出的脉冲信号（脉冲信号之间的时间间隔称为周期，时间是s(秒)），一秒钟一个周期就是 1Hz。</p>
</li>
<li><p><strong>总线频率</strong>（FSB）:CPU标注的总线频率是指CPU连接到北桥芯片（北桥芯片用于CPU和内存、显卡、PCI交换数据，而南桥芯片主要负责I/O接口等一些外设接口的控制、IDE设备的控制，了解即可）总线的最高频率。该总线也是CPU与外界交换数据的主要通道，因此前端总线的数据传输能力对整机性能影响很大。</p>
</li>
<li><p><strong>缓存容量</strong>：1L（一级缓存）、2L（二级缓存）、3L（三级缓存）是处理器内部的缓冲存储器，工作在CPU 和内存之间。缓存大小直接影响CPU 的性能。</p>
</li>
</ol>
<p><strong>CPU的亲和性</strong></p>
<p>进程要在某个给定的 CPU 上尽量长时间地运行而不被迁移到其他处理器的倾向性，进程迁移的频率小就意味着产生的负载小。亲和性一词是从affinity翻译来的，实际可以称为CPU绑定。</p>
<p>在多核运行的机器上，每个CPU本身自己会有缓存，在缓存中存着进程使用的数据，而没有绑定CPU的话，进程可能会被操作系统调度到其他CPU上，如此CPU cache（高速缓冲存储器）命中率就低了。</p>
<p>缓存区没有这类数据，要先把内存或硬盘的数据载入缓存。而当缓存区绑定CPU后，程序就会一直在指定的CPU执行，不会被操作系统调度到其他CPU，性能上会有一定的提高。</p>
<p>另外一种使用CPU绑定考虑的是将关键的进程隔离开，对于部分实时进程调度优先级提高，可以将其绑定到一个指定CPU核上，可以保证实时进程的调度，也可以避免其他CPU上进程被该实时进程干扰。</p>
<p>操作系统部分Linux的调度程序同时提供 ” 软CPU亲和性 ”  和 ” 硬CPU亲和性 ”</p>
<ul>
<li>软亲和性：进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他CPU。</li>
<li>硬亲和性：将进程或者线程绑定到某一个指定的cpu核运行</li>
</ul>
<p>补充概念：</p>
<ul>
<li><p>物理CPU：机器上实际安装的CPU个数，比如说你的主板上安装了一块8核CPU，那么物理CPU个数就是1个，所以物理CPU个数就是主板上安装的CPU个数。</p>
</li>
<li><p>逻辑CPU：一般情况，我们认为一颗CPU可以有多个核，加上intel的超线程技术(HT), 可以在逻辑上再分一倍数量的CPU core出来。</p>
</li>
<li><p>超线程技术(Hyper-Threading)：就是利用特殊的硬件指令，把单个物理CPU模拟成两个CPU（逻辑CPU），实现多线程。我们常听到的双核四线程/四核八线程指的就是支持超线程技术的CPU。</p>
</li>
</ul>
<h5 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h5><p>CPU 和内存以及其他设备之间，需要通信，因此用一种特殊的设备进行控制，就是总线。</p>
<ul>
<li>地址总线：专门用来指定CPU 将操作的内存<strong>地址</strong>。</li>
<li>数据总线：用来读写内存中的<strong>数据</strong>。当 CPU 需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据。</li>
<li>控制总线：用来发送和接收关键<strong>信号</strong>。例如中断信号。</li>
</ul>
<h4 id="程序的执行过程"><a href="#程序的执行过程" class="headerlink" title="程序的执行过程"></a>程序的执行过程</h4><ol>
<li><p>首先，CPU 读取 PC 指针指向的<strong>指令</strong>，将它<strong>导入指令寄存器</strong>。</p>
<p>具体来说，完成读取指令这件事情有 3 个步骤：</p>
<ul>
<li><p>步骤 1：CPU 的控制单元操作地址总线指定需要访问的内存地址（简单理解，就是把 PC 指针中的值拷贝到地址总线中）。</p>
</li>
<li><p>步骤 2：CPU 通知内存设备准备数据（内存设备准备好了，就通过数据总线将数据传送给 CPU）。</p>
</li>
<li><p>步骤 3：CPU 收到内存传来的数据后，将这个数据存入指令寄存器。</p>
</li>
</ul>
<p>完成以上 3 步，CPU 成功读取了 PC 指针指向指令，存入了指令寄存器。</p>
</li>
<li><p>然后，CPU 分析指令寄存器中的指令，确定指令的类型和参数。</p>
</li>
<li><p>如果是计算类型的指令，那么就交给逻辑运算单元计算；如果是存储类型的指令，那么由控制单元执行。</p>
</li>
<li><p>PC 指针自增，并准备获取下一条指令。</p>
<p>在 32 位的机器上，指令是 32 位 4 个字节，需要 4 个内存地址存储，因此 PC 指针会自增 4。</p>
</li>
</ol>
<p>注意：</p>
<ul>
<li>内存虽然是一个随机存取器，但是我们通常不会把指令和数据存在一起，这是为了安全起见。</li>
</ul>
<ul>
<li>程序指针也是一个寄存器，64 位的 CPU 会提供 64 位的寄存器，这样就可以使用更多内存地址。64 位的寄存器可以寻址的范围非常大，但是也会受到地址总线条数的限制。比如和 64 位 CPU 配套工作的地址总线只有 40 条，那么可以寻址的范围就只有 1T，也就是 2^40。</li>
</ul>
<p>从 PC 指针读取指令、到执行、再到下一条指令，构成了一个循环，这个不断循环的过程叫作<strong>CPU 的指令周期</strong>。</p>
<h4 id="存储器分级"><a href="#存储器分级" class="headerlink" title="存储器分级"></a>存储器分级</h4><p>原因：</p>
<ul>
<li>存储器大小受体积制约</li>
<li>存储器电子元件密度越大，发热越严重。</li>
<li>与CPU距离越远传输速度越慢</li>
<li>价格</li>
</ul>
<p>不能用一块存储器来解决所有的需求，那就必须把需求分级。</p>
<h5 id="存储器分级策略"><a href="#存储器分级策略" class="headerlink" title="存储器分级策略"></a>存储器分级策略</h5><ol>
<li>寄存器；</li>
<li>L1-Cache；</li>
<li>L2-Cache；</li>
<li>L3-Cahce；</li>
<li>内存；</li>
<li>硬盘/SSD</li>
</ol>
<h5 id="寄存器（Register）"><a href="#寄存器（Register）" class="headerlink" title="寄存器（Register）"></a>寄存器（Register）</h5><p>寄存器紧挨着 CPU 的控制单元和逻辑计算单元，它所使用的材料速度也是最快的。存储器的速度越快、能耗越高、产热越大，而且花费也是最贵的，因此数量不能很多。</p>
<p>寄存器的数量通常在几十到几百之间，每个寄存器可以用来存储一定字节（byte）的数据。比如：</p>
<p>​        32 位 CPU 中大多数寄存器可以存储 4 个字节；</p>
<p>​        64 位 CPU 中大多数寄存器可以存储 8 个字节。</p>
<p>寄存机的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写。比如一条要在 4 个周期内完成的指令，除了读写寄存器，还需要解码指令、控制指令执行和计算。如果寄存器的速度太慢，那 4 个周期就可能无法完成这条指令了。</p>
<h5 id="L1-Cache"><a href="#L1-Cache" class="headerlink" title="L1-Cache"></a>L1-Cache</h5><p>L1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低。通常 L1-Cache 大小在几十 Kb 到几百 Kb 不等，读写速度在 2~4 个 CPU 时钟周期。</p>
<h5 id="L2-Cache"><a href="#L2-Cache" class="headerlink" title="L2-Cache"></a>L2-Cache</h5><p>L2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远。它的大小  比 L1-Cache 更大，具体大小要看 CPU 型号，有 2M 的，也有更小或者更大的，速度在 10~20 个 CPU 周期。</p>
<h5 id="L3-Cache"><a href="#L3-Cache" class="headerlink" title="L3-Cache"></a>L3-Cache</h5><p>L3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远。大小通常比 L2-Cache 更大，读写速度在 20~60 个 CPU 周期。L3 缓存大小也是看型号的，比如 i9 CPU 有 512KB L1 Cache；有 2MB L2 Cache； 有16MB L3 Cache。</p>
<h5 id="内存-1"><a href="#内存-1" class="headerlink" title="内存"></a>内存</h5><p>内存的主要材料是半导体硅，是插在主板上工作的。因为它的位置距离 CPU 有一段距离，所以需要用总线和 CPU 连接。因为内存有了独立的空间，所以体积更大，造价也比上面提到的存储器低得多。现在有的个人电脑上的内存是 16G，但有些服务器的内存可以到几个 T。内存速度大概在 200~300 个 CPU 周期之间。</p>
<h5 id="SSD-和硬盘"><a href="#SSD-和硬盘" class="headerlink" title="SSD 和硬盘"></a>SSD 和硬盘</h5><p>SSD 也叫固态硬盘，结构和内存类似，但是它的优点在于断电后数据还在。内存、寄存器、缓存断电后数据就消失了。内存的读写速度比 SSD 大概快 10~1000 倍。以前还有一种物理读写的磁盘，我们也叫作硬盘，它的速度比内存慢 100W 倍左右。因为它的速度太慢，现在已经逐渐被 SSD 替代</p>
<h3 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h3><p>以下为常用命令，不再过多赘述</p>
<ul>
<li>文件相关：cd 、mkdir、touch、mv、rm、cp、ls、find、whereis、which、locate、more、tail、cat、less、df、rpm、tar等</li>
<li>权限相关：chmod 、chown、chgrp、sudo等</li>
<li>网络相关：ifconfig、netstat、ifup、ifdown等</li>
</ul>
<p>由于开发常用为查看日志，所以需详细了解以下几个命令：</p>
<p>awk、grep、sed是linux操作文本的三大利器，合称文本三剑客。</p>
<p>三者的功能都是处理文本，但侧重点各不相同，其中属awk功能最强大，但也最复杂。</p>
<p><strong>grep</strong>用于单纯的查找或匹配文本，<strong>sed</strong>用于编辑匹配到的文本，<strong>awk</strong>更适合格式化文本，对文本进行较复杂格式处理。</p>
<h4 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h4><p>grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来) 是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [-acinv] [--color=auto] '搜寻字符串' filename</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line">-a ：将 binary 文件以 text 文件的方式搜寻数据</span><br><span class="line">-c ：计算找到 '搜寻字符串' 的次数</span><br><span class="line">-i ：忽略大小写的不同，所以大小写视为相同</span><br><span class="line">-n ：顺便输出行号</span><br><span class="line">-v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！</span><br><span class="line">--color=auto ：可以将找到的关键词部分加上颜色的显示</span><br></pre></td></tr></table></figure>

<h4 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h4><p>sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变除，非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed [-nefr] [动作]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line">-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">-e ：直接在命令列模式上进行 sed 的动作编辑；</span><br><span class="line">-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；</span><br><span class="line">-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)</span><br><span class="line">-i ：直接修改读取的文件内容，而不是输出到终端。</span><br><span class="line"></span><br><span class="line">动作说明： [n1[,n2]]function</span><br><span class="line">n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』</span><br><span class="line"></span><br><span class="line">function：</span><br><span class="line">a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</span><br><span class="line">c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</span><br><span class="line">d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</span><br><span class="line">i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</span><br><span class="line">p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</span><br><span class="line">s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g</span><br></pre></td></tr></table></figure>

<h4 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h4><p>awk是一个强大的文本分析工具，awk是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk` `[options] ``'program'` `var=value ``file``…</span><br><span class="line">awk` `[options] -f programfile var=value ``file``…</span><br><span class="line">awk` `[options] ``'BEGIN&#123; action;… &#125; pattern&#123; action;… &#125; END&#123; action;… &#125;'` `file` `...</span><br></pre></td></tr></table></figure>

<p>常用命令选项：</p>
<ul>
<li>-F fs：fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:</li>
<li>-v var=value：赋值一个用户定义变量，将外部变量传递给awk</li>
<li>-f scripfile：从脚本文件中读取awk命令</li>
</ul>
<p>内置变量：</p>
<ul>
<li>FS ：<strong>输入字段分隔符</strong>，默认为空白字符</li>
<li>OFS ：<strong>输出字段分隔符</strong>，默认为空白字符</li>
<li>RS ：<strong>输入记录分隔符</strong>，指定输入时的换行符，原换行符仍有效</li>
<li>ORS ：<strong>输出记录分隔符</strong>，输出时用指定符号代替换行符</li>
<li>NF ：字段数量，<strong>共有</strong>多少字段， <strong>$NF引用最后一列，$(NF-1)引用倒数第2列</strong></li>
<li>NR ：<strong>行号</strong>，后可跟多个文件，第二个文件行号继续从第一个文件最后行号开始</li>
<li>FNR ：各文件分别计数, 行号，后跟一个文件和NR一样，跟多个文件，第二个文件<strong>行号从1开始</strong></li>
<li>FILENAME ：<strong>当前文件名</strong></li>
<li>ARGC ：<strong>命令行参数</strong>的个数</li>
<li>ARGV ：数组，保存的是命令行所给定的各参数，<strong>查看参数</strong></li>
</ul>
<h3 id="操作系统基础知识"><a href="#操作系统基础知识" class="headerlink" title="操作系统基础知识"></a>操作系统基础知识</h3><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>对于一个现代的操作系统来说，它的内核至少应该提供以下 4 种基本能力：</p>
<ul>
<li>管理进程、线程（决定哪个进程、线程使用 CPU）；</li>
</ul>
<ul>
<li>管理内存（决定内存用来做什么）；</li>
</ul>
<ul>
<li>连接硬件设备（为进程、和设备间提供通信能力）；</li>
</ul>
<ul>
<li>提供系统调用（接收进程发送来的系统调用）。</li>
</ul>
<h5 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h5><p>CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序。</p>
<h5 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h5><p>只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取。</p>
<h5 id="存在原因"><a href="#存在原因" class="headerlink" title="存在原因"></a>存在原因</h5><p>限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据。</p>
<h5 id="用户态与内核态的切换"><a href="#用户态与内核态的切换" class="headerlink" title="用户态与内核态的切换"></a>用户态与内核态的切换</h5><p>所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作.</p>
<p>这时需要一个这样的机制: <strong>用户态程序切换到内核态</strong>, 但是不能控制在内核态中执行的指令</p>
<p>用户态切换到内核态的3种方式：</p>
<p><strong>a. 系统调用</strong></p>
<p>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
<p><strong>b. 异常</strong></p>
<p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
<p><strong>c. 外围设备的中断</strong></p>
<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<h4 id="中断与中断向量"><a href="#中断与中断向量" class="headerlink" title="中断与中断向量"></a>中断与中断向量</h4><p>以用户键盘按键为例，主板知道有新的按键后，通知 CPU，CPU 要中断当前执行的程序，将 PC 指针跳转到一个固定的位置，我们称为一次<strong>中断</strong>（interrupt）。CPU 不知道中断后PC指针的具体位置是多少，而只能跳转到一个固定位置，考虑到系统中会出现各种各样的事件，我们需要根据<strong>中断类型来判断PC 指针跳转的位置</strong>，中断类型不同，PC 指针跳转的位置也可能会不同。比如按键程序、打印机就绪程序、系统异常等都需要中断，包括上面说到的系统调用，也需要中断正在执行的程序，切换到内核态执行内核程序。</p>
<p>因此我们需要把不同的中断类型进行分类，这个类型叫作<strong>中断识别码</strong>。比如按键，我们可以考虑用编号 16，数字 16 就是按键中断类型的识别码。不同类型的中断发生时，CPU 需要知道 PC 指针该跳转到哪个地址，这个地址，称为<strong>中断向量</strong>（Interupt Vector）。</p>
<p>你可以考虑这样的实现：当编号 16 的中断发生时，32 位机器的 PC 指针直接跳转到内存地址 16<em>4 的内存位置。如果设计最多有 255 个中断，编号就是从 0~255，刚好需要 1K 的内存地址存储中断向量——这个 1K 的空间，称为*</em>中断向量表**。</p>
<p>因此 CPU 接收到中断后，CPU 根据中断类型操作 PC 指针，找到中断向量。操作系统必须在这之前，修改中断向量，插入一条指令。比如操作系统在这里写一条Jump指令，将 PC 指针再次跳转到自己处理对应中断类型的程序。</p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><h4 id="进程（Process）"><a href="#进程（Process）" class="headerlink" title="进程（Process）"></a>进程（Process）</h4><p>就是正在执行的应用程序，是软件的执行副本。而<strong>线程</strong>是轻量级的进程。</p>
<p>进程是分配资源的基础单位。而线程很长一段时间被称作轻量级进程（Light Weighted Process），是程序执行的基本单位。</p>
<h5 id="分时和调度"><a href="#分时和调度" class="headerlink" title="分时和调度"></a>分时和调度</h5><p>因为通常机器中 CPU 核心数量少（从几个到几十个）、进程&amp;线程数量很多（从几十到几百甚至更多），因此进程们在操作系统中只能排着队一个个执行。每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（线程）执行。</p>
<p>例如进程 1 执行到一半时，会先挂起，然后进程 2 开始执行。如果进程 2 一次可以执行完，然后进程 3 开始执行，不过进程 3 一次执行不完，在执行了 1 个时间片段后，进程 1 开始执行；就这样如此周而复始。这个就是<strong>分时</strong>技术。</p>
<h4 id="进程和线程的状态"><a href="#进程和线程的状态" class="headerlink" title="进程和线程的状态"></a>进程和线程的状态</h4><p>一个进程（线程）运行的过程，会经历以下 3 个状态：</p>
<ul>
<li>进程（线程）创建后，就开始排队，此时它会处在“就绪”（<strong>Ready</strong>）状态；</li>
<li>当轮到该进程（线程）执行时，会变成“运行”（<strong>Running</strong>）状态；</li>
<li>当一个进程（线程）将操作系统分配的时间片段用完后，会回到“就绪”（<strong>Ready</strong>）状态。</li>
</ul>
<p>有时候一个进程（线程）会等待磁盘读取数据，或者等待打印机响应，此时进程自己会进入“阻塞”（<strong>Block</strong>）状态。需要等待磁盘、打印机处理完成后，通过中断通知 CPU，然后 CPU 再执行一小段中断控制程序，将控制权转给操作系统，操作系统再将原来阻塞的进程（线程）置为“就绪”（Ready）状态重新排队。</p>
<h4 id="进程（线程）切换"><a href="#进程（线程）切换" class="headerlink" title="进程（线程）切换"></a>进程（线程）切换</h4><p>进程（线程）在操作系统中是不断切换的，<strong>现代操作系统中只有线程的切换</strong>。 每次切换需要先保存当前寄存器的值的内存，注意 PC 指针也是一种寄存器。当恢复执行的时候，就需要从内存中读出所有的寄存器，恢复之前的状态，然后执行。</p>
<p>进程（线程）切换分为以下 5 个步骤：</p>
<ol>
<li>当操作系统发现一个进程（线程）需要被切换的时候，直接控制 PC 指针跳转是非常危险的事情，所以操作系统需要发送一个“中断”信号给 CPU，停下正在执行的进程（线程）。</li>
<li>当 CPU 收到中断信号后，正在执行的进程（线程）会立即停止。注意，因为进程（线程）马上被停止，它还来不及保存自己的状态，所以后续操作系统必须完成这件事情。</li>
<li>操作系统接管中断后，趁寄存器数据还没有被破坏，必须马上执行一小段非常底层的程序（通常是汇编编写），帮助寄存器保存之前进程（线程）的状态。</li>
<li>操作系统保存好进程状态后，执行调度程序，决定下一个要被执行的进程（线程）。</li>
<li>最后，操作系统执行下一个进程（线程）。</li>
</ol>
<h4 id="多核处理"><a href="#多核处理" class="headerlink" title="多核处理"></a>多核处理</h4><p>进程（线程）可以<strong>并行</strong>执行。通常情况下，CPU 有几个核，就可以并行执行几个进程（线程）。</p>
<h4 id="锁、信号量和分布式锁"><a href="#锁、信号量和分布式锁" class="headerlink" title="锁、信号量和分布式锁"></a>锁、信号量和分布式锁</h4><h5 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h5><p>原子操作就是<strong>操作不可分</strong></p>
<h5 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h5><p>竞争条件就是说多个线程对一个资源（内存地址）的读写存在竞争，在这种条件下，最后这个资源的值不可预测，而是取决于竞争时具体的执行顺序。</p>
<h5 id="解决竞争条件"><a href="#解决竞争条件" class="headerlink" title="解决竞争条件"></a>解决竞争条件</h5><p>解决竞争条件有很多方案，一种方案就是不要让程序同时进入临界区，这个方案叫作<strong>互斥</strong>。还有一些方案旨在避免竞争条件，比如 <strong>ThreadLocal</strong>、 <strong>cas 指令</strong>以及 <strong>乐观锁</strong>。</p>
<ul>
<li><strong>避免临界区</strong>：不让程序同时进入临界区这个方案比较简单，核心就是我们给每个线程一个变量i，比如利用 ThreadLocal，这样线程之间就不存在竞争关系了。这样做优点很明显，缺点就是并不是所有的情况都允许你这样做。有一些资源是需要共享的。</li>
<li><strong>cas 指令</strong>：另一个方案是利用 CPU 的指令，让i++成为一个原子操作。 很多 CPU 都提供 Compare And Swap 指令。这个指令的作用是更新一个内存地址的值，比如把i更新为i+1，但是这个指令明确要求使用者必须确定知道内存地址中的值是多少。比如一个线程想把i从100更新到101，线程必须明确地知道现在i是 100，否则就会更新失败。</li>
<li><strong>锁（lock）</strong>：目标是实现抢占（preempt）。就是只让给定数量的线程进入临界区。通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。所谓的锁，可以理解为内存中的一个整型数，拥有两种状态：空闲状态和上锁状态。加锁时，判断锁是否空闲，如果空闲，修改为上锁状态，返回成功。如果已经上锁，则返回失败。解锁时，则把锁状态修改为空闲状态。<strong>自旋锁</strong>：自旋锁与<a href="https://baike.baidu.com/item/互斥锁" target="_blank" rel="noopener">互斥锁</a>比较类似，它们都是为了解决对某项资源的互斥使用。无论是<strong><a href="https://baike.baidu.com/item/互斥锁" target="_blank" rel="noopener">互斥锁</a></strong>，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</li>
</ul>
<h5 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h5><p>一个合理的实现就是生产者消费者模型。 wait 是一个生产者，将当前线程挂到一个等待队列上，并休眠。notify 是一个消费者，从等待队列中取出一个线程，并重新排队。</p>
<p>Java 语言中为每个对象增加了一个 Object Header 区域，里面一个锁的位（bit），锁并不需要一个 32 位整数，一个 bit 足够。下面的代码用户使用 synchronized 关键字让临界区访问互斥。</p>
<p>synchronized 关键字的内部实现，用到了封装好的底层代码——<strong>Monitor</strong> 对象。每个 Java 对象都关联了一个 Monitor 对象。Monitor 封装了对锁的操作，这样简化了 Java 程序员的工作，你只需要调用 synchronized 关键字。</p>
<p>另外，Monitor 实现了生产者、消费者模型。</p>
<ul>
<li>如果一个线程拿到锁，那么这个线程继续执行；</li>
</ul>
<ul>
<li>如果一个线程竞争锁失败，Montior 就调用 wait 方法触发生产者的逻辑，把线程加入等待集合；</li>
</ul>
<ul>
<li>如果一个线程执行完成，Monitor 就调用一次 notify 方法恢复一个等待的线程。</li>
</ul>
<p>这样，Monitor 除了提供了互斥，还提供了线程间的通信，避免了使用自旋锁，还简化了程序设计。</p>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。而互斥锁是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才开始可以利用这个资源。比如对全局变量的访问，有时要加锁，操作完了，在解锁。有的时候锁和信号量会同时使用的。</p>
<p>也就是说，信号量不一定是锁定某一个资源，而是流程上的概念，比如：有A,B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，这个任务并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。而线程互斥量则是“锁住某一资源”的概念，在锁定期间内，其他线程无法对被保护的数据进行操作。在有些情况下两者可以互换。</p>
<h5 id="信号量与互斥锁之间的区别"><a href="#信号量与互斥锁之间的区别" class="headerlink" title="信号量与互斥锁之间的区别"></a>信号量与互斥锁之间的区别</h5><ol>
<li>互斥锁用于线程的互斥，信号量用于线程的同步。这是互斥锁和信号量的根本区别，也就是互斥和同步之间的区别。</li>
<li>互斥量值只能为0/1，信号量值可以为非负整数。也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。信号量是通过一个计数器控制对共享资源的访问，信号量的值是一个非负整数，所有通过它的线程都会将该整数减一。如果计数器大于0，则访问被允许，计数器减1；如果为0，则访问被禁止，所有试图通过它的线程都将处于等待状态。</li>
<li>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</li>
</ol>
<h5 id="互斥和同步的定义"><a href="#互斥和同步的定义" class="headerlink" title="互斥和同步的定义"></a>互斥和同步的定义</h5><ul>
<li><p>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p>
</li>
<li><p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p>
</li>
</ul>
<h5 id="死锁、悲观锁-乐观锁"><a href="#死锁、悲观锁-乐观锁" class="headerlink" title="死锁、悲观锁/乐观锁"></a>死锁、悲观锁/乐观锁</h5><p>两个线程互相等待对方获得的锁，就会发生<strong>死锁</strong>。你可以把死锁理解成一个环状的依赖关系。</p>
<p>临界区互斥的方法（对临界区上锁），具有强烈的排他性，对修改持保守态度，我们称为<strong>悲观锁</strong>（Pressimistic Lock）。通常意义上，我们说上锁，就是悲观锁，比如说 MySQL 的表锁、行锁、Java 的锁，本质是互斥（mutex）。</p>
<p>和悲观锁（PressimisticLock）持相反意见的，是<strong>乐观锁</strong>（Optimistic Lock）。即一开始认为没有冲突，在真正操作提交时判断版本是否一致，如果一致直接提交，不一致则打回。</p>
<h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p><a href="http://blogsea.cn/2020/06/10/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">详见：分布式架构之分布式锁</a></p>
<h4 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h4><h5 id="先到先服务"><a href="#先到先服务" class="headerlink" title="先到先服务"></a>先到先服务</h5><p>早期的操作系统是一个个处理作业（Job），比如很多保险业务，每处理一个称为一个作业（Job）。处理作业最容易想到的就是<strong>先到先服务</strong>（First Come First Service，FCFS），也就是先到的作业先被计算，后到的作业，排队进行。</p>
<p>这里需要用到一个叫作<strong>队列</strong>的数据结构，具有<strong>先入先出</strong>（First In First Out，FIFO）性质。先进入队列的作业，先处理，因此从公平性来说，这个算法非常朴素。另外，一个作业完全完成才会进入下一个作业，作业之间不会发生切换，从吞吐量上说，是最优的——因为没有额外开销。</p>
<p>但是这样对于等待作业的用户来说，是有问题的。比如一笔需要用时 1 天的作业 ，如果等待了 10 分钟，用户是可以接受的；一个用时 10 分钟的作业，用户等待一天就要投诉了。 因此如果用时 1 天的作业先到，用时 10 分钟的任务后到，应该优先处理用时少的，也就是<strong>短作业优先</strong>（Shortest Job First，SJF）。</p>
<h5 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h5><p>平均等待时间 = 总等待时间/任务数</p>
<p>平均等待时间和用户满意度是成反比的，等待时间越长，用户越不满意，因此在大多数情况下，应该优先处理用时少的，从而<strong>降低平均等待时长</strong>。</p>
<h5 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h5><p><strong>优先级队列</strong>可以给队列中每个元素一个优先级，优先级越高的任务就会被先执行。</p>
<p>优先级队列的一种实现方法就是用到了堆（Heap）这种数据结构，更最简单的实现方法，就是每次扫描一遍整个队列找到优先级最高的任务。也就是说，堆（Heap）可以帮助你在 O(1) 的时间复杂度内查找到最大优先级的元素。</p>
<p>这样，关于紧急任务如何插队？等待太久的任务如何插队？但是如果先执行的大任务导致后面来的小任务的情况如何处理？</p>
<h5 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h5><p>为了解决这个问题，我们需要用到<strong>抢占</strong>（Preemption）。</p>
<p>抢占就是<strong>把执行能力分时</strong>，分成时间片段。 让每个任务都执行一个时间片段。如果在时间片段内，任务完成，那么就调度下一个任务。如果任务没有执行完成，则中断任务，让任务重新排队，调度下一个任务。</p>
<p>拥有了抢占的能力，再结合之前我们提到的优先级队列能力，这就构成了一个基本的<strong>线程调度模型</strong>。</p>
<p>每个线程执行一个时间片段，然后每次执行完一个线程就执行一段调度程序。</p>
<p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/operation_system_02.png" alt="优先级队列"></p>
<p>图中用红色代表调度程序，其他颜色代表被调度线程的时间片段。调度程序可以考虑实现为一个单线程模型，这样不需要考虑竞争条件。</p>
<p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/operation_system_03.png" alt="线程调度模型"></p>
<h5 id="多级队列模型"><a href="#多级队列模型" class="headerlink" title="多级队列模型"></a>多级队列模型</h5><p>多级队列，就是多个队列执行调度。</p>
<ul>
<li><p>紧急任务仍然走高优队列，非抢占执行。</p>
</li>
<li><p>普通任务先放到优先级仅次于高优任务的队列中，并且只分配很小的时间片；如果没有执行完成，说明任务不是很短，就将任务下调一层。</p>
</li>
<li><p>下面一层，最低优先级的队列中时间片很大，长任务就有更大的时间片可以用。</p>
</li>
</ul>
<p>通过这种方式，短任务会在更高优先级的队列中执行完成，长任务优先级会下调，也就类似实现了最短作业优先的问题。</p>
<p>实际操作中，可以有 n 层，一层层把大任务筛选出来。 最长的任务，放到最闲的时间去执行。要知道，大部分时间 CPU 不是满负荷的。</p>
<p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/operation_system_04.png" alt="线程调度模型"></p>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>进程间通信（Intermediate Process Communication，IPC）。就是操作系统创建的进程们之间在交换数据。更广泛的意义——程序间的通信。 程序可以是进程，可以是线程，可以是一个进程的两个部分（进程自己发送给自己），也可以是分布式的。</p>
<h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>管道提供了一种非常重要的能力，就是组织计算。进程不用知道有管道存在，因此管道的设计是非侵入的。程序员可以先着重在程序本身的设计，只需要预留响应管道的接口，就可以利用管道的能力。</p>
<p>管道的核心是不侵入、灵活，不会增加程序设计负担，又能组织复杂的计算过程。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">进程1 | 进程2 | 进程3 | mysql -u... -p | 爬虫进程</span><br></pre></td></tr></table></figure>

<p>我们可以由进程 1、进程 2、进程 3 计算出 MySQL 需要的语句，然后直接通过管道执行。MySQL经过计算将结果传给一个爬虫进程，爬虫就开始工作。</p>
<h5 id="本地内存共享"><a href="#本地内存共享" class="headerlink" title="本地内存共享"></a>本地内存共享</h5><p>同一个进程的多个线程本身是共享进程内存的。 这种情况不需要特别考虑共享内存。如果是跨进程的线程（或者理解为跨进程的程序），可以考虑使用共享内存。</p>
<p>linux 内存共享库的实现原理是以虚拟文件系统的形式，从内存中划分出一块区域，供两个进程共同使用。看上去是文件，实际操作是内存。</p>
<p>共享内存的方式，速度很快，但是程序不是很好写，因为这是一种侵入式的开发，也就是说你需要为此撰写大量的程序。比如如果修改共享内存中的值，需要调用 API。如果考虑并发控制，还要处理同步问题等。因此，只要不是高性能场景，进程间通信通常不考虑共享内存的方式。</p>
<h5 id="本地消息-队列"><a href="#本地消息-队列" class="headerlink" title="本地消息/队列"></a>本地消息/队列</h5><p>内存共享不太好用，因此本地消息有两种常见的方法。一种是用<strong>消息队列</strong>——现代操作系统都会提供类似的能力。Unix 系可以使用 POSIX 标准的 mqueue。另一种方式，就是直接用网络请求（<strong>远程调用RPC</strong>），比如 TCP/IP 协议，也包括建立在这之上的更多的通信协议。</p>
<ul>
<li><p><strong>远程调用RPC</strong>：一种通过本地程序调用来封装远程服务请求的方法。</p>
<p>程序调用 RPC 的时候，程序看上去是在调用一个本地的方法，或者执行一个本地的任务，但是后面会有一个服务程序（通常称为 stub），将这种本地调用转换成远程网络请求。 同理，服务端接到请求后，也会有一个服务端程序（stub），将请求转换为一个真实的服务端方法调用。</p>
<p>RPC 调用的方式比较适合微服务环境的开发，当然 RPC 通常需要专业团队的框架以支持高并发、低延迟的场景。不过，硬要说 RPC 有额外转化数据的开销（主要是序列化），也没错，但这不是 RPC 的主要缺点。<strong>RPC 真正的缺陷是增加了系统间的耦合。当系统主动调用另一个系统的方法时，就意味着在增加两个系统的耦合。长期增加 RPC 调用，会让系统的边界逐渐腐化。这才是使用 RPC 时真正需要注意的东西。</strong></p>
</li>
<li><p><strong>消息队列</strong>：既然 RPC 会增加耦合，那么怎么办呢——可以考虑事件。事件不会增加耦合，如果一个系统订阅了另一个系统的事件，那么将来无论谁提供同类型的事件，自己都可以正常工作。系统依赖的不是另一个系统，而是某种事件。如果哪天另一个系统不存在了，只要事件由其他系统提供，系统仍然可以正常运转。</p>
</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>随着程序越来越复杂，会出现的内存不足的，程序员必须小心翼翼地处理内存的使用，避免超过允许的内存使用阈值。</p>
<p>那么如何来解决这些问题呢？</p>
<h4 id="交换（Swap）技术"><a href="#交换（Swap）技术" class="headerlink" title="交换（Swap）技术"></a>交换（Swap）技术</h4><p>Swap 技术允许一部分进程使用内存，不使用内存的进程数据先保存在磁盘上。这里提到的数据，是指完整的进程数据，包括正文段（程序指令）、数据段、堆栈段等。轮到某个进程执行的时候，尝试为这个进程在内存中找到一块空闲的区域。如果空间不足，就考虑把没有在执行的进程交换（Swap）到磁盘上，把空间腾挪出来给需要的进程。</p>
<p>每个进程独立得到一个空间——我们称为<strong>地址空间</strong>（Address Space）。你可以认为地址空间是<strong>一块连续分配的内存块</strong>。每个进程在不同地址空间中工作，构成了一个原始的虚拟化技术。</p>
<p>这种方法，是一种比较原始的虚拟化技术，进程使用的是基于地址空间的虚拟地址。但是这种方案有很多明显的缺陷，比如：</p>
<ul>
<li>碎片问题：上图中我们看到进程来回分配、回收交换，内存之间会产生很多缝隙。经过反反复复使用，内存的情况会变得十分复杂，导致整体性能下降。</li>
<li>频繁切换问题：如果进程过多，内存较小，会频繁触发交换。</li>
</ul>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虚拟化技术中，操作系统设计了虚拟内存（理论上可以无限大的空间），受限于 CPU 的处理能力，通常 64bit CPU，就是 2^64 个地址。</p>
<p>虚拟化技术中，应用使用的是虚拟内存，操作系统管理虚拟内存和真实内存之间的映射。操作系统将虚拟内存分成整齐小块，每个小块称为一个<strong>页（Page）</strong>。之所以这样做，原因主要有以下两个方面。</p>
<p>一方面应用使用内存是以页为单位，整齐的页能够避免内存碎片问题。</p>
<p>另一方面，每个应用都有高频使用的数据和低频使用的数据。这样做，操作系统就不必从应用角度去思考哪个进程是高频的，仅需思考哪些页被高频使用、哪些页被低频使用。如果是低频使用，就将它们保存到硬盘上；如果是高频使用，就让它们保留在真实内存中。</p>
<h4 id="页（Page）和页表"><a href="#页（Page）和页表" class="headerlink" title="页（Page）和页表"></a>页（Page）和页表</h4><p>操作系统将虚拟内存分块，每个小块称为一个<strong>页（Page）</strong>；真实内存也需要分块，每个小块我们称为一个 <strong>Frame</strong>。Page 到 Frame 的映射，需要一种叫作<strong>页表</strong>的结构。</p>
<p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/operation_system_05.png" alt="页和页表"></p>
<blockquote>
<p>笔记来源：林䭽 老师的《重学操作系统》课程</p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语言特性与设计模式（一）</title>
    <url>/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Java语言特性与设计模式（一）"><a href="#Java语言特性与设计模式（一）" class="headerlink" title="Java语言特性与设计模式（一）"></a>Java语言特性与设计模式（一）</h1><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul>
<li>字符类型：char</li>
<li>布尔类型：boolean</li>
<li>数值类型：byte、short、int、long、float、double</li>
</ul>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>大小(字节)</th>
<th>默认值</th>
<th>封装类</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
<td>(byte)0</td>
<td>Byte</td>
<td>最小值-128（-2^7） 最大值 127（2^7-1）</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>(short)0</td>
<td>Short</td>
<td>最小值 -32768（-2^15） 最大值 32767（2^15 - 1）</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>0</td>
<td>Integer</td>
<td>最小值 -2,147,483,648（-2^31） 最大值 2,147,483,647（2^31 - 1）</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>0L</td>
<td>Long</td>
<td>最小值 -9,223,372,036,854,775,808（-2^63） 最大值 9,223,372,036,854,775,807（2^63 -1）</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>0.0f</td>
<td>Float</td>
<td>最小值1.4E-45 （2的-149次方） 最大值 3.4028235E38 （2的128次方-1）</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>0.0d</td>
<td>Double</td>
<td>最小值 4.9E-324 （2的-1074次方） 最大值 1.7976931348623157E308 （2的1024次方-1）</td>
</tr>
<tr>
<td>boolean</td>
<td>-</td>
<td>false</td>
<td>Boolean</td>
<td>true 和 false</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>\u0000(null)</td>
<td>Character</td>
<td>最小值 \u0000（即为0） 最大值 \uffff（即为65,535）</td>
</tr>
<tr>
<td>void</td>
<td>-</td>
<td>-</td>
<td>Void</td>
<td>-</td>
</tr>
</tbody></table>
<p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是对象，在实际使用时存在很多的不便，为了解决这个不足，在设计类时java为每个基本数据类型设计了一个对应的类，这些类统称为<strong>包装类</strong>（Wrapper Class），对于包装类说，他们的用途主要包含两种：</p>
<p>  1.作为和基本数据类型对应的类类型存在，方便涉及到对象的操作；</p>
<p>  2.包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法；</p>
<h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><p>​    <strong>装箱</strong>：就是自动将基本数据类型转换为包装类</p>
<p>　<strong>拆箱</strong>：就是自动将包装类转换为基本数据类型</p>
<p><strong>问题1</strong>：通过阅读源码可知<strong>Integer、Short、Byte、Character</strong> 有缓存机制，Double 和 Float 没有缓存机制，其中Integer类型会缓存 -128~127  以内的数字，就有以下情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">100</span>;</span><br><span class="line">Integer b = <span class="number">100</span>;</span><br><span class="line">Integer c = <span class="number">300</span>;</span><br><span class="line">Integer d = <span class="number">300</span>;</span><br><span class="line">Integer e = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">a == b;  <span class="comment">// 使用缓存，所以为true</span></span><br><span class="line">c == d;  <span class="comment">// 大于128 所以新new Integer()</span></span><br><span class="line">a == e;</span><br><span class="line"></span><br><span class="line">结果为： <span class="keyword">true</span>、<span class="keyword">false</span>、<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p><strong>问题2</strong>：java常用数据类型比较大小</p>
<ol>
<li><p>基本类型 byte,char,int,short,long,float,long,double，直接比较大小，&lt; ,&gt;, == 都可以用来直接比较</p>
</li>
<li><p>包装类型,需要考虑<strong>装箱</strong>和<strong>拆箱</strong>，比如：</p>
<p>Integer类型比较，范围在-128到127之间可以直接比较用==进行比较，超过范围的，因为Integer类型在比较大小的时候会拆箱，在超过-128到127范围会重新new对象，此时比较==，两个地址已经不相同</p>
<p>其他类型Double,Float,Long比较“==”相当于比较地址,比较大于，小于还是可以的。</p>
</li>
<li><p>基本类型和包装类型</p>
<p>包装类型和基本类型比较大小，包装类型会先拆箱，转为基本类型然后再作比较，所以包装类型和基本类型可以直接使用&lt; &gt; ==</p>
</li>
</ol>
<h4 id="自动转型与强制转型"><a href="#自动转型与强制转型" class="headerlink" title="自动转型与强制转型"></a>自动转型与强制转型</h4><h5 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h5><p>容量小的数据类型可以自动转换为容量大的数据类型（容量指的是表数范围而不是字节数）；</p>
<p><img src="/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/java_language_01.png" alt="自动类型转换"></p>
<ul>
<li><p>实线表示无数据丢失的自动类型转换</p>
</li>
<li><p>虚线表示在转换过程可能出现精度损失</p>
<p>虽然float与double表示范围都远超过int与long，但是int与long都是全字节表示数字，float与double有部分字节表示正负与指数，这些字节被分担掉表示数字的字节，精确表示数字有限，所以转换时会有精度丢失。</p>
</li>
<li><p>特殊：可以将整型常量直接赋值给byte、short、char等类型变量，而不需要进行强制类型转换，只要不超过其表数范围。</p>
</li>
</ul>
<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>用于显式的转换一个数值的类型，当将一种类型强制转换为另一种类型而又超出了目标类型的表数范围，就会被截断成为一个完全不同的值。</p>
<p>强制类型转换：(转换类型)转换的变量，例：(char)(a+2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> s2 = s1 + <span class="number">2</span>;  <span class="comment">// 自动转换</span></span><br><span class="line"><span class="keyword">short</span> s3=(<span class="keyword">short</span>) s2;  <span class="comment">// 强转</span></span><br></pre></td></tr></table></figure>

<h3 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h3><blockquote>
<p>每种编程语言都有自己的数据处理方式。有些时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操作对象。所有这些在 Java 里都得到了简化，一切都被视为对象。因此，我们可采用一种统一的语法。尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。                                                                   《Java编程思想》</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"张三"</span>);</span><br></pre></td></tr></table></figure>

<p>有人会说，这里的person是一个对象，是Person类的一个实例。</p>
<p>也有人会说，这里的person并不是真正的对象，而是指向所创建的对象的引用。</p>
<p>到底哪种说法是对的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person;</span><br><span class="line">person = <span class="keyword">new</span> Person(<span class="string">"张三"</span>);</span><br></pre></td></tr></table></figure>

<p>这两行代码实现的功能和上面的一行代码是完全一样的。在Java中 new 是用来在堆上创建对象用的，如果person是一个对象的话，那么第二行为何还要通过new来创建对象呢？由此可见，person并不是所创建的对象，“操纵的标识符实际是指向一个对象的引用”，也就是说person是一个引用，是指向一个可以指向Person类的对象的引用。真正创建对象的语句是右边的new Person(“张三”);</p>
<ul>
<li>一个引用可以指向多个对象</li>
<li>一个对象也可以被多个引用所指</li>
</ul>
<p>从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：<strong>强引用</strong>、<strong>软引用</strong>、<strong>弱引用</strong>和<strong>虚引用</strong>。</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，<strong>垃圾回收器绝不会回收它</strong>。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<h4 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a><strong>软引用（SoftReference）</strong></h4><p>如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，<strong>如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<h4 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a><strong>弱引用（WeakReference）</strong></h4><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，<strong>不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<h4 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a><strong>虚引用（PhantomReference）</strong></h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，<strong>在任何时候都可能被垃圾回收</strong>。 虚引用主要用来跟踪对象被垃圾回收的活动。</p>
<p>虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<h3 id="动态代理与反射"><a href="#动态代理与反射" class="headerlink" title="动态代理与反射"></a>动态代理与反射</h3><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>在业务中使用动态代理，一般是为了给需要实现的方法添加预处理或者添加后续操作，但是不干预实现类的正常业务，把一些基本业务和主要的业务逻辑分离。我们一般所熟知的Spring的AOP原理就是基于动态代理实现的。</p>
<p><strong>目前java动态代理的实现分为两种</strong></p>
<ul>
<li><p>基于JDK的动态代理</p>
</li>
<li><p>基于CGILB的动态代理</p>
</li>
</ul>
<h5 id="基于JDK的动态代理"><a href="#基于JDK的动态代理" class="headerlink" title="基于JDK的动态代理"></a><strong>基于JDK的动态代理</strong></h5><ol>
<li><p>创建接口，并实现接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Person接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口的实现，并实现方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你好！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建代理类，实现 <strong>InvocationHandler</strong>接口，实现invoke方法，方法内调用代理对象的方法，可在前后注入非业务代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(PersonProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonProxy</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke调用原有方法，并在前后注入日志</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable 		</span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"------------- BEGIN ------------------"</span>);</span><br><span class="line">        Object invoke = method.invoke(<span class="keyword">this</span>.person, args);</span><br><span class="line">        LOGGER.info(<span class="string">"-------------  END  ------------------"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写实际调用类，这里用main方法。使用<strong>Proxy</strong>类创建代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person chinese = <span class="keyword">new</span> Chinese();</span><br><span class="line">        InvocationHandler proxy = <span class="keyword">new</span> PersonProxy(chinese);</span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        <span class="comment">// 参数1：代理类的类加载器</span></span><br><span class="line">        <span class="comment">// 参数2：实现类的接口，多个用数组</span></span><br><span class="line">        <span class="comment">// 参数3：代理类</span></span><br><span class="line">        Person person = (Person)Proxy.newProxyInstance(proxy.getClass().getClassLoader(), chinese.getClass().getInterfaces(), proxy);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        person.say();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\Java\jdk1<span class="number">.8</span><span class="number">.0_65</span>\bin\java </span><br><span class="line"><span class="number">11</span>:<span class="number">12</span>:<span class="number">35.918</span> [main] INFO com.example.demo.dto.PersonProxy - ------------- BEGIN ------------------</span><br><span class="line">你好！</span><br><span class="line"><span class="number">11</span>:<span class="number">12</span>:<span class="number">35.923</span> [main] INFO com.example.demo.dto.PersonProxy - -------------  END  ------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>Chinese</strong>类中只会输出“你好！”，但是在被代理之后，实际调用的方法是<strong>PersonProxy</strong>的<strong>invoke</strong>方法，这样可以在不修改业务类的情况下对业务类增加一些日志等其他操作，甚至可以直接修改有返回值方法的返回值。</p>
<p><strong>场景举例</strong>：<strong>Mybatis动态代理</strong></p>
<p><strong>Mybatis</strong> 的<strong>DeaultSqlSession</strong>中的<strong>getMapper</strong>方法开始，debug可知内部调用<strong>Configuration</strong> 的<strong>getMapper</strong>方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将将工作继续交到<strong>MapperRegistry</strong>的getMapper的方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到<strong>MapperRegistry</strong>的<strong>getMapper</strong>的方法,这里是通过<strong>MapperProxyFactory</strong>这个工厂生成我们所关注的<strong>MapperProxy</strong>的代理类，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后我们通过<strong>mapperProxyFactory.newInstance(sqlSession);</strong>进入<strong>MapperProxyFactory</strong>的<strong>newInstance</strong>方法中；我们看到这里使用了 <strong>Proxy.newProxyInstance</strong> 方法，这是 我们所说的 JDK动态代理方式创建代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">  <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<strong>MapperProxy</strong> 类，可以看到 其实现了InvocationHandler 接口，关注 invoke 方法中最终返回mapperMethod.execute(sqlSession, args);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    MapperMethod mapperMethod = methodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">      mapperMethod = <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration());</span><br><span class="line">      methodCache.put(method, mapperMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mapperMethod;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@UsesJava</span>7</span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">invokeDefaultMethod</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;MethodHandles.Lookup&gt; constructor = MethodHandles.Lookup<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">        .<span class="title">getDeclaredConstructor</span>(<span class="title">Class</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">      constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">    <span class="keyword">return</span> constructor</span><br><span class="line">        .newInstance(declaringClass,</span><br><span class="line">            MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED</span><br><span class="line">                | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC)</span><br><span class="line">        .unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Backport of java.lang.reflect.Method#isDefault()</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((method.getModifiers()</span><br><span class="line">        &amp; (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) == Modifier.PUBLIC)</span><br><span class="line">        &amp;&amp; method.getDeclaringClass().isInterface();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到类<strong>MapperMethod</strong>类的<strong>execute</strong>方法，发现<strong>execute</strong>中通过调用本类中的其他方法获取并封装返回结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName() </span><br><span class="line">          + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h5 id="基于CGLIB的动态代理"><a href="#基于CGLIB的动态代理" class="headerlink" title="基于CGLIB的动态代理"></a><strong>基于CGLIB的动态代理</strong></h5><p>基于JDK的动态代理一定要继承一个接口，而绝大部分情况是基于POJO类的动态代理，那么CGLIB就是一个很好的选择，在Hibernate框架中PO的字节码生产工作就是靠CGLIB来完成的。</p>
<ol>
<li><p>引入CGLIB的jar包。</p>
</li>
<li><p>创建被代理类。这里使用上面的<strong>Chinese</strong>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你好！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建方法拦截器，实现<strong>MethodInterceptor</strong>接口，对方法进行拦截处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(PersonInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"------------- BEGIN -----------"</span>);</span><br><span class="line">        <span class="comment">// 注意这里使用的是 invokeSuper方法</span></span><br><span class="line">        Object invoke = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        LOGGER.info(<span class="string">"-------------  END  -----------"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写实际调用类，利用<strong>Enhancer</strong>来创建被代理类对象，这样可以拦截方法，对方法进行前置和后置log的添加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// setSuperclass表示设置要代理的类</span></span><br><span class="line">	<span class="comment">// setCallback表示设置回调即MethodInterceptor的实现类</span></span><br><span class="line">	<span class="comment">// 使用create()方法生成一个代理对象，注意要强转一下，因为返回的是Object。</span></span><br><span class="line">       Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">       enhancer.setSuperclass(English<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       enhancer.setCallback(<span class="keyword">new</span> PersonInterceptor());</span><br><span class="line">       English english = (English)enhancer.create();</span><br><span class="line">       english.say();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span>:<span class="number">00</span>:<span class="number">40.809</span> [main] INFO com.example.demo.dto.PersonInterceptor - ------------- BEGIN -----------</span><br><span class="line">Hello World!</span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>:<span class="number">40.836</span> [main] INFO com.example.demo.dto.PersonInterceptor - -------------  END  -----------</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>总结：</strong></p>
<p><strong>Jdk动态代理</strong>的拦截对象是通过<strong>反射</strong>的机制来调用被拦截方法的，反射的效率比较低，所以cglib采用了<strong>FastClass</strong>的机制来实现对被拦截方法的调用（methodProxy.invokeSuper方法内部）。FastClass机制就是对一个类的方法建立索引，通过索引来直接调用相应的方法。</p>
<p><strong>FastClass</strong>有两个方法 getIndex() 和 invoke() 。</p>
<ul>
<li><strong>getIndex()方法</strong>：根据入参（方法名+方法的描述符），对Test的每个方法建立索引，并返回。</li>
<li><strong>invoke()方法</strong>：根据指定的索引，以ol为入参调用对象O的方法。这样就避免了反射调用，提高了效率。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FastClassInfo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    FastClass f1; <span class="comment">// net.sf.cglib.test.Target的fastclass</span></span><br><span class="line">    FastClass f2; <span class="comment">// Target$$EnhancerByCGLIB$$788444a0 的fastclass</span></span><br><span class="line">    <span class="keyword">int</span> i1; <span class="comment">//方法g在f1中的索引</span></span><br><span class="line">    <span class="keyword">int</span> i2; <span class="comment">//方法CGLIB$g$0在f2中的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MethodProxy 中的 invokeSuper 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeSuper</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">        MethodProxy.FastClassInfo fci = <span class="keyword">this</span>.fastClassInfo;</span><br><span class="line">        <span class="keyword">return</span> fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var4.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul>
<li><p><strong>JDK动态代理</strong>通过实现<strong>InvocationHandler</strong>接口创建自己的调用处理器；通过为<strong>Proxy</strong>类指定ClassLoader对象和一组interface来创建动态代理；</p>
<p><strong>CGLib动态代理</strong>使用<strong>Enhancer</strong>类中的<strong>create</strong>方法创建代理对象，<strong>MethodInterceptor</strong> 的实现类提供增强代码。</p>
</li>
<li><p><strong>JDK动态代理</strong>是面向接口的动态代理,被代理类必须实现接口。</p>
<p><strong>CGLib动态代理</strong>是基于子类的动态代理，被代理类不能为final类，方法也不能是final的。</p>
</li>
<li><p>如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）；</p>
<p>如果要被代理的对象不是个实现类那么，Spring会强制使用CGLib来实现动态代理。</p>
</li>
<li><p><strong>JDK动态代理</strong>通过实现该<strong>InvocationHandler</strong>接口定义横切逻辑（，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。</p>
<p><strong>CGLIB</strong>是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</p>
</li>
</ul>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>Java反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时调用任意一个对象的方法。</li>
<li>生成动态代理。</li>
</ul>
<p>Java中主要由以下的类来实现Java反射机制（这些类都位于java.lang.reflect包中）：</p>
<ul>
<li><strong>Class</strong>类：代表一个类。 </li>
<li><strong>Field</strong>类：代表类的成员变量（成员变量也称为类的属性）。</li>
<li><strong>Method</strong>类：代表类的方法。</li>
<li><strong>Constructor</strong>类：代表类的构造方法。</li>
<li><strong>Array</strong>类：提供了动态创建数组，以及访问数组的元素的静态方法。</li>
</ul>
<p><strong>Class</strong>类是Reflection API中的核心类，这里只列举其主要方法，其他方法可查看相应API：</p>
<ul>
<li><strong>getName</strong>()：获得类的完整名字。 getFields()：获得类的public类型的属性。</li>
<li><strong>getDeclaredFields</strong>()：获得类的所有属性。</li>
<li><strong>getMethods</strong>()：获得类的public类型的方法。</li>
<li><strong>getDeclaredMethods</strong>()：获得类的所有方法。</li>
<li><strong>getMethod</strong>(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes参数指定方法的参数类型。</li>
<li><strong>getConstrutors</strong>()：获得类的public类型的构造方法。</li>
<li><strong>getConstrutor</strong>(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes参数指定构造方法的参数类型。</li>
<li><strong>newInstance</strong>()：通过类的不带参数的构造方法创建这个类的一个对象。</li>
</ul>
<h5 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  	 <span class="comment">//1.源头：获取Class对象，用三种方式</span></span><br><span class="line">       Phone iPhone = <span class="keyword">new</span> Phone();</span><br><span class="line">       <span class="comment">//1.1.对象.getClass();获取对象</span></span><br><span class="line">       Class&lt;?&gt; clazz1 = iPhone.getClass();</span><br><span class="line">       <span class="comment">//1.2.类.class</span></span><br><span class="line">       clazz1 = Phone<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">       <span class="comment">//1.3.Class.forName("包名.类名");</span></span><br><span class="line">       clazz1 = Class.forName(<span class="string">"test.Phone"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建对象</span></span><br><span class="line">	<span class="comment">//2.1通过newInstence()</span></span><br><span class="line">       Phone instance1 = (Phone) clazz1.newInstance();</span><br><span class="line">       <span class="comment">//2.2先调用构造器，再通过newInstence()创建</span></span><br><span class="line">       Object instance2 = clazz1.getConstructor().newInstance();</span><br></pre></td></tr></table></figure>

<h5 id="效率提升"><a href="#效率提升" class="headerlink" title="效率提升"></a>效率提升</h5><p>由于反射方式动态创建类，所以效率比较低，例如 <strong>Class.forName</strong> 比较耗时，想要提升反射效率，可以有以下优化点：</p>
<ul>
<li><p>使用较高版本的JDK，Java开发团队一直有对反射优化；</p>
</li>
<li><p>善用API，例如：尽量不要<code>getMethods()</code>后再遍历筛选，而直接用<code>getMethod(methodName)</code>来根据方法名获取方法；</p>
</li>
<li><p>使用缓存，需要多次动态创建一个类的实例，可将其缓存起来，提高效率；</p>
</li>
<li><p>使用高性能的反射库；</p>
</li>
<li><p>field.setAccessible(true); 由于JDK的安全检查耗时较多.所以通过setAccessible(true)的方式关闭安全检查就可以达到提升反射速度的目的。 设置Field对象的Accessible的访问标志位为 true，就可以通过反射获取私有变量的值，在访问时会忽略访问修饰符的检查。这种方式 无法通过sonar 扫描，不推荐使用，实际可使用ReflectionUtils.makeAccessible(field);（未尝试） </p>
</li>
</ul>
<h3 id="常用集合"><a href="#常用集合" class="headerlink" title="常用集合"></a>常用集合</h3><p><img src="/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/java_language_02.gif" alt="Java集合框架图"></p>
<p>集合是一种工具类，就像是容器，储存任意数量的具有共同属性的对象。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>​    <strong>Collection</strong> 接口的接口 对象的集合（单列集合）<br>​    │——-<strong>List</strong> 接口：元素按进入先后有序保存，可重复<br>​    │—————-├ <strong>LinkedList</strong> 接口实现类， 链表， 插入删除， 没有同步， 线程不安全<br>​    │—————-├ <strong>ArrayList</strong> 接口实现类， 数组， 随机访问， 没有同步， 线程不安全<br>​    │—————-└ <strong>Vector</strong> 接口实现类 数组， 同步， 线程安全<br>​    │———————-└ <strong>Stack</strong> 是Vector类的实现类<br>​    │——-<strong>Set</strong> 接口： 仅接收一次，不可重复，并做内部排序<br>​    │—————-└<strong>HashSet</strong> 使用hash表（数组）存储元素<br>​    │————————└ <strong>LinkedHashSet</strong> 链表维护元素的插入次序<br>​    └ —————-<strong>TreeSet</strong> 底层实现为二叉树，元素排好序</p>
<p>​    <strong>Map</strong> 接口 键值对的集合 （双列集合）<br>​    │———<strong>Hashtable</strong> 接口实现类， 同步， 线程安全<br>​    │———<strong>HashMap</strong> 接口实现类 ，没有同步， 线程不安全-<br>​    │—————–├ <strong>LinkedHashMap</strong> 双向链表和哈希表实现<br>​    │—————–└ <strong>WeakHashMap</strong><br>​    │ ——–<strong>TreeMap</strong> 红黑树对所有的key进行排序<br>​    └ ———<strong>IdentifyHashMap</strong></p>
<p><strong>集合与数组对比</strong></p>
<ul>
<li>长度：数组固定，集合可变</li>
<li>内容：数组可以是基本类型和引用类型，集合只能是引用类型</li>
<li>元素内容：数组只能存储同一种类型元素；集合可以存储不同类型（一般存储同一类型）</li>
</ul>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p><strong>List</strong> 是一个接口，它继承于<strong>Collection</strong>的接口。它代表着<strong>有序</strong>的队列，元素可重复。</p>
<p><strong>ArrayList</strong>、 <strong>LinkedList</strong> 和 <strong>Vector</strong>都实现了List接口，是List的三种实现。</p>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><strong>ArrayList</strong></h5><p><strong>ArrayList</strong>实现<strong>List</strong>接口，继承<strong>AbstractList</strong>。</p>
<ul>
<li><p>底层是<strong>数组</strong>实现，在数组中搜索和读取数据是很快的。但是添加、删除时，该元素后面的所有元素都要移动，所以添加/删除数据效率不高。数组有容量，每次达到阈值需要扩容（1.5倍），这个操作比较影响效率。</p>
</li>
<li><p>是非线程安全的，一般用于单线程环境中（与<strong>Vector</strong>最大的区别就是，<strong>Vector</strong>是线程安全的，所以<strong>ArrayList</strong>比<strong>Vector</strong>的性能相对要好些），在多线程中，可以选择<strong>Vector</strong>或者<strong>CopyOnWriteArrayList</strong>。</p>
</li>
<li><p><strong>Arraylist</strong>实现了<strong>Serializable</strong>接口，支持序列化，能够通过序列化传输；</p>
</li>
<li><p>实现了<strong>RandomAccess</strong>接口（只是个标注接口，没有实际的方法），支持快速随机访问，主要变现为可以通过下标直接访问（因为<strong>Arraylist</strong>的底层是数组，可直接用数组下标来索引）；</p>
</li>
<li><p>实现了<strong>Cloneable</strong>接口，能被克隆。</p>
</li>
</ul>
<h5 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a><strong>ArrayList</strong> 源码分析</h5><p><strong>（JDK1.8，后面同上）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认初始容量大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认构造函数，空数组</span></span><br><span class="line"><span class="comment">    * 第一次 add()时，指定初始化长度 10 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">           <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">           <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">           <span class="comment">//创建空数组</span></span><br><span class="line">           <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">   * 如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       elementData = c.toArray();</span><br><span class="line">       <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">           <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">               <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// replace with empty array.</span></span><br><span class="line">           <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造方法：</strong></p>
<ul>
<li>无参构造器：初始化为空数组，第一次<strong>add</strong> 操作时，初始化容量。</li>
<li>指定容量构造器：直接初始化指定容量的数组。</li>
<li>指定Collection构造器：<strong>Arrays.copyOf</strong>  指定数组为传入集合数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 得到最小扩容量</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//判断是否需要扩容</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 要分配的最大数组大小,</span></span><br><span class="line"><span class="comment">    * 源码注释中说考虑到一些虚拟机存在数组元数据，占用8bytes的存储大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">       <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">      <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">      <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">       <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">       <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">       <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">       <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">           Integer.MAX_VALUE :</span><br><span class="line">           MAX_ARRAY_SIZE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><strong>add(e)</strong> 首先调用 <strong>ensureCapacityInternal</strong> 方法判断是否需要扩容，以及进行扩容操作，然后 将 元素 e 放入 数组末尾；</li>
<li><strong>ensureCapacityInternal</strong> 方法先比较 默认容量和传入参数（size + 1），取大值作为 <strong>最小扩容量</strong>，然后进入<strong>ensureExplicitCapacity</strong>方法判断是否需要扩容，如需要则调用 <strong>grow</strong> 方法进行扩容。</li>
<li><strong>grow</strong>是按照旧容量位运算右移一位，加上原容量，得到新容量大小，所以扩容大小为原来的 <strong>1.5 倍</strong>。如果扩容后的容量比最小扩容量小，则以最小扩容量为新容量。得到新容量后，再与<strong>MAX_ARRAY_SIZE</strong>比较，如果h还比其大，则设置最大容量为 <strong>Integer.MAX_VALUE</strong>。</li>
</ul>
<p><strong>ArrayList线程不安全的原因？替代方法？</strong></p>
<p>首先说一下什么是线程不安全：线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。</p>
<p><strong>ArrayList</strong>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">    * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">    * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">    * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<p>通过这两个字段我们可以看出，<strong>ArrayList</strong>的实现主要就是用了一个<strong>Object</strong>的数组，用来保存所有的元素，以及一个<strong>size</strong>变量用来保存当前数组中已经添加了多少元素。</p>
<p>观察源码可知：在多个线程进行<strong>add</strong>操作时可能会导致<strong>elementData</strong>数组越界，<strong>size ++</strong> 在多线程环同样会境下导致 数据问题，所以说 <strong>ArrayList</strong> 是线程不安全的。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>使用 <strong>Vector</strong></p>
</li>
<li><p>使用 <strong>Collections.synchronizedList</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> List&lt;Object&gt; arrayListSafe = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Object&gt;());</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用JUC中的<strong>CopyOnWriteArrayList</strong>类</p>
</li>
</ul>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><ul>
<li>基于双端链表，添加/删除元素只会影响周围的两个节点，开销很低；只能顺序遍历，无法按照索引获得元素，因此查询效率不高；没有固定容量，不需要扩容；</li>
<li>也是线程不安全的。线程安全可以使用 <strong>Collections.synchronizedList</strong>（类似<strong>ArrayList</strong>）。</li>
<li><strong>LinkedList</strong>实现了<strong>Serializable</strong>接口，支持序列化，能够通过序列化传输；</li>
<li>实现了<strong>Cloneable</strong>接口，能被克隆。</li>
<li>和<strong>ArrayList</strong> 一样，不是同步容器</li>
</ul>
<h5 id="LinkedList-源码分析"><a href="#LinkedList-源码分析" class="headerlink" title="LinkedList 源码分析"></a>LinkedList 源码分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到， <strong>LinkedList</strong> 的成员变量只有三个：</p>
<ul>
<li>头节点 <strong>first</strong></li>
<li>尾节点 <strong>last</strong></li>
<li>容量 <strong>size</strong></li>
</ul>
<p>节点是一个双向节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入到头部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取头节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//新建一个节点，尾部指向之前的 头元素 first</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">//first 指向新建的节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">//如果之前是空链表，新建的节点 也是最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//原来的第一个节点（现在的第二个）头部指向新建的头结点</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入到尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取尾部节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//新建一个节点，头部指向之前的 尾节点 last</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//last 指向新建的节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果之前是空链表， 新建的节点也是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//原来的尾节点尾部指向新建的尾节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 指定节点 前插入一个元素，这里假设 指定节点不为 null</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取指定节点 succ 前面的一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">//新建一个节点，头部指向 succ 前面的节点，尾部指向 succ 节点，数据为 e</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">//让 succ 节点头部指向 新建的节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">//如果 succ 前面的节点为空，说明 succ 就是第一个节点，那现在新建的节点就变成第一个节点了</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果前面有节点，让前面的节点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除头节点并返回该节点上的数据，假设不为 null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取数据，一会儿返回</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">//获取头节点后面一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">//使头节点上数据为空，尾部指向空</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">//现在头节点后边的节点变成第一个了</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">//如果头节点后面的节点为 null，说明移除这个节点后，链表里没节点了</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除尾部节点并返回，假设不为空</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="comment">//获取倒数第二个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">//尾节点数据、尾指针置为空</span></span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">//现在倒数第二变成倒数第一了</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除某个指定节点</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设 x 不为空</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="comment">//获取指定节点前面、后面的节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果前面没有节点，说明 x 是第一个</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//前面有节点，让前面节点跨过 x 直接指向 x 后面的节点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果后面没有节点，说 x 是最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//后面有节点，让后面的节点指向 x 前面的</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定位置的节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设指定位置有元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分一下，如果小于 size 的一半，从头开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//大于 size 一半，从尾部倒着遍历</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><ul>
<li><strong>Vector</strong> 的实现也是数组，继承了<strong>AbstractList</strong>，实现了<strong>List</strong>，支持相关的添加、删除、修改、遍历等功能。</li>
<li><strong>Vector</strong> 实现了<strong>RandmoAccess</strong>接口，即<strong>提供了随机访问功能</strong>。我们即可以通过元素的序号快速获取元素对象；</li>
<li><strong>Vector</strong> 实现了<strong>Cloneable</strong>接口，即实现clone()函数。它能被克隆。</li>
<li>和<strong>ArrayList</strong>不同，<strong>Vector中的操作是线程安全的</strong>。</li>
<li>Vector 默认容量是 10，当Vector容量不足以容纳全部元素时，Vector的容量会增加。<strong>若容量增加系数 &gt;0，则将容量的值增加到 “容量增 + 系数”；否则，将容量大小增加一倍。</strong>（增加系数有构造器时指定）</li>
</ul>
<h5 id="Vector-源码分析"><a href="#Vector-源码分析" class="headerlink" title="Vector 源码分析"></a>Vector 源码分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 保存Vector中数据的数组</span></span><br><span class="line">    <span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际数据的数量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量增长系数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vector的序列版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2767605614048989439L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vector构造函数。默认容量是10。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定Vector容量大小的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定Vector"容量大小"和"增长系数"的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">// 新建一个数组，数组容量是initialCapacity</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="comment">// 设置容量增长系数</span></span><br><span class="line">        <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定集合的Vector构造函数。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取“集合(c)”的数组，并将其赋值给elementData</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">// 设置数组长度</span></span><br><span class="line">        elementCount = elementData.length;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, elementCount, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认“Vector容量”的帮助函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">// 当Vector的容量不足以容纳当前的全部元素，增加容量大小。</span></span><br><span class="line">        <span class="comment">// 若 容量增量系数&gt;0(即capacityIncrement&gt;0)，则将容量增大当capacityIncrement</span></span><br><span class="line">        <span class="comment">// 否则，将容量增大一倍。</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;</span><br><span class="line">            Object[] oldData = elementData;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = (capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                (oldCapacity + capacityIncrement) : (oldCapacity * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (newCapacity &lt; minCapacity) &#123;</span><br><span class="line">                newCapacity = minCapacity;</span><br><span class="line">            &#125;</span><br><span class="line">            elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定Vector的容量。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将Vector的改变统计数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置容量值为 newSize</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (newSize &gt; elementCount) &#123;</span><br><span class="line">            <span class="comment">// 若 "newSize 大于 Vector容量"，则调整Vector的大小。</span></span><br><span class="line">            ensureCapacityHelper(newSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若 "newSize 小于/等于 Vector容量"，则将newSize位置开始的元素都设置为null</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize ; i &lt; elementCount ; i++) &#123;</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elementCount = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><strong>Set</strong>继承于<strong>Collection</strong>接口，是一个不允许出现重复元素，并且无序的集合，主要有<strong>HashSet</strong>和<strong>TreeSet</strong>两大实现类。</p>
<p>在判断重复元素的时候，Set集合会调用<strong>hashCode</strong>()和<strong>equal</strong>()方法来实现。</p>
<h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><ul>
<li><strong>HashSet</strong>实现<strong>Set</strong>接口，底层由<strong>HashMap</strong>来实现，为哈希表结构；当有元素插入的时候，会计算元素的<strong>hashCode</strong>值，将元素插入到哈希表对应的位置中来；</li>
<li><strong>HashSet</strong>继承<strong>AbstractSet</strong>类，获得了Set接口大部分的实现，减少了实现此接口所需的工作，实际上是又继承了<strong>AbstractCollection</strong>类；</li>
<li><strong>HashSet</strong>实现<strong>Cloneable</strong>，得到了clone()方法，可以实现克隆功能；</li>
<li><strong>HashSet</strong>实现<strong>Serializable</strong>，表示可以被序列化，通过序列化去传输。</li>
<li>线程不安全。</li>
</ul>
<h5 id="HashSet-源码分析"><a href="#HashSet-源码分析" class="headerlink" title="HashSet 源码分析"></a>HashSet 源码分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment">     * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建指定容量的HashMap,传入集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建指定容量、指定负载因子的 HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建指定容量的 HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用map的 add 方法</span></span><br><span class="line"><span class="comment">     * 注意这里 元素为 HashMap 的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用map的remove 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a><strong>LinkedHashSet</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2851667679971038690L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.DISTINCT | Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="List和Set区别"><a href="#List和Set区别" class="headerlink" title="List和Set区别"></a>List和Set区别</h5><ul>
<li>有序性：<strong>List</strong> 有序；<strong>Set</strong>无序（元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）</li>
<li>唯一性：<strong>List</strong>可以重复；<strong>Set</strong>元素唯一，重复元素会覆盖掉</li>
<li>获取元素：<strong>List</strong>可以通过索引直接操作元素；<strong>Set</strong>不能</li>
<li>特点：<ul>
<li><strong>List</strong>：和数组类似，<strong>List</strong>可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</li>
<li><strong>Set</strong>：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li>
</ul>
</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><strong>Map</strong>用于保存具有映射关系的数据，<strong>Map</strong>里保存着两组数据：<strong>key</strong>和<strong>value</strong>，它们都可以使任何引用类型的数据，但key不能重复。所以通过指定的<strong>key</strong>就可以取出对应的<strong>value</strong>。区别于 <strong>Collection</strong> 的单列集合， <strong>Map</strong> 是双列集合。</p>
<p><strong>Map</strong> 的常用实现有：<strong>HashTable</strong>、<strong>HashMap</strong>（下面有<strong>LinkedHashMap</strong>）、<strong>TreeMap</strong>、<strong>IdentityHashMap</strong></p>
<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>HashMap</strong> 继承于<strong>AbstractMap</strong>，实现了<strong>Map</strong>接口，可以对它进行哈希表操作；</li>
<li>实现了<strong>Cloneable</strong>接口，能被克隆；</li>
<li>实现了<strong>Serializable</strong>接口，因此它支持序列化，能够通过序列化传输。</li>
<li><strong>HashMap</strong>是非线程安全的，只是用于单线程环境下，多线程环境下可以采用<strong>concurrent</strong>并发包下的<strong>concurrentHashMap</strong>。</li>
</ul>
<h5 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h5><p><strong>关键静态属性和成员变量：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap初始化容量的默认大小（16），必须是2的整数次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">// 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// HashMap初始化时的默认负载因子，基于准确率和资源浪费考虑，太小资源浪费，太大hash冲突几率大</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 将链表转为红黑树的阈值，当一个元素在被添加时，如果链表中的元素个数已经达到8个，则将链表转为红黑树形式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 将红黑树转为链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 链表被转化为红黑树时，哈希表最小的容量。为了避免冲突，该值至少为4 * TREEIFY_THRESHOLD</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储链表的数组，table在第一次使用时会进行初始化，如果有必要会有resize的操作</span></span><br><span class="line"><span class="comment">// table的大小总是2的整数次幂</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 保存entrySet()方法的缓存，要和AbstractMap的keySet()和values()区分，AbstractMap有自己的Set集合，来缓存这两个方法的返回值</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">// 键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// HsahMap结构的修改次数，用于fail-fast机制</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 下一次resize的阈值大小 = HashMap容量 * 负载因子</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//哈希表的负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p><strong>构造方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数指定了HashMap初始化时的容量以及负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数指定了HashMap初始化时的容量，负载因子使用默认负载因子0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 无参构造方法，默认的初始化容量为16，负载因子为默认的0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 根据其他Map来创建HashMap，负载因子为0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中需要注意构造器里的一个方法 ：<strong>tableSizeFor(initialCapacity)</strong> ,该方法的作用是，是返回<strong>大于输入参数且最近的2的整数次幂的数</strong>。比如输入10，则返回<strong>16</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">    * 补充知识点：</span></span><br><span class="line"><span class="comment">    * &gt;&gt;表示右移，如果该数为正，则高位补0，若为负数，则高位补1；</span></span><br><span class="line"><span class="comment">    * &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里就涉及到一个常见问题： “<strong>为什么HashMap长度是2的幂次？</strong>”</p>
<p>原因是在于减少<strong>hash</strong>冲突，提高<strong>HashMap</strong>的效率。我们都知道<strong>HashMap</strong> 在查找某个元素时，需要根据<strong>key</strong>的<strong>hash</strong>值来求得对应数组中的位置。如何 计算这个位置就是 <strong>hash算法</strong>。<strong>HashMap</strong>的数据结构是<strong>数组+链表+红黑树</strong>，我们希望元素是均匀分布在每个位置上，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 </p>
<p>所以我们首先想到的就是把<strong>hashcode</strong>对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，<strong>java</strong>中使用了一种更高效的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先算得key 的hashcode值，</span></span><br><span class="line"><span class="comment">// 然后和（数组长度-1）做一次 “&amp;”运算</span></span><br><span class="line"><span class="comment">// 我们期望 （数组长度-1）二进制 全为 11111...</span></span><br><span class="line"><span class="comment">// 因为 &amp; 运算中 1 和 0 结果为 0， 0 和 0 结果也为 0 </span></span><br><span class="line"><span class="comment">// 而 1 和 1 结果为 1， 0 和 1 结果为 0</span></span><br><span class="line"><span class="comment">// 所以 固定数的二进制 每一位都为 1 可以减少 相同结果，降低 hash碰撞，提升效率</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HashMap的几个关键方法：put方法、get方法和remove方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若key为null，则直接返回0，否则通过h = key.hashCode()计算出key的hashcode，然后返回h ^ (h &gt;&gt;&gt; 16)的值。h &gt;&gt;&gt; 16为无符号向右移动16位，移位之后，h的高16位全部变成了0,这样做的好处是，低位的信息中混入了高位的信息，这样高位的信息被变相的保留了下来.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onlyIfAbsent为true时，则不覆盖key对应的value值，但是put在调用这个方法时，赋值为false，说明会覆盖原始value</span></span><br><span class="line"><span class="comment">// evict为false时，table处于创建模式，put在调用这个方法时，赋值为true</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table为null或者table长度为0，则通过resize方法来初始化table，其中，n为数组的长度</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash是计算出的节点在数组中的下标，若数组对应下标为null，则直接将节点赋值到tab[i]</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 若数组对应下标不为null，则表明发生了哈希冲突，其中，p为table[i]中的第一个节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果p节点与插入节点的hash和key相同，则e = p</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 否则，判断p节点是否为TreeNode，即判断链表是否已经调整为红黑树，若是的话，则通过putTreeVal来添加红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 否则，p为链表节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 在链表尾节点处插入新节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表节点个数在插入新的节点后，达到转为红黑树的阈值，则需要将链表转为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果插入节点和原链表中的某个key具有相同的hash且key相同，则停止查找</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e != null表明哈希表中已经存在键为key的节点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 若允许覆盖value值，或旧值为null，则更新key所对应的值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// HashMap结构修改次数加1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 若节点个数 &gt; threshold，则对table进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码中我们可以看出，<strong>HashMap</strong>的<strong>key</strong>和<strong>value</strong>都可以为<strong>null</strong>，因为在计算节点哈希值时，若<strong>key</strong>为<strong>null</strong>，则哈希值返回<strong>0</strong>，而且，插入元素时，会判断<strong>key</strong>对应的<strong>value</strong>是否为<strong>null</strong>，所以，<strong>key</strong>和<strong>value</strong>都可以为<strong>null</strong>。</p>
<p><strong>HashMap</strong>的扩容是通过 <strong>resize()</strong> 方法来完成的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化table或对table进行扩容</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果table的原容量 &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果原容量 &gt;= MAXIMUM_CAPACITY，则将阈值threshold修改为Integer.MAX_VALUE，并返回原table</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算新容量newCap = 原容量 * 2</span></span><br><span class="line">        <span class="comment">// 若newCap &lt; MAXIMUM_CAPACITY且旧容量oldCap &gt;= DEFAULT_INITIAL_CAPACITY，则新的阈值newThr = 旧阈值 * 2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，table的原容量为0，如果原阈值 &gt; 0，则新容量newCap = oldThr</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 否则，新容量newCap = DEFAULT_INITIAL_CAPACITY（16）</span></span><br><span class="line">    <span class="comment">// 新阈值newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY)</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果新阈值newThr为0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算阈值ft，ft = (float)newCap * loadFactor</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">// 根据ft来计算新阈值newThr</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 更新阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 创建新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">//更新table为newTab</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 如果原table不为null，则需要将原table中的节点复制到新table中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历原table数组，j为下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 原table的j下标存有节点，e为头结点</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将原table[j]处置为null，释放空间</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果e没有后继节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 将e赋值给新table对应的首节点</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果e为红黑树节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 重构红黑树结构到新table中</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// e为链表节点</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 将同一链表中的元素根据(e.hash &amp; oldCap)是否为0进行分割，分成两个不同的链表，完成rehash</span></span><br><span class="line">                    <span class="comment">// 若(e.hash &amp; oldCap)为0，则该节点在新table中的下标不变</span></span><br><span class="line">                    <span class="comment">// 若(e.hash &amp; oldCap)不为0，则该节点在新table中的下标变为j + oldCap</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新table</span></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的源码可知，<strong>HashMap</strong> 触发扩容的条件是：</p>
<ul>
<li>数组长度大于阈（yu）值 （= 容量 * 负载因子，例如容量为16，负载因子为 .75f ,则 阈值为 12）；</li>
<li>且 发生 <strong>hash</strong> 碰撞 。</li>
</ul>
<p>扩容大小为 原容量 的 <strong>2 倍</strong>。</p>
<p><strong>HashMap</strong>的<strong>refresh</strong>：</p>
<p><img src="/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/java_language_05.png" alt="HashMap的refresh"></p>
<ul>
<li><strong>rehash</strong> 方法 将数组扩容后，会将原来的元素重新计算，放入新位置，判断依据为 <ul>
<li>// 将同一链表中的元素根据<strong>(e.hash &amp; oldCap)</strong>是否为<strong>0</strong>进行分割，分成两个不同的链表，完成<strong>rehash</strong></li>
<li>// 若<strong>(e.hash &amp; oldCap)</strong>为<strong>0</strong>，则该节点在新table中的下标不变</li>
<li>// 若<strong>(e.hash &amp; oldCap)</strong>不为<strong>0</strong>，则该节点在新table中的下标变为  <strong>j + oldCap</strong></li>
</ul>
</li>
<li>由此看来扩容是一个比较耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用<strong>HashMap</strong>的时，最好能提前预估下<strong>HashMap</strong>中元素的个数，这样有助于提高<strong>HashMap</strong>的性能。</li>
</ul>
<p><strong>get(Object key)方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(Object key)方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Node节点结构：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"> </span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">    <span class="comment">// 节点的哈希值等于key和value的哈希值求异或</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将链表转为红黑树之后，节点不再以<strong>Node</strong>方式存储，而被转化为了<strong>TreeNode</strong>节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="comment">// 左节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    <span class="comment">// 右节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    <span class="comment">// 删除节点时，需要断开链接，这个节点记录了删除节点的前一个节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 返回当前节点的树根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/java_language_04.png" alt="HashMap结构图"></p>
<h3 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h3><p><strong>异常</strong>指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。<strong>Java</strong>通 过API中<strong>Throwable</strong>类的众多子类描述各种不同的异常。因而，<strong>Java</strong>异常都是对象，是<strong>Throwable</strong>子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。</p>
<p><img src="/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/java_language_06.png" alt="异常类层次机构图"></p>
<p><strong>Throwable：</strong> 有两个重要的子类：<strong>Exception</strong>（异常）和 <strong>Error</strong>（错误）。</p>
<ul>
<li><strong>Error (错误)</strong>：是程序无法处理的错误，表示运行应用程序中较严重问题。<strong>大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题</strong>。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</li>
<li><strong>Exception (异常)</strong>： <strong>是程序本身可以处理的异常</strong>。<strong>Exception</strong> (异常) 按照性质又分为 <strong>编译异常</strong>（可检查）和<strong>运行时异常</strong>（不可检查）</li>
</ul>
<p><strong>编译时异常：</strong></p>
<p>又叫<strong>可检查异常</strong>，通常是由语法错误和环境因素（外部资源）造成的异常。比如输入输出异常<strong>IOException</strong>，数据库操作<strong>SQLException</strong>。其特点是，<strong>Java语言强制要求捕获和处理所有非运行时异常</strong>。通过行为规范，强化程序的健壮性和安全性。</p>
<p><strong>运行时异常：</strong></p>
<p>又叫<strong>不可检查异常</strong>(RuntimeException)，这些异常一般是由程序逻辑错误引起的，即语义错。比如算术异常，空指针异常<strong>NullPointerException</strong>，下标越界<strong>IndexOutOfBoundsException</strong>。运行时异常应该在程序测试期间被暴露出来，由程序员去调试，而避免捕获。</p>
<p><strong>异常处理程序机制：</strong></p>
<ul>
<li>抛出异常；</li>
<li>try-catch-finally 捕获和处理异常</li>
</ul>
<p><strong>如何选择异常？</strong></p>
<p>考虑这个异常出现之后是否调用者可以处理，并且你是否希望调用者进行处理，如果调用者可以处理，并且你也希望调用者进行处理，那么就要抛出<strong>受检异常</strong>，提醒调用者在使用你的方法时，考虑到如果抛出异常时如果进行处理，相似的，如果在写某个方法时，你认为这是个偶然异常，理论上说，你觉得运行时可能会碰到什么问题，而这些问题也许不是必然发生的，也不需要调用者显示的通过异常来判断业务流程操作的，那么这时就可以使用一个RuntimeException这样的<strong>非受检异常.</strong></p>
<p><strong>什么 时候抛异常？</strong></p>
<p>如果你觉得某些”问题”解决不了了，那么你就可以抛出异常了。比如，你在写一个service,其中在写到某段代码处,你发现可能会产生问题，那么就需要抛出异常。或者说该问题程序无法处理，需要告知用户处理，例如：文件不存在等。</p>
<p><strong>常见问题：</strong></p>
<p><strong>finally</strong>关键字中出现<strong>return</strong>等关键字导致的程序执行顺序问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">//出现异常</span></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;<span class="keyword">catch</span>(..)&#123;</span><br><span class="line">  a=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  a=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序返回：2</span></span><br><span class="line"><span class="comment">// 因为 finally语句块是最后执行</span></span><br></pre></td></tr></table></figure>

<h3 id="注解机制"><a href="#注解机制" class="headerlink" title="注解机制"></a>注解机制</h3><p><strong>Java</strong>注解是JDK1.5引入的一种注释机制，java语言的类、方法、变量、参数和包都可以被注解标注。和Javadoc不同，java注解可以通过反射获取标注内容。</p>
<p>在编译器生成<strong>.class</strong>文件时，注解可以被嵌入字节码中，而jvm也可以保留注解的内容，在运行时获取注解标注的内容信息。</p>
<p>完整的注解（从编写到最终运行）需要三方面的参与。</p>
<ul>
<li>需要定义一个注解。</li>
<li>需要一个被贴的程序元素（类，方法，字段，构造器等）</li>
<li>第三方程序的支持（赋予我注解的特殊功能）</li>
</ul>
<h4 id="JDK内置注解"><a href="#JDK内置注解" class="headerlink" title="JDK内置注解"></a>JDK内置注解</h4><table>
<thead>
<tr>
<th>注解名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>@Override</td>
<td>检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</td>
</tr>
<tr>
<td>@Deprecated</td>
<td>标记过时方法。如果使用该方法，会报编译警告。</td>
</tr>
<tr>
<td>@SuppressWarnings</td>
<td>指示编译器去忽略注释解中声明的警告。</td>
</tr>
<tr>
<td>@FunctionalInterface</td>
<td>java8支持，标识一个匿名函数或函数式接口。</td>
</tr>
</tbody></table>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>是指 <strong>注解的注解</strong>，可以在注解接口中使用的注解。</p>
<p>常见元注解：</p>
<ul>
<li><p><strong>@Target</strong> 表示该注解用于什么地方，可能的值在枚举类 <strong>ElemenetType</strong> 中，包括：</p>
<p> ElemenetType.<strong>CONSTRUCTOR</strong>—————————–构造器声明<br> ElemenetType.<strong>FIELD</strong> ———————————-域声明（包括 enum 实例）<br> ElemenetType.<strong>LOCAL_VARIABLE</strong>————————- 局部变量声明<br> ElemenetType.<strong>METHOD</strong> ———————————方法声明<br> ElemenetType.<strong>PACKAGE</strong> ——————————–包声明<br> ElemenetType.<strong>PARAMETER</strong> ——————————参数声明<br> ElemenetType.<strong>TYPE</strong>———————————– 类，接口（包括注解类型）或<strong>enum</strong>声明 </p>
</li>
<li><p><strong>@Retention</strong> 表示在什么级别保存该注解信息。可选的参数值在枚举类型 <strong>RetentionPolicy</strong> 中，包括：</p>
<p> RetentionPolicy.<strong>SOURCE</strong>————-注解将被编译器丢弃<br> RetentionPolicy.<strong>CLASS</strong> ————-注解在class文件中可用，但会被VM丢弃<br> RetentionPolicy.<strong>RUNTIME</strong> ———VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。</p>
</li>
<li><p><strong>@Documented</strong> 将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。相当与@see,@param 等。</p>
</li>
<li><p><strong>@Inherited</strong> 允许子类继承父类中的注解。</p>
</li>
<li><p>*<em>@Repeatable *</em>标识某注解可以在同一个声明上使用多次</p>
</li>
</ul>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>第一步：创建注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如创建属性注解</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestFieldAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：使用注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性上添加注解</span></span><br><span class="line">    <span class="meta">@TestFieldAnnotation</span>(description = <span class="string">"这是一个名字字段"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestFieldAnnotation</span>(description = <span class="string">"这是一个年龄字段"</span>)</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：解析（常与AOP一起用，这里简单案例）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取全部属性</span></span><br><span class="line">        Field[] fields = UserDTO<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredFields</span>()</span>;</span><br><span class="line">        <span class="comment">// 遍历属性</span></span><br><span class="line">        Stream.of(fields).forEach(field -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断属性上是否有该注解</span></span><br><span class="line">            <span class="keyword">boolean</span> annotationPresent = </span><br><span class="line">                    field.isAnnotationPresent(TestFieldAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (annotationPresent) &#123;</span><br><span class="line">                TestFieldAnnotation annotation = </span><br><span class="line">                        field.getAnnotation(TestFieldAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="comment">// 打印注解description</span></span><br><span class="line">                System.out.println(annotation.description());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="版本差异与新特性"><a href="#版本差异与新特性" class="headerlink" title="版本差异与新特性"></a>版本差异与新特性</h3><p><img src="/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/java_language_03.png" alt="版本差异"></p>
<p>其中<strong>Java</strong> 的 <strong>1.8</strong> 和  <strong>1.11</strong> 版本为长期支持版本，重点关注其新特性。</p>
<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p><strong>关于函数式接口</strong></p>
<ol>
<li>如果一个接口只有一个抽象方法，那么这个接口就是函数式接口。（<strong>Java8</strong>开始接口可以存在接口方法的实现，即为默认方法）</li>
<li>如果一个接口上声明了@<strong>FunctionInterface</strong>，那么编译器就会按照函数式接口定义要求该接口；</li>
<li>如果一个接口只有一个抽象方法，但是没有声明@<strong>FunctionInterface</strong>,编译器仍然会将之看作为函数式接口；</li>
<li>函数式接口的实例可以用<strong>Lambda</strong>表达式，方法引用或构造方法创建。</li>
</ol>
<p>为什么设计函数式接口？</p>
<p>​        配合<strong>Lambda</strong>表达式，使得<strong>Java8</strong>中能够传递方法过程，即 <strong>函数式编程</strong>。</p>
<p>​        在函数式编程语言中，<strong>Lambda</strong>表达式的类型是函数，但是在Java中，<strong>Lambda</strong>表达式实际上是对象，它们必须依附于一类特别的对象类型：函数式接口。</p>
<p>Java内置四大常用核心函数式接口（java.util.function）</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
<th>Stream方法</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer<T>消费型</T></td>
<td>T</td>
<td>Void</td>
<td>对参数进行操作，void accept(T t)</td>
<td>forEach</td>
</tr>
<tr>
<td>Supplier<T>供给型</T></td>
<td>无</td>
<td>T</td>
<td>返回类型为T的对象，T get()</td>
<td>orElse</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;函数型</td>
<td>T</td>
<td>R</td>
<td>对T类型参数操作返回R类型结果</td>
<td>map</td>
</tr>
<tr>
<td>Predicate<T>判定型</T></td>
<td>T</td>
<td>boolean</td>
<td>判断T类型参数是否满足某一约束</td>
<td>filter</td>
</tr>
</tbody></table>
<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p><strong>Java Lambda</strong>表达式<em>的一个重要用法是简化某些</em>匿名内部类<strong>（<code>Anonymous Classes</code>）</strong>的写法。</p>
<p><strong>无参函数：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK7 匿名内部类写法</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;<span class="comment">// 接口名</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;<span class="comment">// 方法名</span></span><br><span class="line">		System.out.println(<span class="string">"Thread run()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK8 Lambda表达式写法</span></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">		() -&gt; System.out.println(<span class="string">"Thread run()"</span>)<span class="comment">// 省略接口名和方法名</span></span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<p><strong>带参函数：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK7 匿名内部类写法</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;<span class="comment">// 接口名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span></span>&#123;<span class="comment">// 方法名</span></span><br><span class="line">        <span class="keyword">if</span>(s1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK8 Lambda表达式写法</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">Collections.sort(list, (s1, s2) -&gt;&#123;<span class="comment">// 省略参数表的类型</span></span><br><span class="line">    <span class="keyword">if</span>(s1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码跟匿名内部类的作用是一样的。除了省略了接口名和方法名，代码中把参数表的类型也省略了。这得益于<code>javac</code>的<strong>类型推断</strong>机制，编译器能够根据上下文信息推断出参数的类型，当然也有推断失败的时候，这时就需要手动指明参数类型了。</p>
<p>也许你已经想到了，<strong>能够使用Lambda的依据是必须有相应的函数接口</strong>（<strong>函数接口，</strong>是指内部只有一个抽象方法的接口）。这一点跟<strong>Java</strong>是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写<strong>Lambda</strong>表达式。实际上<strong>Lambda</strong>的类型就是对应函数接口的类型。<strong>Lambda表达式另一个依据是类型推断机制</strong>，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。Lambda表达更多合法的书写形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lambda表达式的书写形式</span></span><br><span class="line">Runnable run = () -&gt; System.out.println(<span class="string">"Hello World"</span>);<span class="comment">// 1</span></span><br><span class="line">ActionListener listener = event -&gt; System.out.println(<span class="string">"button clicked"</span>);<span class="comment">// 2</span></span><br><span class="line">Runnable multiLine = () -&gt; &#123;<span class="comment">// 3 代码块</span></span><br><span class="line">    System.out.print(<span class="string">"Hello"</span>);</span><br><span class="line">    System.out.println(<span class="string">" Hoolee"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">BinaryOperator&lt;Long&gt; add = (Long x, Long y) -&gt; x + y;<span class="comment">// 4</span></span><br><span class="line">BinaryOperator&lt;Long&gt; addImplicit = (x, y) -&gt; x + y;<span class="comment">// 5 类型推断</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义函数式接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义函数接口，</span></span><br><span class="line"><span class="comment">// 注解可选，但加上该标注编译器会帮你检查接口是否符合函数接口规范</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerInterface</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">ConsumerInterface&lt;String&gt; consumer = str -&gt; System.out.println(str);</span><br></pre></td></tr></table></figure>

<p><strong>集合中Lambda的使用：</strong></p>
<p>为引入<strong>Lambda</strong>表达式，<strong>Java8</strong>新增了<code>java.util.funcion</code>包，里面包含常用的<strong>函数接口</strong>，这是<strong>Lambda</strong>表达式的基础，<strong>Java</strong>集合框架也新增部分接口，以便与<strong>Lambda</strong>表达式对接。</p>
<table>
<thead>
<tr>
<th align="left">接口名</th>
<th align="left">Java8新加入的方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Collection</td>
<td align="left">removeIf() spliterator() stream() parallelStream() forEach()</td>
</tr>
<tr>
<td align="left">List</td>
<td align="left">replaceAll() sort()</td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge()</td>
</tr>
</tbody></table>
<p><strong>举例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.forEach( str -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用removeIf()结合Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.removeIf(str -&gt; str.length()&gt;<span class="number">3</span>); <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.replaceAll(str -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// List.sort()方法结合Lambda表达式</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.sort((str1, str2) -&gt; str1.length()-str2.length());</span><br></pre></td></tr></table></figure>

<h4 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h4><p><strong>Stream</strong> 是<strong>Java8</strong>中处理集合的关键抽象概念，它可以对集合进行非常复杂的<strong>查找、过滤、筛选</strong>等操作。</p>
<p>使用 <strong>Stream API</strong>对集合数据进行操作就类似于使用<strong>SQL</strong>进行数据库查询；</p>
<p>简而言之，<strong>Stream API</strong> 提供了一种高效且易于使用的数据处理方式。</p>
<p><strong>概念</strong></p>
<p>*<em>流 *</em>是数据渠道，用于操作数据源（集合，数组等）所生成的元素序列。</p>
<p>集合讲的是<strong>数据</strong>，流讲的是<strong>计算</strong>。</p>
<ul>
<li>*<em>Stream *</em>自己不会存储元素，需要通过数据源来构造</li>
<li>*<em>Stream *</em>的操作时延迟执行的，等到需要结果的时候才执行，即在存在终止操作时才会真正执行。</li>
</ul>
<p><strong>并行流（parallelStream） *<em>与 *</em>串行流（默认生成的Stream）</strong></p>
<p>*<em>并行流 *</em>就是把一个内容分成多个数据块，并用不同线程分别处理每个数据块的流，因此可以对数据进行多线程并行操作。</p>
<p>*<em>Stream *</em>的使用步骤：</p>
<ol>
<li><p><strong>源操作</strong>（创建<strong>Stream</strong>）：从一个数据源获得流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream();</span><br><span class="line">Stream.of(array);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>中间操作</strong>：一个中间操作链条，对数据源进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter(),map(),distinct()等</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>终止操作</strong>：执行中间操作链，产生一个结果。</p>
<p>注意：一个流经过终止操作后，不能再次进行其他任何操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">count(),findAny(),collect()等</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="常见源操作"><a href="#常见源操作" class="headerlink" title="常见源操作"></a><strong>常见源操作</strong></h5><ul>
<li><p><strong>Collection</strong>接口 被扩展，提供了俩个获取流的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个顺序流</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回一个并行流</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> ParallelStream&lt;E&gt; <span class="title">stream</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">list.stream();</span><br></pre></td></tr></table></figure>
</li>
<li><p>由数组创建流：<strong>Arrays</strong> 的静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态方法返回一个流</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Arrays.stream(arr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>由值创建流：使用 <strong>Stream</strong>的静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Stream.of(list);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="常见中间操作"><a href="#常见中间操作" class="headerlink" title="常见中间操作"></a>常见中间操作</h5><p><strong>Stream</strong> 的多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会进行任何处理，而是在终止操作时一次性全部处理，称为 “<strong>惰性求值</strong>“。</p>
<ul>
<li><p>筛选与切片</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter(Predicate p);<span class="comment">// 从流中排除某些元素</span></span><br><span class="line">distinct();<span class="comment">// 筛选，通过流中的元素 hashCode\equals方法去重</span></span><br><span class="line">limit(Long maxSize);<span class="comment">// 截断流，使其元素数量不超过 maxSize</span></span><br><span class="line">skip(<span class="keyword">long</span> n);<span class="comment">// 跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，返回一个空流，与limit(n)互补</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>映射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map(Function f); <span class="comment">// 通过f方法作用于流中的每个元素，获得队形的f方法的执行结果组成一个新的流</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sorted();<span class="comment">// 将流中的元素进行自然排序，产生一个新的流</span></span><br><span class="line">sorted(Comparator comp);<span class="comment">// 使用比较器进行排序产生一个新的流</span></span><br><span class="line"><span class="comment">// 默认升序排序，降序用reversed()</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="常见终止操作"><a href="#常见终止操作" class="headerlink" title="常见终止操作"></a>常见终止操作</h5><p><strong>Stream</strong> 的终止操作会将流生成一个结果，结果可以是任何不为流 的值，如<strong>List,Integer,void</strong> 等。</p>
<ul>
<li><p>匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查流中的元素是否全部匹配p的约束</span></span><br><span class="line"><span class="function">Boolean <span class="title">allMatch</span><span class="params">(Predicte p)</span></span>;</span><br><span class="line"><span class="comment">// 至少一个元素匹配</span></span><br><span class="line"><span class="function">Boolean <span class="title">anyMatch</span><span class="params">(Predicte p)</span></span>;</span><br><span class="line"><span class="comment">// 均不匹配</span></span><br><span class="line"><span class="function">Boolean <span class="title">noneMatch</span><span class="params">(Predicte p)</span></span>;</span><br><span class="line"><span class="comment">// 返回流中的第一个元素</span></span><br><span class="line"><span class="function">Optional <span class="title">findFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回流中的任意一个元素</span></span><br><span class="line"><span class="function">Optional <span class="title">fundAny</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回流中元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 流中的元素经过比较器排序后，返回流中的最大值的元素</span></span><br><span class="line">max(Comparator comp);</span><br><span class="line"><span class="comment">// 流中的元素经过比较器排序后，返回流中的最小值的元素</span></span><br><span class="line">min(Comparator comp);</span><br><span class="line"><span class="comment">// 遍历操作</span></span><br><span class="line">forEach();</span><br></pre></td></tr></table></figure>
</li>
<li><p>归约</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reduce(T t,BinaryOperator b);<span class="comment">// 将流中元素反复结合起来得到一个值</span></span><br><span class="line">reduce(BinaryOperator b);<span class="comment">// 得到一个Optional的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>收集：<strong>Collection(Collector c)</strong>:将流转换成为其他形式。接受一个<strong>Collector</strong>接口的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collector 接口的实现方法决定了如何对流进行收集操作，Collectors(java.util.stream.Collectors)工具类提供了很多静态方法，方便创建收集器示例</span></span><br><span class="line"></span><br><span class="line">toList()/toSet(); <span class="comment">// 将流中元素收集到list，默认是ArrayList/HashSet</span></span><br><span class="line">toCollection(()-&gt;<span class="keyword">new</span> LinkedList); <span class="comment">// 将流中元素收集到LinkedList</span></span><br><span class="line">joining(); <span class="comment">// 连接流中的每个字符串</span></span><br><span class="line">groupingBy(); <span class="comment">// 根据某一属性值对流中的元素进行分组，属性值为k，元素为v</span></span><br><span class="line">collectingAndThen(); <span class="comment">// 包裹另一个收集器，对其这个收集器的结果在进行一次收集转换</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><p>从 <strong>Java 8</strong> 引入的一个很有趣的特性是 <strong><em>Optional</em></strong>  类。<strong>Optional</strong> 类主要解决的问题是臭名昭著的空指针异常（<strong>NullPointerException</strong>）    </p>
<p><strong>创建 Optional 实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Optional.empty() 创建一个空的 Optional 实例</span></span><br><span class="line">Optional&lt;User&gt; emptyOpt = Optional.empty();</span><br><span class="line">emptyOpt.get(); <span class="comment">// 也会抛出 NPE 异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用of() 和 ofNullable() 创建包含值的 Optional</span></span><br><span class="line">Optional&lt;User&gt; opt = Optional.of(user); <span class="comment">// 如果user 为null，会抛出NPE</span></span><br><span class="line">Optional&lt;User&gt; opt = Optional.ofNullable(user); <span class="comment">// 与of() 不同，允许user 为null</span></span><br><span class="line">Assert.isTrue(opt.isPresent(),<span class="string">"对象不可为空"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>访问 Optional 实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用orElse() 与 orElseGet()区别：如果对象非空, orElse() 方法仍然创建了 User 对象。与之相反，orElseGet() 方法不创建 User 对象。</span></span><br><span class="line">User user = <span class="keyword">null</span>;</span><br><span class="line">User result = Optional.ofNullable(user).orElse(() -&gt; <span class="keyword">new</span> User());</span><br><span class="line">User result2 = Optional.ofNullable(user).orElseGet(() -&gt; <span class="keyword">new</span> User());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用orElseThrow()</span></span><br><span class="line">User result = Optional.ofNullable(user)</span><br><span class="line">      .orElseThrow( () -&gt; <span class="keyword">new</span> IllegalArgumentException());</span><br></pre></td></tr></table></figure>

<p><strong>值转换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用map() 值转换</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"test@gmail.com"</span>, <span class="string">"1234"</span>);</span><br><span class="line">String email = Optional.ofNullable(user)</span><br><span class="line">    .map(u -&gt; u.getEmail()).orElse(<span class="string">"default@gmail.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用filter() 值过滤</span></span><br><span class="line">Optional&lt;User&gt; result = Optional.ofNullable(user)</span><br><span class="line">      .filter(u -&gt; u.getEmail() != <span class="keyword">null</span> &amp;&amp; u.getEmail().contains(<span class="string">"@"</span>));</span><br></pre></td></tr></table></figure>

<p><strong>Java 9 增强</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java 9 为 Optional 类添加了三个方法：or()、ifPresentOrElse() 和 stream()。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or() 的返回值是由 Supplier 参数产生的另一个 Optional 对象。如果对象包含值，则 Lambda 表达式不会执行。</span></span><br><span class="line">User result = Optional.ofNullable(user)</span><br><span class="line">      .or( () -&gt; Optional.of(<span class="keyword">new</span> User(<span class="string">"default"</span>,<span class="string">"1234"</span>))).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ifPresentOrElse()</span></span><br><span class="line">Optional.ofNullable(user).ifPresentOrElse( u -&gt; logger.info(<span class="string">"User is:"</span> + u.getEmail()),</span><br><span class="line">  () -&gt; logger.info(<span class="string">"User not found"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过把实例转换为 Stream 对象，让你从强大的 Stream API 中受益。</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"john@gmail.com"</span>, <span class="string">"1234"</span>);</span><br><span class="line">List&lt;String&gt; emails = Optional.ofNullable(user)</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(u -&gt; u.getEmail() != <span class="keyword">null</span> &amp;&amp; u.getEmail().contains(<span class="string">"@"</span>))</span><br><span class="line">    .map( u -&gt; u.getEmail())</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Java语言特性，面试复习</tag>
      </tags>
  </entry>
</search>
