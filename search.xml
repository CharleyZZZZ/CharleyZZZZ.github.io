<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo + Github搭建免费个人博客</title>
    <url>/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Hexo-Github搭建免费个人博客"><a href="#Hexo-Github搭建免费个人博客" class="headerlink" title="Hexo + Github搭建免费个人博客"></a>Hexo + Github搭建免费个人博客</h1><h2 id="什么是-Hexo"><a href="#什么是-Hexo" class="headerlink" title="什么是 Hexo"></a>什么是 Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><blockquote>
<ul>
<li>注册Github账号，熟悉github基本使用</li>
<li>安装nodejs、npm，了解相关使用</li>
<li>安装git客户端</li>
</ul>
</blockquote>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1. 创建仓库"></a>1. 创建仓库</h3><blockquote>
<ul>
<li>github新建仓库：仓库名必须是 <strong>username.github.io</strong> 格式，其中 <strong>username</strong> 是你的github用户名</li>
<li>完成后 <strong><em><a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a></em></strong> 即为博客网站地址，github提供页面访问（Hexo会在项目路径生成index.html）</li>
</ul>
</blockquote>
<h3 id="2-设置SSHKey（已经设置的可跳过本步骤）"><a href="#2-设置SSHKey（已经设置的可跳过本步骤）" class="headerlink" title="2. 设置SSHKey（已经设置的可跳过本步骤）"></a>2. 设置SSHKey（已经设置的可跳过本步骤）</h3><h4 id="1）生成SSHKey"><a href="#1）生成SSHKey" class="headerlink" title="1）生成SSHKey"></a>1）生成SSHKey</h4><pre><code>ssh-keygen -t rsa -C &quot;邮件地址&quot; -f ~/.ssh/秘钥名称（rsa_example）</code></pre><blockquote>
<ul>
<li>-C 指定邮件地址</li>
<li>-f 指定秘钥名称，因为一台机器可能存有多个git仓库的秘钥（例如github和公司gitlab），区别名称可在 <strong>config</strong> 文件中设置特定的仓库地址使用指定的秘钥</li>
</ul>
</blockquote>
<h4 id="2）将公钥复制到github上"><a href="#2）将公钥复制到github上" class="headerlink" title="2）将公钥复制到github上"></a>2）将公钥复制到github上</h4><p>​    打开github设置，进入 <strong>SSH and GPG keys</strong>,点击  <strong>New SSH key</strong>  复制 <code>rsa_example.pub</code>  里的公钥，保存</p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_01.png" alt="copy_sshKey_to_github"></p>
<h4 id="3）编辑-ssh-config-文件"><a href="#3）编辑-ssh-config-文件" class="headerlink" title="3）编辑  ~/.ssh/config 文件"></a>3）编辑  ~/.ssh/config 文件</h4><p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_02.png" alt="edit_ssh_config"></p>
<ul>
<li>​    <strong>Hostname</strong>   : 仓库地址</li>
<li>​    <strong>Port</strong>：端口</li>
<li>​    <strong>IdentityFile</strong>： 密钥文件</li>
<li>​    <strong>User</strong>： 邮箱地址</li>
</ul>
<h4 id="4）测试连接"><a href="#4）测试连接" class="headerlink" title="4）测试连接"></a>4）测试连接</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hi xxx! You've successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<p>说明已经配置成功，可以新建个文件夹推点东西测试下了</p>
<h3 id="3-hexo安装"><a href="#3-hexo安装" class="headerlink" title="3. hexo安装"></a>3. hexo安装</h3><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p>
<p>官网： <a href="http://hexo.io/" target="_blank" rel="noopener">http://hexo.io</a></p>
<p>github: <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a></p>
<ol>
<li><p>打开命令行（Windows建议使用git bash）全局安装hexo</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个hexo安装目录，f:/hexo ,并切换到该目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化hexo，自动下载一些文件到该目录，包括node_modules</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g #生成相关文件</span><br><span class="line">hexo s #启动本地预览，默认访问地址http://localhost:4000</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一次初始化，hexo会生成示例 Hello World，使用默认主题，可通过配置文件更改主题。</p>
</li>
</ol>
<h3 id="4-更改主题"><a href="#4-更改主题" class="headerlink" title="4. 更改主题"></a>4. 更改主题</h3><p>官网主题地址：<strong><em><a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></em></strong></p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_03.png" alt="hexo_themes"></p>
<ul>
<li><p>选择一款自己喜欢的主题进入主题，去github上复制地址</p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_04.png" alt="get_theme_code"></p>
</li>
</ul>
<ul>
<li><p>然后进入<strong>hexo/theme</strong> 目录下，打开 <code>git bash</code> 输入<code>git clone</code> 地址 拉取主题，或者 在 <strong>github</strong> 上直接下载项目，然后复制到 <strong>theme</strong> 文件夹下</p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_05.png" alt="pull_theme_code"></p>
</li>
</ul>
<ul>
<li><p>修改hexo主题配置: 修改hexo配置文件 <code>hexo/_config.yml</code></p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_06.png" alt="theme_setting"></p>
</li>
</ul>
<ul>
<li><p>重新生成，本地预览在<code>hexo/</code>目录打开<code>git bash</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g #打包</span><br><span class="line">hexo s #本地启动</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="5-查看效果"><a href="#5-查看效果" class="headerlink" title="5. 查看效果"></a>5. 查看效果</h3><p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_07.png" alt></p>
<h2 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h2><p><strong>安装部署插件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure>



<p><strong>配置 <code>_config.yml</code> 中关于 <code>deploy</code> 的部分</strong></p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_08.png" alt></p>
<p>其中涂鸦部分是你的 github 用户名</p>
<p><code>repository: git@github.com:username/username.github.io.git</code></p>
<p><strong>部署到github</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_09.png" alt></p>
<p><strong>访问Github Page: <a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a></strong></p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_10.png" alt></p>
<h2 id="Hexo-补充"><a href="#Hexo-补充" class="headerlink" title="Hexo 补充"></a>Hexo 补充</h2><ul>
<li><p>常用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new “postName” #新建文章</span><br><span class="line">hexo new page “pageName” #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help # 查看帮助hexo version #查看Hexo的版本</span><br><span class="line">以上均可简写 例：hexo deploy可写成 hexo d</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>tags 使用</p>
<p>在<code>hexo</code>主目录，使用 <code>hexo n &quot;new-blog&quot;</code> 创建名为 <code>new-blog</code> 的博客。</p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_11.png" alt="img"></p>
<p>会在 hexo/source/_posts文件夹下生成 相应 md文件，md文件自带title信息</p>
<p>使用md编辑器打开如下：</p>
<ul>
<li>title：博客标题</li>
</ul>
</li>
<li><p>date：生成日期</p>
<ul>
<li>tags：标签，多标签格式：[tag,tag，…]</li>
</ul>
</li>
</ul>
<ul>
<li><p>hexo图片引入</p>
<p>编写博文时想要插入图片怎么办，由于最终要在<code>Github Page</code>上显示，所以图片也要上传至<code>github</code>上去，md博文中引入，这里使用<code>hexo</code>的一个插件</p>
<p><strong>安装插件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image –save</span><br></pre></td></tr></table></figure>

<p><strong>更改配置文件_config.yml</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder</span>:<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p><strong>这时运行 <code>hexo n &quot;second-blog&quot;</code>创建新博文时，就会在相同目录下创建一个 同名文件夹<code>second-blog/</code>，将图片资源放入该文件夹下，就可以在博文中引用了</strong></p>
<p><img src="/2020/04/26/Hexo-Github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo_blog_12.png" alt></p>
</li>
</ul>
<p><strong>如果你觉得写的还不错，请给我个 star 吧：<a href="https://github.com/CharleyZZZZ/CharleyZZZZ.github.io" target="_blank" rel="noopener">https://github.com/CharleyZZZZ/CharleyZZZZ.github.io</a></strong></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>[游玩] 五一崇明之行</title>
    <url>/2020/05/07/%E6%B8%B8%E7%8E%A9-%E4%BA%94%E4%B8%80%E5%B4%87%E6%98%8E%E4%B9%8B%E8%A1%8C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>[SpringBoot] SpringBoot学习之自动配置原理</title>
    <url>/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h3><p>SpringBoot给我们开发项目带来了很多方便，其中很大归功于其自动配置功能，但是一直以来我对其实现原理没有仔细探究，这里我们将通过查看源码的方式理解SpringBoot自动配置原理，以及如何优雅的实现自动配置。</p>
<h3 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h3><p>​    <strong>SpringBoot</strong> 项目在启动时会便会自动配置项目的配置项以及加载依赖项目的配置项，其入口在注解<strong>@SpringBootApplication</strong>中的 <strong>@EnabledAutoConfiguration</strong> 注解中</p>
<p>而具体获取需要自动配置的配置类则在 *<em>AutoConfigurationImportSelector *</em>类获取中：</p>
<p><img src="/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/autoconfig_01.png" alt></p>
<p>观察 <strong>AutoConfigurationImportSelector</strong>类的<strong>selectImports</strong> 方法可知：</p>
<p>获取<strong>autoconfigures</strong> 的方式是从 <strong>META-INF/spring.factories</strong> 文件中获取键值为 <strong>EnableAutoConfiguration</strong>类名的自动配置类列表：</p>
<p><img src="/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/autoconfig_02.png" alt></p>
<p><img src="/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/autoconfig_03.png" alt></p>
<p><strong>META-INF/spring.factories:</strong></p>
<p><img src="/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/autoconfig_04.png" alt></p>
<p>任意点开一个自动配置类：</p>
<p>  可以看出来虽然获取到各个模块的自动配置类，但真正是否配置还需取决于注解 <strong>@ConditionalOnXXXX</strong></p>
<p>该类注解判断在配置文件中项目是否开启该功能，或者是否存在某些类（即引入该依赖）才决定自动配置属性或者自动注入相关对象。</p>
<p><strong>@ConditionalOnXXXX</strong> 常用注解如下：</p>
<ul>
<li>@ConditionalOnBean（仅仅在当前上下文中存在某个对象时，才会实例化一个Bean）</li>
<li>@ConditionalOnClass（某个class位于类路径上，才会实例化一个Bean）</li>
<li>@ConditionalOnExpression（当表达式为true的时候，才会实例化一个Bean</li>
<li>@ConditionalOnMissingBean（仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean</li>
<li>@ConditionalOnMissingClass（某个class类路径上不存在的时候，才会实例化一个Bean</li>
<li>@ConditionalOnNotWebApplication（不是web应用)</li>
<li>@ConditionalOnProperty （控制某个configuration是否生效。具体操作是通过其两个属性name以及havingValue来实现的，其中name用来从application.properties中读取某个属性值，如果该值为空，则返回false;如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。如果返回值为false，则该configuration不生效；为true则生效）</li>
</ul>
<p><img src="/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/autoconfig_05.png" alt></p>
<p>综上可知，<strong>SpringBoot</strong>在项目启动时，通过注解 <strong>@EnabledAutoConfiguration</strong> 从 <strong>META-INF/spring.factories</strong> 中获取需要配置的配置类，这些配置类都是各个常用模块的自动配置，例如<strong>jdbc</strong>，<strong>aop</strong>，<strong>redis</strong>，<strong>amqp</strong>等，而配置类中通过<strong>@ConditionalOnXXXX</strong>注解判断项目是否引入或者开启该功能，如果确认项目引入或开启了该功能则自动配置相关项到上下文中。而不需要人工再配置，大大节省了工作量。</p>
<h3 id="自定义starter自动配置"><a href="#自定义starter自动配置" class="headerlink" title="自定义starter自动配置"></a>自定义starter自动配置</h3><h4 id="META-INF-spring-factories配置"><a href="#META-INF-spring-factories配置" class="headerlink" title="META-INF/spring.factories配置"></a>META-INF/spring.factories配置</h4><p>如果我们要引入自定义starter ，该如何使其自动配置呢。</p>
<p>思路很简单：</p>
<p>​    在自定义<strong>starter</strong>中添加<strong>AutoConfiguration</strong>配置类，将该<strong>starter</strong>需要的相关配置放在里面，然后再resources目录下新建 <strong>META-INF/spring.factories</strong>文件，仿照<strong>spring-boot-autoconfiguration</strong> 项目将我们的自动配置类配置进去，然后在主项目中引入就可以实现自动配置了，</p>
<p>当然我们也可以给该自定义功能添加开关，例如添加配置 <strong>xxxx.enabled = true</strong> 开启</p>
<p>在 <strong>AutoConfiguration</strong> 配置类上添加注解 <strong>@ConditionalOnProperty</strong> 控制当<strong>xxxx.enabled = true</strong> 时才自动配置</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.autoconfiguration.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.autoconfiguration.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> demo自动配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/5/8 15:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(</span><br><span class="line">        prefix = <span class="string">"demo.admin"</span>,</span><br><span class="line">        value = &#123;<span class="string">"enabled"</span>&#125;,</span><br><span class="line">        havingValue = <span class="string">"true"</span>,</span><br><span class="line">        matchIfMissing = <span class="keyword">false</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动注入Bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">userDetails</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDetails(<span class="string">"张三"</span>, <span class="number">21</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.autoconfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 用户动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/5/8 15:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISpeak</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给用户一个说的动作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.autoconfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/5/8 15:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetails</span> <span class="keyword">implements</span> <span class="title">ISpeak</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDetails</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello，我叫"</span> + <span class="keyword">this</span>.name + <span class="string">", 我今年"</span> + <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在resources下新建 目录 META-INF目录：</p>
<p>分别添加如下文件：配置数据元数据配置，当输入该属性时会有自动提示</p>
<p><strong>spring-configuration-metadata.json</strong>  ：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"demo.admin.enabled"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"java.lang.Boolean"</span>,</span><br><span class="line">      <span class="attr">"defaultValue"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>spring.factories</strong> :</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">com.demo.autoconfiguration.config.DemoAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<p><strong>pom.xml</strong> :</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>autoconfiguration<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>autoconfiguration<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;optional&gt;true&lt;/optional&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而在主项目中只需要引入该依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>autoconfiguration<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.properties 中开启功能：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">demo.admin.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>启动项目，Controller中测试，Postman模拟调用结果：</p>
<p><img src="/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/autoconfig_06.png" alt></p>
<h4 id="注解的方式配置"><a href="#注解的方式配置" class="headerlink" title="注解的方式配置"></a>注解的方式配置</h4><p>除了上面的方式也可以通过注解的方式，那就不用在 <strong>META-INF/spring.factories</strong> 中添加配置类了。</p>
<p><strong>starter</strong> 项目中添加注解 <strong>@EnabledDemoAutoconfiguration</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.autoconfiguration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.autoconfiguration.config.DemoAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 自动配置注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/5/8 17:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;DemoAutoConfiguration<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnabledDemoAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解上添加 <strong>@Import({DemoAutoConfiguration.class})</strong> 将我们的自动配置类导入进来</p>
<p>而在主项目中 启动类或已加载的配置类上添加 该注解即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 添加Demo-starter自动配置</span></span><br><span class="line"><span class="meta">@EnabledDemoAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootLogging02Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(SpringBootLogging02Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SpringBoot自动配置说明就到这了，谢谢。。。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>自动配置</tag>
      </tags>
  </entry>
  <entry>
    <title>[SpringBoot] SpringBoot学习之日志管理</title>
    <url>/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h2><p>对于一个应用程序来说日志记录是必不可少的一部分，线上问题追踪，基于日志的业务逻辑统计分析等都离不开日志。</p>
<p>java中常见的的日志框架有：Log4j、Log4j2、Logback、JCL(Jakarta Commons Logging)、Slf4j(Simple Logging Façade for Java)、JUL(java.util.logging)、Jboss-logging ,这些框架有些是日志的抽象层，例如 JCL、SLF4J、Jboss-logging,而另一部分则是日志的实现 :Log4j、Log4j2、JUL、Logback</p>
<p><strong>在srpingBoot中使用的是 SLF4j + Logback 组合</strong></p>
<p><strong>准备：</strong></p>
<p>知识储备：</p>
<ul>
<li>熟练掌握SPRING，SPRINGMVC</li>
<li>了解springBoot的基本开发</li>
<li>了解至少一种日志框架的简单使用、应用场景以及基本配置</li>
</ul>
<p>环境条件：</p>
<ul>
<li>jdk1.8</li>
<li>maven4.0.0</li>
<li>IntelliJ IDEA 2017</li>
<li>Spring Boot 1.5.9.RELEASE</li>
</ul>
<p>学习计划：</p>
<ul>
<li>了解当前主流日志框架，优缺点对比，选型方案</li>
<li>学习springBoot日志框架原理</li>
<li>学习对springBoot日志管理的使用、基本配置以及高级特性</li>
<li>特定需求下，如何统一、更换项目日志框架。</li>
</ul>
<h2 id="日志框架简介"><a href="#日志框架简介" class="headerlink" title="日志框架简介"></a>日志框架简介</h2><h3 id="1-Java日志框架的发展与选择"><a href="#1-Java日志框架的发展与选择" class="headerlink" title="1. Java日志框架的发展与选择"></a>1. Java日志框架的发展与选择</h3><h4 id="日志框架的发展"><a href="#日志框架的发展" class="headerlink" title="日志框架的发展"></a>日志框架的发展</h4><blockquote>
<p>1996年早期，欧洲安全电子市场项目组决定编写它自己的程序跟踪API(Tracing API)。经过不断的完善，这个API终于成为一个十分受欢迎的Java日志软件包，即Log4j。后来Log4j成为Apache基金会项目中的一员。</p>
<p>期间Log4j近乎成了Java社区的日志标准。据说Apache基金会还曾经建议sun引入Log4j到java的标准库中，但Sun拒绝了。</p>
<p>2002年Java1.4发布，Sun推出了自己的日志库JUL(Java Util Logging),其实现基本模仿了Log4j的实现。在JUL出来以前，log4j就已经成为一项成熟的技术，使得log4j在选择上占据了一定的优势。</p>
<p>接着，Apache推出了Jakarta Commons Logging，JCL只是定义了一套日志接口(其内部也提供一个Simple Log的简单实现)，支持运行时动态加载日志组件的实现，也就是说，在你应用代码里，只需调用Commons Logging的接口，底层实现可以是log4j，也可以是Java Util Logging。</p>
<p>后来(2006年)，Ceki Gülcü不适应Apache的工作方式，离开了Apache。然后先后创建了slf4j(日志门面接口，类似于Commons Logging)和Logback(Slf4j的实现)两个项目，并回瑞典创建了QOS公司，QOS官网上是这样描述Logback的：The Generic，Reliable Fast&amp;Flexible Logging Framework(一个通用，可靠，快速且灵活的日志框架)。</p>
<p>现今，Java日志领域被划分为两大阵营：Commons Logging阵营和SLF4J阵营。</p>
<p>Commons Logging在Apache大树的笼罩下，有很大的用户基数。但有证据表明，形式正在发生变化。2013年底有人分析了GitHub上30000个项目，统计出了最流行的100个Libraries，可以看出slf4j的发展趋势更好：</p>
<p>Apache眼看有被Logback反超的势头，于2012-07重写了log4j 1.x，成立了新的项目Log4j 2。Log4j 2具有logback的所有特性。</p>
<p>​                                                                                                                                                       —– 引用自Internet</p>
</blockquote>
<p><strong>总结：</strong></p>
<table>
<thead>
<tr>
<th>日志门面（日志抽象层）</th>
<th align="left">日志实现</th>
</tr>
</thead>
<tbody><tr>
<td>JCL(Jakarta Commons Logging)          SLF4j(Simple Logging Facade for Java)       jboss-logging</td>
<td align="left">Log4j     JUL(java.util.logging)  Log4j2      Logback</td>
</tr>
</tbody></table>
<ul>
<li><p>当前Java日志领域分为俩大阵营，SLF4J 和 Commons-Logging阵营。这俩种都是日志门面，SLF4J本身并无日志的实现，JCL定义了一套日志接口，其内部提供了Simple Log的实现。</p>
</li>
<li><p>log4j和Logback则是具体的日志实现方案。可以简单的理解为接口与接口的实现，调用这只需要关注接口而无需关注具体的实现，做到解耦。</p>
</li>
<li><p>比较常用的组合是 Slf4j 与Logback 组合，Commons-logging 与Log4j的组合。</p>
</li>
<li><p>Log4j2与Log4j发生了很大的变化，log4j2不兼容log4j。</p>
</li>
<li><p>Logback必须配合Slf4j，因为他们是同一作者兼容性好。</p>
</li>
</ul>
<h4 id="日志框架的选择"><a href="#日志框架的选择" class="headerlink" title="日志框架的选择"></a>日志框架的选择</h4><p><strong>目前在新的项目中建议使用   Slf4j + Logback   的组合做为日志管理。</strong></p>
<ul>
<li><p>从日志门面上比较。<strong>Slf4j</strong> 的实现机制决定其限制较少，适用范围更广，通用性高。同时，相比于Commons-logging，<strong>Slf4j</strong>对于内存和CPU等资源的开销更小。</p>
</li>
<li><p>在日志的实现上比较，<strong>Logback</strong> 相比于其他日志实现框架拥有更好的性能，其次<strong>Logback</strong>的文档免费，对于开发者而言，相对有利。</p>
</li>
</ul>
<h3 id="2-SLF4j-框架的使用"><a href="#2-SLF4j-框架的使用" class="headerlink" title="2. SLF4j 框架的使用"></a>2. SLF4j 框架的使用</h3><p><strong>SLF4j 官网</strong>：<strong><em><a href="https://www.slf4j.org" target="_blank" rel="noopener">https://www.slf4j.org</a></em></strong></p>
<p>开发中，日志记录方法的调用，不应该直接调用日志的实现类，而是调用日志抽象层里的方法。</p>
<h4 id="SLF4j-框架的简单使用"><a href="#SLF4j-框架的简单使用" class="headerlink" title="SLF4j 框架的简单使用"></a>SLF4j 框架的简单使用</h4><p>导入SLF4j和 Logback 的jar 包。</p>
<p>SLF4j本身并无实现，所以得导入实现类jar 包，这里使用Logback，参照<code>spring-boot-starter-logging</code>：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_01.png" alt="spring-boot-starter-logging"></p>
<p>代码中使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SLF4j-与其他日志组件的桥接"><a href="#SLF4j-与其他日志组件的桥接" class="headerlink" title="SLF4j 与其他日志组件的桥接"></a>SLF4j 与其他日志组件的桥接</h4><p>SLF4j不仅可以与Logback组合，还可以与其他日志的实现框架组合，实现方法，可以参照官方文档：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_02.png" alt></p>
<ul>
<li><p>只导入slf4j 的jar包，没有实现类，指向<strong>/dev/null</strong></p>
</li>
<li><p>导入slf4j 的 jar包，也导入和其实现类的jar包，例如<strong>logback</strong>、<strong>slf4j-simple</strong>等，可以正常使用，</p>
</li>
<li><p>如果要使用<strong>log4j</strong>、<strong>JUL</strong>等非<strong>sfl4j</strong>阵营的实现类，只需要多导入一个适配层 的jar包即可，例如：slf4j-log412.jar 、slf4j-jdk14.jar等</p>
</li>
<li><p>每个日志的实现框架都有自己的配置文件。选用什么实现框架，就配置相关的配置文件，与<strong>SLF4j</strong>无关。</p>
</li>
</ul>
<h4 id="SLF4j-统一项目日志框架"><a href="#SLF4j-统一项目日志框架" class="headerlink" title="SLF4j 统一项目日志框架"></a>SLF4j 统一项目日志框架</h4><p><strong>问题记录：</strong>项目使用（SLF4j+Logback）作为日志框架，而项目中依赖的其他框架，例如Spring、Hibernate、Mybits等，他们的底层都使用了日志框架，而且各不相同：</p>
<table>
<thead>
<tr>
<th>其他框架</th>
<th>日志选型</th>
</tr>
</thead>
<tbody><tr>
<td>Spring</td>
<td>Commons-logging</td>
</tr>
<tr>
<td>Hibernate</td>
<td>Jboss-logging</td>
</tr>
<tr>
<td>Mybatis</td>
<td>Log4j</td>
</tr>
<tr>
<td>….</td>
<td>….</td>
</tr>
</tbody></table>
<p><strong>如何统一日志框架，SLF4j官方文档也给出了解决办法：</strong></p>
<img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_03.png" style="zoom:120%;">



<p><strong>以 Spring为例：</strong></p>
<p><strong>项目：SLF4J + Logback</strong> </p>
<p><strong>Spring：Commons-logging API</strong></p>
<p>那么如果我们想在项目中统一使用Logback去统一日志管理</p>
<p>只需要用jcl-over-slf4j.jar  包去替换 commons-logging.jar包即可。</p>
<p>步骤：</p>
<ul>
<li><p>将系统中其他日志框架先排除出去</p>
</li>
<li><p>用中间包来替换原有的日志框架</p>
</li>
<li><p>导入slf4j 其他的实现包</p>
</li>
</ul>
<p><strong>同样的，如果 项目中使用的是 Slf4j + 其他日志框架 的也可以使用这种方式统一日志框架。</strong></p>
<ul>
<li><p>首先将系统中其他日志框架先排除出去</p>
</li>
<li><p>用中间包来替换原有的日志框架</p>
</li>
<li><p>导入slf4j 其他的实现包</p>
</li>
</ul>
<img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_04.png">



<h4 id="问题：为什么导入替换这些包就可以统一日志框架？"><a href="#问题：为什么导入替换这些包就可以统一日志框架？" class="headerlink" title="问题：为什么导入替换这些包就可以统一日志框架？"></a>问题：为什么导入替换这些包就可以统一日志框架？</h4><p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_05.png" alt></p>
<p>查看 <code>jcl-over-slf4j.jar</code> 包可以看到，虽然 jar 包名称叫 <code>jcl-over-slf4j.jar</code> ，但是内部的包名确是<code>org.apache.commons.logging</code> ,项目中排除了jcl的依赖，当Spring框架去寻找日志部分的代码时会走到这里，而这里的<code>LogFactory</code> 实例化时创建的也是<code>SLF4JlogFactory</code>。作者就是通过这种方式实现了偷梁换柱，以此做到日志框架的统一的目的。</p>
<h2 id="SpringBoot中的日志框架"><a href="#SpringBoot中的日志框架" class="headerlink" title="SpringBoot中的日志框架"></a>SpringBoot中的日志框架</h2><p><strong>Spring-boot-starter-logging</strong> 使用 <strong>SLF4j + Logback</strong>。当然SpringBoot也能自动适配<strong>（jul、log4j、logback）</strong>并简化配置。</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_06.png" alt></p>
<h3 id="1-新建SpringBoot项目"><a href="#1-新建SpringBoot项目" class="headerlink" title="1. 新建SpringBoot项目"></a>1. 新建SpringBoot项目</h3><p>选择 Spring Initializer 快速创建。</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_07.png" alt></p>
<p>选择web 模块，方便测试，SpringBoot 版本选择 1.5.9，也可以再pom.xml中更改。</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_08.png" alt></p>
<p>点击Next ，再 点击Finish。</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_09.png" alt></p>
<h3 id="2-SpringBoot默认日志级别以及配置方法"><a href="#2-SpringBoot默认日志级别以及配置方法" class="headerlink" title="2. SpringBoot默认日志级别以及配置方法"></a>2. SpringBoot默认日志级别以及配置方法</h3><p>在自带的Test 方法中 <code>LoggerFactory.getLogger(getClass());</code> 创建创建日志对象。分别输出 trace、debug、info、warn、error级别的日志，右键运行Test ：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_10.png" alt></p>
<p>SpringBoot 默认输出日志级别是info 及以后的级别：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_11.png" alt></p>
<p><strong>想要更改默认输出级别，可以在application.properties文件中配置。</strong></p>
<h4 id="1）logging-level-root-debug-更改更改springBoot-默认级别"><a href="#1）logging-level-root-debug-更改更改springBoot-默认级别" class="headerlink" title="1）logging.level.root=debug 更改更改springBoot 默认级别"></a>1）logging.level.root=debug 更改更改springBoot 默认级别</h4><p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_12.png" alt></p>
<h4 id="2）-还可以设置指定的包文件下的日志级别："><a href="#2）-还可以设置指定的包文件下的日志级别：" class="headerlink" title="2） 还可以设置指定的包文件下的日志级别："></a>2） 还可以设置指定的包文件下的日志级别：</h4><p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_13.png" alt></p>
<h3 id="3-配置日志导出到文件"><a href="#3-配置日志导出到文件" class="headerlink" title="3. 配置日志导出到文件"></a>3. 配置日志导出到文件</h3><h4 id="1）只指定文件名"><a href="#1）只指定文件名" class="headerlink" title="1）只指定文件名"></a>1）只指定文件名</h4><p>使用 <code>logging-file</code> 指定文件名：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_14.png" alt></p>
<h4 id="2）指定文件名-路径"><a href="#2）指定文件名-路径" class="headerlink" title="2）指定文件名  + 路径"></a>2）指定文件名  + 路径</h4><p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_15.png" alt></p>
<h4 id="3）指定文件路径"><a href="#3）指定文件路径" class="headerlink" title="3）指定文件路径"></a>3）指定文件路径</h4><p>使用 <code>logging.path</code> 指定日志文件生成路径，默认文件名：<code>spring.log</code></p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_16.png" alt></p>
<h3 id="4-配置日志格式"><a href="#4-配置日志格式" class="headerlink" title="4. 配置日志格式"></a>4. 配置日志格式</h3><h4 id="1）控制台日志格式"><a href="#1）控制台日志格式" class="headerlink" title="1）控制台日志格式"></a>1）控制台日志格式</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_17.png" alt></p>
<p>我们也可以自定义格式，例如：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_18.png" alt></p>
<p><strong>格式设置说明：</strong></p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_19.png" alt></p>
<h4 id="2）更改输出文件日志格式"><a href="#2）更改输出文件日志格式" class="headerlink" title="2）更改输出文件日志格式"></a>2）更改输出文件日志格式</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_20.png" alt></p>
<h2 id="SpringBoot日志默认配置原理及高级特性"><a href="#SpringBoot日志默认配置原理及高级特性" class="headerlink" title="SpringBoot日志默认配置原理及高级特性"></a>SpringBoot日志默认配置原理及高级特性</h2><h3 id="1-Spring-Boot-日志默认配置及原理"><a href="#1-Spring-Boot-日志默认配置及原理" class="headerlink" title="1. Spring Boot 日志默认配置及原理"></a>1. Spring Boot 日志默认配置及原理</h3><p>为什么Spring Boot 默认配置了日志级别、日志默认文件名、日志格式等属性，查看SpringBoot源码可解：</p>
<img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_21.png" style="zoom: 50%;">

<p>以<strong>Logback</strong>为例，在<code>org.springframework.boot</code> 包里，已经配置好了相关日志框架的基本配置。</p>
<p><strong>base.xml:</strong></p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_22.png" alt></p>
<p><strong>defaut.xml:</strong></p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_23.png" alt></p>
<p><strong>此外，在<code>LoggingSystemProperties</code>中也设置了相关属性的默认值。</strong></p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_24.png" alt></p>
<h3 id="3-添加指定配置"><a href="#3-添加指定配置" class="headerlink" title="3. 添加指定配置"></a>3. 添加指定配置</h3><h4 id="问题：SpringBoot中只记录了日志实现框架的基本功能，如果我们要使用日志框架的高级功能该怎么做？"><a href="#问题：SpringBoot中只记录了日志实现框架的基本功能，如果我们要使用日志框架的高级功能该怎么做？" class="headerlink" title="问题：SpringBoot中只记录了日志实现框架的基本功能，如果我们要使用日志框架的高级功能该怎么做？"></a>问题：SpringBoot中只记录了日志实现框架的基本功能，如果我们要使用日志框架的高级功能该怎么做？</h4><p><strong>参考官方文档：</strong></p>
<table>
<thead>
<tr>
<th>Logging System</th>
<th>Customization</th>
</tr>
</thead>
<tbody><tr>
<td>Logback</td>
<td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code> ,<code>logback.xml</code>  or <code>logback.groovy</code></td>
</tr>
<tr>
<td>Log4j2</td>
<td><code>log4j2-spring.xml</code>  or  <code>log4j2.xml</code></td>
</tr>
<tr>
<td>JUL(Java Util Logging)</td>
<td><code>logging.properties</code></td>
</tr>
</tbody></table>
<p>我们只需要在资源文件夹下添加相关框架的配置文件即可：</p>
<p>以Logback 为例：添加logback-spring.xml, logback-spring.groovy, logback.xml 或者logback.groovy 文件，然后在里面编写相关配置即可。</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_25.png" alt></p>
<p>运行项目看是否已更改</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_26.png" alt></p>
<h3 id="4-Spring-Boot-日志管理高级特性"><a href="#4-Spring-Boot-日志管理高级特性" class="headerlink" title="4. Spring Boot 日志管理高级特性"></a>4. Spring Boot 日志管理高级特性</h3><p>​      上面提到添加指定配置可以引入<code>logback.xml</code> 也可以是 <code>logback-spring.xml</code> (以Logback为例)，那么俩者的区别是什么？</p>
<p>​      区别在于 <code>logback.xml</code> 其实是直接被底层框架<strong>Logback</strong>识别，而 <code>logback-spring.xml</code> 是被<strong>SpringBoot</strong>识别加载，这样的好处是<strong>SpringBoot</strong>可以添加一些日志实现框架以外的高级功能。</p>
<p>例如：</p>
<p><strong>SpringBoot</strong>支持添加 <springProfile> 标签设置不同环境的日志配置。</springProfile></p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_27.png" alt></p>
<p>默认不是dev环境：</p>
<p>设置：<strong><code>spring.profile.active=dev</code></strong>  激活dev环境后</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_28.png" alt></p>
<h2 id="切换SpringBoot日志实现框架"><a href="#切换SpringBoot日志实现框架" class="headerlink" title="切换SpringBoot日志实现框架"></a>切换SpringBoot日志实现框架</h2><p><strong>SpringBoot</strong> 默认使用的是 <strong>SLF4J + Logback *<em>的方式实现日志管理，如果我们想用 *</em>SLF4j + Log4j</strong> 的方式该如何实现。</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_02.png" alt></p>
<p>依据官方文档：</p>
<h4 id="1-排除-Logback-相关-jar-包"><a href="#1-排除-Logback-相关-jar-包" class="headerlink" title="1.  排除 Logback 相关 jar 包"></a>1.  排除 Logback 相关 jar 包</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--排除Logback相关jar包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--排除log4j转换包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-导入-Log4j-相关-jar-包"><a href="#2-导入-Log4j-相关-jar-包" class="headerlink" title="2. 导入 Log4j 相关 jar 包"></a>2. 导入 Log4j 相关 jar 包</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-查看依赖树"><a href="#3-查看依赖树" class="headerlink" title="3. 查看依赖树"></a>3. 查看依赖树</h4><p>右键 -&gt; Diagrams -&gt; Show Dependencies</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_29.png" alt></p>
<p>运行项目Test，查看日志输出格式，已更改为log4j默认输出格式：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_30.png" alt></p>
<h4 id="4-统一日志框架"><a href="#4-统一日志框架" class="headerlink" title="4. 统一日志框架"></a>4. 统一日志框架</h4><p>方式如1.2 SLF4j统一日志记录  方式相同。</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_04.png" alt></p>
<h4 id="5-另一种切换方式"><a href="#5-另一种切换方式" class="headerlink" title="5. 另一种切换方式"></a>5. 另一种切换方式</h4><p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_31.png" alt></p>
<p><strong>SpringBoot</strong> 默认使用<code>spring-boot-starter-logging</code> ，其底层使用的是 <strong>Slf4j + logback</strong></p>
<p>而官方提供另外的 starter：<code>spring-boot-starter-log4j2</code>，其使用的则是 <strong>log4j2</strong> 作为日志的实现。所以我们只需排除掉 <code>spring-boot-starter-logging</code>，然后再引入<code>spring-boot-starter-log4j2</code>，就可以做到由 <strong>Logback</strong> 到 <strong>log4j2</strong> 的切换。</p>
<p>排除 spring-boot-starter-logging：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_32.png" alt></p>
<p><strong>pom.xml</strong></p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_33.png" alt></p>
<p>再看下 依赖树：</p>
<p><img src="/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/springboot_log_34.png" alt></p>
<p>以上就是关于 Spring Boot 日志框架学习的全部内容，从相识到相知，希望你看过这篇文章后对springBoot日志部分有个更深入了解，谢谢！</p>
<p><strong>如果你觉得写的还不错，请给我个 star 吧：<a href="https://github.com/CharleyZZZZ/CharleyZZZZ.github.io" target="_blank" rel="noopener">https://github.com/CharleyZZZZ/CharleyZZZZ.github.io</a></strong></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>日志管理</tag>
      </tags>
  </entry>
  <entry>
    <title>[SpringBoot] SpringBoot学习之启动配置原理</title>
    <url>/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h2><p><strong>为了更深入掌握SpringBoot的核心技术，我们需要从第一步项目启动开始，了解SpringBoot的启动原理，运行流程，自动配置原理。</strong></p>
<p><strong>知识储备：</strong></p>
<ul>
<li><p>熟练掌握SPRING，SPRINGMVC，掌握各种监听器的作用和使用方法。</p>
</li>
<li><p>掌握使用SpringBoot创建简单项目</p>
</li>
<li><p>熟练使用Eclipse或者IDEA</p>
</li>
</ul>
<p><strong>环境条件：</strong></p>
<ul>
<li><p>jdk1.8</p>
</li>
<li><p>maven4.0.0</p>
</li>
<li><p>IntelliJ IDEA 2017</p>
</li>
<li><p>Spring Boot 1.5.9.RELEASE；</p>
</li>
</ul>
<p><strong>学习计划：</strong></p>
<ul>
<li><p>Debug方式跑完启动流程。</p>
</li>
<li><p>了解SpringBoot启动原理以及自动配置原理</p>
</li>
<li><p>自定义监听器</p>
</li>
</ul>
<h2 id="Spring-Boot-启动配置原理剖析"><a href="#Spring-Boot-启动配置原理剖析" class="headerlink" title="Spring Boot 启动配置原理剖析"></a>Spring Boot 启动配置原理剖析</h2><p><strong>新建SpringBoot项目，在main方法里打断点，通过调试的方法一步一步分析SpringBoot启动流程。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootLogging02Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在此处打断点进入</span></span><br><span class="line">		SpringApplication.run(SpringBootLogging02Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>F7进入方法，可以看到主要分为俩大步：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Static helper that can be used to run a &#123;<span class="doctag">@link</span> SpringApplication&#125; from the</span></span><br><span class="line"><span class="comment"> * specified sources using default settings and user supplied arguments.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sources the sources to load</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Object[] sources, String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(sources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong>new SpringApplication(sources)   创建SpringApplication</strong></p>
</li>
<li><p><strong>run(args)  运行SpringApplication</strong></p>
</li>
</ul>
<p>接下来将分别来看：</p>
<h3 id="1-创建-SpringApplication"><a href="#1-创建-SpringApplication" class="headerlink" title="1.创建 SpringApplication"></a>1.创建 SpringApplication</h3><p><strong>进入SpringApplication的构造器内：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new &#123;<span class="doctag">@link</span> SpringApplication&#125; instance. The application context will load</span></span><br><span class="line"><span class="comment"> * beans from the specified sources (see &#123;<span class="doctag">@link</span> SpringApplication class-level&#125;</span></span><br><span class="line"><span class="comment"> * documentation for details. The instance can be customized before calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #run(String...)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sources the bean sources</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #run(Object, String[])</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #SpringApplication(ResourceLoader, Object...)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(Object... sources)</span> </span>&#123;</span><br><span class="line">	initialize(sources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Object[] sources)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sources != <span class="keyword">null</span> &amp;&amp; sources.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 添加 source</span></span><br><span class="line">		<span class="keyword">this</span>.sources.addAll(Arrays.asList(sources));</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// 判断web环境</span></span><br><span class="line">	<span class="keyword">this</span>.webEnvironment = deduceWebEnvironment();</span><br><span class="line">       <span class="comment">// 设置Initializers</span></span><br><span class="line">	setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">			ApplicationContextInitializer<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">       <span class="comment">// 设置Listeners</span></span><br><span class="line">	setListeners(</span><br><span class="line">           (Collection) getSpringFactoriesInstances(ApplicationListener<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">       <span class="comment">// 判断main方法</span></span><br><span class="line">	<span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由初始化方法分析以下步骤：</p>
<h4 id="配置资源-：读取主配置类"><a href="#配置资源-：读取主配置类" class="headerlink" title="配置资源 ：读取主配置类"></a>配置资源 ：读取主配置类</h4><p><img src="/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/springboot_start_01.png" alt></p>
<h4 id="判断Web环境"><a href="#判断Web环境" class="headerlink" title="判断Web环境"></a>判断Web环境</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] WEB_ENVIRONMENT_CLASSES = &#123; <span class="string">"javax.servlet.Servlet"</span>,</span><br><span class="line">		<span class="string">"org.springframework.web.context.ConfigurableWebApplicationContext"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">deduceWebEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (String className : WEB_ENVIRONMENT_CLASSES) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>即通过判断是否存在以下类，来判断是否是web应用：</strong></p>
<ul>
<li><p>javax.servlet.Servlet</p>
</li>
<li><p>org.springframework.web.context.ConfigurableWebApplicationContext</p>
</li>
</ul>
<h4 id="保存-ApplicationContextInitializer"><a href="#保存-ApplicationContextInitializer" class="headerlink" title="保存 ApplicationContextInitializer"></a>保存 ApplicationContextInitializer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123;</span><br><span class="line">	<span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,</span><br><span class="line">		Class&lt;?&gt;[] parameterTypes, Object... args) &#123;</span><br><span class="line">	ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">	<span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">       <span class="comment">// 加载 ApplicationContextInitializer 类型的类</span></span><br><span class="line">	Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(</span><br><span class="line">			SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">       <span class="comment">// 创建实例</span></span><br><span class="line">	List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">			classLoader, args, names);</span><br><span class="line">       <span class="comment">// 排序</span></span><br><span class="line">	AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">	<span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里通过<strong>SpringFactoriesLoaler</strong>加载 <strong>ApplicationContextInitializer</strong> 类型的类<br>        Set<String> names = new LinkedHashSet<String>(<br>                SpringFactoriesLoader.loadFactoryNames(type, classLoader));</String></String></p>
<p>进入 <strong>SpringFactoriesLoader.loadFactoryNames</strong> 方法后发现，就是从类路径<strong>META-INF/spring.factories</strong> 内加载所有的 <strong>ApplicationContextInitializer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The location to look for factories.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Can be present in multiple JAR files.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-	INF/spring.factories"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载META-INF/spring.factories 文件中定义的类</span></span><br><span class="line">Enumeration&lt;URL&gt; urls = </span><br><span class="line">    (classLoader != <span class="keyword">null</span> ?classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">				ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">	URL url = urls.nextElement();</span><br><span class="line">	Properties properties=PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(url));</span><br><span class="line">	String factoryClassNames = properties.getProperty(factoryClassName);</span><br><span class="line">	result.addAll(Arrays.asList(</span><br><span class="line">        StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>



<p>在源码包中可以找到：<strong>META-INF/spring.factories</strong>：</p>
<p><img src="/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/springboot_start_02.png" alt></p>
<h4 id="保存-ApplicationListener"><a href="#保存-ApplicationListener" class="headerlink" title="保存 ApplicationListener"></a>保存 ApplicationListener</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与上一步类似，也是从 META-INF/spring.factories 中读取类，并实例化，</span></span><br><span class="line"><span class="comment">// 最后放到SpringApplication的 listeners 属性中</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/springboot_start_03.png" alt></p>
<h4 id="获取main方法"><a href="#获取main方法" class="headerlink" title="获取main方法"></a>获取main方法</h4><p><img src="/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/springboot_start_04.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 main入口 的方法</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line">		<span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">"main"</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">				<span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">		<span class="comment">// Swallow and continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此，SpringApplication对象创建完成了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>保存主配置类</p>
</li>
<li><p>判断web应用</p>
</li>
<li><p><strong>从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后实例化，保存起来</strong></p>
</li>
<li><p><strong>从类路径下找到META-INF/spring.factories配置的所有ApplicationListener；然后实例化，保存起来</strong></p>
</li>
<li><p>获取main方法位置</p>
</li>
</ul>
<h3 id="2-运行SpringApplication-run-String…-args"><a href="#2-运行SpringApplication-run-String…-args" class="headerlink" title="2. 运行SpringApplication.run(String… args)"></a>2. 运行SpringApplication.run(String… args)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the Spring application, creating and refreshing a new</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">	StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">	stopWatch.start();</span><br><span class="line">	ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">	FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">	configureHeadlessProperty();</span><br><span class="line">       <span class="comment">// 获取SpringApplicationRunListener</span></span><br><span class="line">	SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">       <span class="comment">// 回调 starting() 方法</span></span><br><span class="line">	listeners.starting();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 获取命令行参数</span></span><br><span class="line">		ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">				args);</span><br><span class="line">           <span class="comment">// 准备环境</span></span><br><span class="line">		ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">				applicationArguments);</span><br><span class="line">           <span class="comment">// 打印控制台</span></span><br><span class="line">		Banner printedBanner = printBanner(environment);</span><br><span class="line">           <span class="comment">// 创建上下文 context</span></span><br><span class="line">		context = createApplicationContext();</span><br><span class="line">           <span class="comment">// 启动异常拦截</span></span><br><span class="line">		analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">           <span class="comment">// 准备上下文 </span></span><br><span class="line">		prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">				printedBanner);</span><br><span class="line">           <span class="comment">// 刷新（初始化）上下文</span></span><br><span class="line">		refreshContext(context);</span><br><span class="line">		afterRefresh(context, applicationArguments);</span><br><span class="line">           <span class="comment">// 回调 listeners 的 finished 方法</span></span><br><span class="line">		listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">		stopWatch.stop();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">			<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">					.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析该方法得知 run方法 主要做了以下几件事：</strong></p>
<ul>
<li><p>获取SpringApplicationRunListener，并回调starting方法</p>
</li>
<li><p>准备、配置环境信息</p>
</li>
<li><p>创建上下文（IOC容器）</p>
</li>
<li><p>准备（初始化）上下文</p>
</li>
<li><p>初始化 IOC 容器</p>
</li>
<li><p>IOC容器中获取ApplicationRunner和CommandLineRunner并回调</p>
</li>
<li><p>所有的SpringApplicationRunListener，回调finished方法</p>
</li>
<li><p>返回ioc容器</p>
</li>
</ul>
<h4 id="获取SpringApplicationRunListener，并回调starting-方法"><a href="#获取SpringApplicationRunListener，并回调starting-方法" class="headerlink" title="获取SpringApplicationRunListener，并回调starting()方法"></a>获取SpringApplicationRunListener，并回调starting()方法</h4><p>进入getRunListeners（args）方法内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title">getRunListeners</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">    <span class="comment">// getSpringFactoriesInstance  与上面一样是从 META-INF/factories 文件中加载</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</span><br><span class="line">        SpringApplicationRunListener<span class="class">.<span class="keyword">class</span>, <span class="title">types</span>, <span class="title">this</span>, <span class="title">args</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/springboot_start_05.png" alt></p>
<p>回调 listener.starting() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 循环回调 starting()方法</span></span><br><span class="line">	<span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="keyword">this</span>.listeners) &#123;</span><br><span class="line">		listener.starting();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="准备、配置环境信息"><a href="#准备、配置环境信息" class="headerlink" title="准备、配置环境信息"></a>准备、配置环境信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">prepareEnvironment</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">		ApplicationArguments applicationArguments)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Create and configure the environment</span></span><br><span class="line">       <span class="comment">// 获取或创建环境</span></span><br><span class="line">	ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">       <span class="comment">// 配置环境</span></span><br><span class="line">	configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">       <span class="comment">// 循环回调 listener.environmentPrepared(environment); 方法</span></span><br><span class="line">	listeners.environmentPrepared(environment);</span><br><span class="line">       <span class="comment">// 判断 web环境，是否进行环境转换</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.webEnvironment) &#123;</span><br><span class="line">		environment = <span class="keyword">new</span> EnvironmentConverter(getClassLoader())</span><br><span class="line">				.convertToStandardEnvironmentIfNecessary(environment);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取或者创建环境：</p>
<ul>
<li>当前环境不为空就返回当前环境，</li>
<li>当前是web环境就返回new StandarServletEnvironment，</li>
<li>否则返回StandardEnvironment</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">getOrCreateEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.webEnvironment) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StandardServletEnvironment();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置环境</p>
<p>这里主要是加载properties 文件和 profiles</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureEnvironment</span><span class="params">(ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">		String[] args)</span> </span>&#123;</span><br><span class="line">	configurePropertySources(environment, args);</span><br><span class="line">	configureProfiles(environment, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断非web环境，返回 StandardEnvironment</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StandardEnvironment convertToStandardEnvironmentIfNecessary(</span><br><span class="line">		ConfigurableEnvironment environment) &#123;</span><br><span class="line">	if (environment instanceof StandardEnvironment</span><br><span class="line">			&amp;&amp; !isWebEnvironment(environment, this.classLoader)) &#123;</span><br><span class="line">		return (StandardEnvironment) environment;</span><br><span class="line">	&#125;</span><br><span class="line">	return convertToStandardEnvironment(environment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建上下文-context"><a href="#创建上下文-context" class="headerlink" title="创建上下文 context"></a>创建上下文 context</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The class name of application context that will be used by default for non-web</span></span><br><span class="line"><span class="comment">	 * environments.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONTEXT_CLASS = <span class="string">"org.springframework.context."</span></span><br><span class="line">    + <span class="string">"annotation.AnnotationConfigApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The class name of application context that will be used by default for web</span></span><br><span class="line"><span class="comment">	 * environments.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_WEB_CONTEXT_CLASS = <span class="string">"org.springframework."</span></span><br><span class="line">    + <span class="string">"boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">    <span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断web环境，选择不同上下文类型，</span></span><br><span class="line">            contextClass = Class.forName(</span><br><span class="line">                <span class="keyword">this</span>.webEnvironment ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"Unable create a default ApplicationContext, "</span></span><br><span class="line">                + <span class="string">"please specify an ApplicationContextClass"</span>,</span><br><span class="line">                ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据反射获取上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="准备（初始化）上下文"><a href="#准备（初始化）上下文" class="headerlink" title="准备（初始化）上下文"></a>准备（初始化）上下文</h4><p>这里简单来说就是对上下文环境做简单配置，并触发相关监听器的回调方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">			ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 设置环境信息</span></span><br><span class="line">    	context.setEnvironment(environment);</span><br><span class="line">    	<span class="comment">// 注册beanNameGenerator，设置 ResourceLoader</span></span><br><span class="line">		postProcessApplicationContext(context);</span><br><span class="line">    	<span class="comment">// 获取SpringApplication 中的 initializers ,回调 initialize() 方法</span></span><br><span class="line">		applyInitializers(context);</span><br><span class="line">		listeners.contextPrepared(context);</span><br><span class="line">    	</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">			logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">			logStartupProfileInfo(context);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">    	<span class="comment">// 注册一些简单组件</span></span><br><span class="line">		context.getBeanFactory().registerSingleton(<span class="string">"springApplicationArguments"</span>,</span><br><span class="line">				applicationArguments);</span><br><span class="line">		<span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">			context.getBeanFactory().registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Load the sources</span></span><br><span class="line">		Set&lt;Object&gt; sources = getSources();</span><br><span class="line">		Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">		load(context, sources.toArray(<span class="keyword">new</span> Object[sources.size()]));</span><br><span class="line">    	<span class="comment">// listener 回调 contextLoaded 方法</span></span><br><span class="line">		listeners.contextLoaded(context);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="初始化-IOC-容器"><a href="#初始化-IOC-容器" class="headerlink" title="初始化 IOC 容器"></a>初始化 IOC 容器</h4><p>初始化IOC容器（context）主要分为以下两步：</p>
<ul>
<li><p>初始化容器内所有的bean</p>
</li>
<li><p>Web应用还会创建嵌入式的tomcat（或其他中间件）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">       Object var1 = <span class="keyword">this</span>.startupShutdownMonitor;</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 刷新上下文环境</span></span><br><span class="line"><span class="comment">            * 初始化上下文环境，对系统环境变量或系统属性进行准备和校验</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// 创建 BeanFactory ,解析XML，相当于之前的XmlBeanFactory操作</span></span><br><span class="line">           ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// 初始化 beanFactory</span></span><br><span class="line">           <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 提供子类覆盖的额外处理</span></span><br><span class="line">               <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">               <span class="comment">// 激活各种BeanFactory处理器</span></span><br><span class="line">               <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">               <span class="comment">// 注册各种处理器</span></span><br><span class="line">               <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">               <span class="comment">// 初始化上下文资源文件，国际化文件</span></span><br><span class="line">               <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">               <span class="comment">// 注册事件广播器，并放入上下文</span></span><br><span class="line">               <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">               <span class="comment">// 提供子类扩展的额外处理</span></span><br><span class="line">               <span class="keyword">this</span>.onRefresh();</span><br><span class="line">               <span class="comment">// 获取Listeners，并放入 applicationEventMulticaster（事件广播器）</span></span><br><span class="line">               <span class="keyword">this</span>.registerListeners();</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 设置转换器</span></span><br><span class="line"><span class="comment">                * 注册一个默认的属性值解析器</span></span><br><span class="line"><span class="comment">                * 冻结所有bean定义，说明注册的bean定义将不能被修改或进一步处理</span></span><br><span class="line"><span class="comment">                * 初始化剩余的非惰性的bean，即初始化非延迟加载的bean</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">        		<span class="comment">// 完成初始化后续操作</span></span><br><span class="line">               <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (BeansException var9) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">               <span class="keyword">this</span>.cancelRefresh(var9);</span><br><span class="line">               <span class="keyword">throw</span> var9;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">this</span>.resetCommonCaches();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中 this.finishRefresh() 方法详细说明一下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化Spring 生命周期处理类</span></span><br><span class="line">    <span class="keyword">this</span>.initLifecycleProcessor();</span><br><span class="line">    <span class="comment">// 生命周期处理类开始生命周期</span></span><br><span class="line">    <span class="keyword">this</span>.getLifecycleProcessor().onRefresh();</span><br><span class="line">    <span class="comment">// 事件发布</span></span><br><span class="line">    <span class="keyword">this</span>.publishEvent((ApplicationEvent)(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>)));</span><br><span class="line">    LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>初始化生命周期处理器 <strong>DefaultLifecycleProcessor</strong>，<strong>DefaultLifecycleProcessor</strong>含有<strong>start</strong>方法和<strong>stop</strong>方法</p>
</li>
<li><p><strong>spring</strong> 启动的时候调用 <strong>start</strong> 方法开始生命周期</p>
</li>
<li><p><strong>spring</strong> 关闭的时候调用 <strong>stop</strong> 方法来结束生命周期，</p>
</li>
<li><p>启动所有实现了<strong>Lifecycle</strong> 接口的类</p>
</li>
<li><p>通过<strong>spring</strong> 的事件发布机制发布 <strong>ContextRefreshedEvent</strong> 事件，以保证对应的监听器做进一步处理，即对那种在<strong>spring</strong> 启动后需要处理的一些类，实现了<strong>ApplicationListener</strong><ContextRefreshedEvent>,这里即是触发这些类的执行（执行<strong>onApplicationEvent</strong>方法），除此之外，<strong>spring</strong> 内置 <strong>Event</strong> 有 <strong>ContextClosedEvent</strong> 、<strong>ContextRefreshedEvent</strong> 、<strong>ContextStartedEvent</strong> 、<strong>ContextStopedEvent</strong> 、<strong>ContextHandleEvent</strong></ContextRefreshedEvent></p>
</li>
<li><p>最后完成初始化，通知生命周期处理器 <strong>LifecycleProcessor</strong> 刷新过程，同时发出事件通知其他 类</p>
</li>
</ul>
<h4 id="IOC容器中获取ApplicationRunner和CommandLineRunner并回调"><a href="#IOC容器中获取ApplicationRunner和CommandLineRunner并回调" class="headerlink" title="IOC容器中获取ApplicationRunner和CommandLineRunner并回调"></a>IOC容器中获取ApplicationRunner和CommandLineRunner并回调</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRefresh</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">		ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">	callRunners(context, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">	List&lt;Object&gt; runners = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">       <span class="comment">// 从IOC容器中获取 ApplicationRunner 和 CommandLineRunner</span></span><br><span class="line">	runners.addAll(context.getBeansOfType(ApplicationRunner<span class="class">.<span class="keyword">class</span>).<span class="title">values</span>())</span>;</span><br><span class="line">	runners.addAll(context.getBeansOfType(CommandLineRunner<span class="class">.<span class="keyword">class</span>).<span class="title">values</span>())</span>;</span><br><span class="line">	AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">	<span class="keyword">for</span> (Object runner : <span class="keyword">new</span> LinkedHashSet&lt;Object&gt;(runners)) &#123;</span><br><span class="line">           <span class="comment">// 一次 调用ApplicationRunner 和 CommandLineRunner 的 run() 方法</span></span><br><span class="line">		<span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) &#123;</span><br><span class="line">			callRunner((ApplicationRunner) runner, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) &#123;</span><br><span class="line">			callRunner((CommandLineRunner) runner, args);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunner</span><span class="params">(ApplicationRunner runner, ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		(runner).run(args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to execute ApplicationRunner"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunner</span><span class="params">(CommandLineRunner runner, ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		(runner).run(args.getSourceArgs());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to execute CommandLineRunner"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与前面获取 <strong>ApplicationContextInitializer</strong> 和 <strong>ApplicationListener</strong> 不同的是，<strong>ApplicationRunner</strong> 和<strong>CommandLineRunner</strong> 的获取是从context（即IOC容器）中获取的。</p>
<p>然后依次回调，这里要注意回调先后顺序（<strong>优先级</strong>） <strong>ApplicationRunner</strong>  <strong>&gt;</strong>  <strong>CommandLineRunner</strong></p>
<h4 id="所有的SpringApplicationRunListener，回调finished方法"><a href="#所有的SpringApplicationRunListener，回调finished方法" class="headerlink" title="所有的SpringApplicationRunListener，回调finished方法"></a>所有的SpringApplicationRunListener，回调finished方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finished</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="keyword">this</span>.listeners) &#123;</span><br><span class="line">		callFinishedListener(listener, context, exception);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="返回ioc容器"><a href="#返回ioc容器" class="headerlink" title="返回ioc容器"></a>返回ioc容器</h4><p>至此，SpringAppication 的run方法就运行完了，Spring Boot也启动完成了。</p>
<h2 id="Spring-Boot-启动过程中的时间回调机制"><a href="#Spring-Boot-启动过程中的时间回调机制" class="headerlink" title="Spring Boot 启动过程中的时间回调机制"></a>Spring Boot 启动过程中的时间回调机制</h2><h3 id="1-SpringBoot启动过程中的监听器"><a href="#1-SpringBoot启动过程中的监听器" class="headerlink" title="1. SpringBoot启动过程中的监听器"></a>1. SpringBoot启动过程中的监听器</h3><p>在分析完SpringBoot启动原理后我们发现，SpringBoot启动过程中使用了如下4个监听器：</p>
<ul>
<li><p><strong>配置在 META-INF/spring.factories 中：</strong></p>
<p>​        -  ApplicationContextInitializer</p>
<p>​        -  SpringApplicationRunListener</p>
<ul>
<li><p><strong>从IOC容器中获取的：</strong></p>
<p>​        -  ApplicationRunner</p>
<p>​        -  CommandLineRunner</p>
</li>
</ul>
</li>
</ul>
<p><strong>思考</strong>：在SpringBoot启动过程中都有注册并回调上述监听器，那么我们可否自定义上述监听器，已完成在项目启动过程中需要实现的功能</p>
<h3 id="2-自定义事件监听器"><a href="#2-自定义事件监听器" class="headerlink" title="2. 自定义事件监听器"></a>2. 自定义事件监听器</h3><p>新建 <strong>HelloApplicationContextInitializer</strong> 、<strong>HelloSpringApplicationRunListener</strong> 类，分别实现 <strong>ApplicationContextInitializer</strong> 和 <strong>SpringApplicationRunListener</strong> 接口</p>
<p><strong>HelloApplicationContextInitializer：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextInitializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/4/28 14:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationContextInitailizer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ConfigurableApplicationContext configurableApplicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=== &gt;&gt;&gt; HelloApplicationContextInitailizer.initialize === "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HelloSpringApplicationRunListener：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplicationRunListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.ConfigurableEnvironment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/4/28 15:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSpringApplicationRunListener</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意该类必须实现一个有参的构造器，否则报错</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> application</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> HelloSpringApplicationRunListener</span><br><span class="line">        (SpringApplication application,String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloSpringApplicationRunListener.starting... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloSpringApplicationRunListener.environmentPrepared... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloSpringApplicationRunListener.contextPrepared... "</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloSpringApplicationRunListener.contextLoaded... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finished</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloSpringApplicationRunListener.finished... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建 <strong>HelloApplicationRunner</strong>：实现 <strong>ApplicationRunner</strong> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/4/28 15:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloApplicationRunner.run "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建 <strong>HelloCommandLineRunner</strong>，实现 <strong>CommandLineRunner</strong> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/4/28 15:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloCommandLineRunner.run... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 <strong>ApplicationContextInitializer</strong>、<strong>SpringApplicationRunListener</strong> 的实现类配置在类路径下的<strong>META-INF/spring.factories</strong>里：</p>
<p><img src="/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/springboot_start_06.png" alt></p>
<p><strong>HelloApplicationRunner</strong> 和 <strong>HelloCommandLineRunner</strong> 是从上下文中获取，只需要在类上添加<strong>@Component</strong> 注解即可</p>
<p><strong>启动项目，查看控制台日志</strong></p>
<img src="/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/springboot_start_07.png" style="zoom: 80%;">





<p><strong>如果你觉得写的还不错，请给我个 star 吧：<a href="https://github.com/CharleyZZZZ/CharleyZZZZ.github.io" target="_blank" rel="noopener">https://github.com/CharleyZZZZ/CharleyZZZZ.github.io</a></strong></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>[Spring] Spring 常用注解(一)</title>
    <url>/2020/05/13/Spring-Spring-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3-%E4%B8%80/</url>
    <content><![CDATA[<h3 id="1-Bean相关"><a href="#1-Bean相关" class="headerlink" title="1. Bean相关"></a>1. Bean相关</h3><h4 id="1-1-Autowired"><a href="#1-1-Autowired" class="headerlink" title="1.1 @Autowired"></a>1.1 @Autowired</h4><p>依赖注入，自动导入对象到类中，该类同样要求被 <strong>Spring</strong> 容器管理，例如 <strong>Controller</strong> 中注入 <strong>Service</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserService userService;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-2-Bean-注册"><a href="#1-2-Bean-注册" class="headerlink" title="1.2 Bean 注册"></a>1.2 Bean 注册</h4><ul>
<li><p>*<em>@Component *</em> 注解表明一个类会作为组件类，并告知Spring要为这个类创建bean</p>
</li>
<li><p><strong>@Repository</strong>  对应持久层即 Dao 层，主要用于数据库相关操作</p>
</li>
<li><p><strong>@Service</strong>  对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p>
</li>
<li><p><strong>@Controller</strong>  对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</p>
</li>
<li><p>*<em>@Bean *</em> 注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑；</p>
</li>
<li><p><strong>@Configuration</strong>  与 <strong>@Component</strong> 功能类似，语义上是声明配置类，也可用 <strong>@Component</strong> 替代</p>
</li>
</ul>
<h4 id="1-3-Scope-Bean做用域"><a href="#1-3-Scope-Bean做用域" class="headerlink" title="1.3 @Scope Bean做用域"></a>1.3 <strong>@Scope</strong> Bean做用域</h4><p>声明 Spring Bean 的作用域，使用方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">personSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>四种常见的 Spring Bean 的作用域：</strong></p>
<ul>
<li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</li>
<li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
</ul>
<h3 id="2-Controller层常用"><a href="#2-Controller层常用" class="headerlink" title="2. Controller层常用"></a>2. Controller层常用</h3><h4 id="2-1-基本注解"><a href="#2-1-基本注解" class="headerlink" title="2.1 基本注解"></a>2.1 基本注解</h4><ul>
<li><p>@<strong>RequestMapping(“url”)</strong>  这里的 url写的是请求路径的一部分，一般作用在 Controller的方法上，作为请求的映射地址。</p>
</li>
<li><p>@<strong>RestController</strong>  该注解是  @<strong>ResponseBody</strong>  和 @<strong>Controller</strong> 注解的集合，</p>
</li>
<li><p>@<strong>RequestBody</strong>  作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 <strong>JavaBean</strong> 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上。</p>
</li>
<li><p>@<strong>ResponseBody</strong>  作用在方法上，将方法的返回结果直接写入 <strong>HTTP response body</strong> 中，用<strong>json</strong>的格式 返回</p>
</li>
</ul>
<h4 id="2-2-Http请求相关注解"><a href="#2-2-Http请求相关注解" class="headerlink" title="2.2 Http请求相关注解"></a>2.2 Http请求相关注解</h4><p><strong>五种常见的请求类型:</strong></p>
<ul>
<li><p><strong>GET</strong> ：请求从服务器获取特定资源。举个例子：GET /users（获取所有学生）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价于@RequestMapping(value="/users",method=RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"users"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>POST</strong> ：在服务器</p>
</li>
<li><p>创建一个新的资源。举个例子：POST /users（创建学生）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价于@RequestMapping(value="/users",method=RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"users"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>PUT</strong> ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：PUT /users/12（更新编号为 12 的学生）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价于@RequestMapping(value="/users/&#123;userId&#125;",method=RequestMethod.PUT)</span></span><br><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/users/&#123;userId&#125;"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DELETE</strong> ：从服务器删除特定的资源。举个例子：DELETE /users/12（删除编号为 12 的学生）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价于@RequestMapping(value="/users/&#123;userId&#125;",method=RequestMethod.DELETE)</span></span><br><span class="line"><span class="meta">@DeleteMapping</span>(<span class="string">"/users/&#123;userId&#125;"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>PATCH</strong> ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般实际项目中，我们都是 PUT 不够用了之后才用 PATCH 请求去更新数据。</span></span><br><span class="line"><span class="meta">@PatchMapping</span>(<span class="string">"/profile"</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="2-3-前后端传值相关"><a href="#2-3-前后端传值相关" class="headerlink" title="2.3 前后端传值相关"></a>2.3 前后端传值相关</h4><ol>
<li><p><strong>@PathVariable</strong> <strong>和</strong> <strong>@RequestParam</strong></p>
<p>@<strong>PathVariable</strong>用于获取路径参数，@<strong>RequestParam</strong>用于获取查询参数。</p>
<p>具体见示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;userId&#125;/name"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         @PathVariable(<span class="string">"userId"</span>)</span> Long userId,</span></span><br><span class="line"><span class="function">         @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"employeeId"</span>, required = <span class="keyword">false</span>)</span> Long employeeId ) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><strong>@RequestBody</strong></p>
<p>作用在形参列表上，读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且<strong>Content-Type 为 application/json</strong> 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用<strong>HttpMessageConverter</strong>或者自定义的<strong>HttpMessageConverter</strong>将请求的 body 中的 json 字符串转换为 java 对象。</p>
<p>简单来说就是 将 前台的 传来的 <strong>json</strong> 字符串 自动转成 对象。</p>
<p>可与 @<strong>ResponseBody</strong> 同时记忆</p>
</li>
</ol>
<h5 id="知识点：ajax-中-DataType-和-ContentType-的区别"><a href="#知识点：ajax-中-DataType-和-ContentType-的区别" class="headerlink" title="知识点：ajax 中 DataType 和 ContentType 的区别"></a>知识点：ajax 中 DataType 和 ContentType 的区别</h5><ul>
<li><strong>contentType</strong>   告诉服务器，我要发什么类型的数据，对于后台接口来说就是请求参数</li>
<li><strong>dataType</strong>  告诉服务器，我要想什么类型的数据，对于后台接口来说就是请求返回值</li>
</ul>
<h4 id="2-4-参数校验相关注解"><a href="#2-4-参数校验相关注解" class="headerlink" title="2.4 参数校验相关注解"></a>2.4 参数校验相关注解</h4><p><strong>JSR(Java Specification Requests）</strong> 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了，校验的时候我们实际用的是 <strong>Hibernate Validator</strong> 框架。</p>
<table>
<thead>
<tr>
<th><strong>Hibernate Validator</strong></th>
<th>JSR标准</th>
</tr>
</thead>
<tbody><tr>
<td>Hibernate Validator 4.x</td>
<td>Bean Validation 1.0（JSR 303）</td>
</tr>
<tr>
<td>Hibernate Validator 5.x</td>
<td>Bean Validation 1.1（JSR 349）</td>
</tr>
<tr>
<td>Hibernate Validator 6.x</td>
<td>Bean Validation 2.0（JSR 380）</td>
</tr>
</tbody></table>
<p>而SpringBoot 项目的 spring-boot-starter-web 依赖中已经有 hibernate-validator 包，不需要引用相关依赖。</p>
<p><strong>所有的注解，推荐使用 JSR 注解，即</strong> <strong>javax.validation.constraints</strong>，而不是<strong>org.hibernate.validator.constraints</strong></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>@AssertTrue</td>
<td>用于boolean字段，该字段只能为true</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>该字段的值只能为false</td>
</tr>
<tr>
<td>@CreditCardNumber</td>
<td>对信用卡号进行一个大致的验证</td>
</tr>
<tr>
<td>@DecimalMax</td>
<td>只能小于或等于该值</td>
</tr>
<tr>
<td>@DecimalMin</td>
<td>只能大于或等于该值</td>
</tr>
<tr>
<td>@Digits(integer=,fraction=)</td>
<td>检查是否是一种数字的整数、分数,小数位数的数字</td>
</tr>
<tr>
<td>@Email</td>
<td>检查是否是一个有效的email地址</td>
</tr>
<tr>
<td>@Future</td>
<td>检查该字段的日期是否是属于将来的日期</td>
</tr>
<tr>
<td>@Length(min=,max=)</td>
<td>检查所属的字段的长度是否在min和max之间,只能用于字符串</td>
</tr>
<tr>
<td>@Max</td>
<td>该字段的值只能小于或等于该值</td>
</tr>
<tr>
<td>@Min</td>
<td>该字段的值只能大于或等于该值</td>
</tr>
<tr>
<td>@NotNull</td>
<td>不能为null</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>不能为空，检查时会将空格忽略</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>不能为空，这里的空是指空字符串</td>
</tr>
<tr>
<td>@Null</td>
<td>检查该字段为空</td>
</tr>
<tr>
<td>@Past</td>
<td>检查该字段的日期是在过去</td>
</tr>
<tr>
<td>@Pattern(regex=,flag=)</td>
<td>被注释的元素必须符合指定的正则表达式</td>
</tr>
<tr>
<td>@Range(min=,max=,message=)</td>
<td>被注释的元素必须在合适的范围内</td>
</tr>
<tr>
<td>@Size(min=, max=)</td>
<td>检查该字段的size是否在min和max之间，可以是字符串、数组、集合、Map等</td>
</tr>
<tr>
<td>@URL(protocol=,host,port)</td>
<td>检查是否是一个有效的URL，如果提供了protocol，host等，则该URL还需满足提供的条件</td>
</tr>
<tr>
<td>@Valid</td>
<td>该注解主要用于字段为一个包含其他对象的集合或map或数组的字段，或该字段直接为一个其他对象的引用，这样在检查当前对象的同时也会检查该字段所引用的对象</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.NotEmpty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/5/9 17:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty</span>(message = <span class="string">"姓名不能为空！"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"年龄不能为空！"</span>)</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Controller</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/person"</span>)</span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@RequestBody @Valid Person person)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ResponseEntity.ok().body(person);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>在需要验证的参数上加上了@Valid注解，如果验证失败，它将抛出MethodArgumentNotValidException，同时配合ExceptionHandler,捕捉异常，封装统一出错返回信息给前端。</strong></p>
<p>对于请求参数不是对象类型的，可直接在 请求参数上添加校验注解，</p>
<p><strong>但是在类上一定要加上</strong> <strong>Validated</strong> <strong>注解了，这个参数可以告诉 Spring 去校验方法参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/4/27 17:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/person/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="title">getPersonByID</span><span class="params">(@Valid @PathVariable(<span class="string">"id"</span>)</span> @<span class="title">Max</span><span class="params">(value = <span class="number">5</span>,message = <span class="string">"超过 id 的范围了"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-5-全局Controller异常相关注解"><a href="#2-5-全局Controller异常相关注解" class="headerlink" title="2.5 全局Controller异常相关注解"></a>2.5 全局Controller异常相关注解</h4><h5 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a><strong>@ExceptionHandler</strong></h5><p>单独使用<strong>@ExceptionHandler</strong>时一般写在控制器的内部，在控制器的某个方法上加上<strong>@ExceptionHandler</strong>注解。</p>
<p>在<strong>ExceptionController</strong>内部如果抛出了指定<strong>XXXXException</strong>异常，就会被这个控制器内部的<strong>handleError</strong>捕捉到。然后进行处理。</p>
<p>但是这样就很麻烦，需要在每个控制器上添加这样一个方法。</p>
<p>通常的做法是 项目添加<strong>BaseController</strong>，在其他控制器继承<strong>BaseController</strong>，此外 <strong>BaseController</strong> 还可以封装控制器通用方法，常量等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> <span class="keyword">implements</span> <span class="title">IBaseConstants</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(BaseController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分页常量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PAGE = <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PAGE_SIZE = <span class="string">"10"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JSP_500 = <span class="string">"500"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR_MESSAGE = <span class="string">"errorMsg"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Object</span> <span class="title">exceptionHandler</span>(<span class="title">Exception</span> <span class="title">exception</span>, <span class="title">HttpServletRequest</span> <span class="title">request</span>) </span>&#123;</span><br><span class="line">        LOGGER.error(exception.getMessage(), exception);</span><br><span class="line">        Throwable rootCause = <span class="keyword">this</span>.getRootCause(exception);</span><br><span class="line">        IBaseException baseException;</span><br><span class="line">        <span class="comment">// 这里判断是否是 ajax 请求，来判断是返回json ，还是 modelAndView视图</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isAjaxRequest(request) &amp;&amp; !<span class="keyword">this</span>.isApiRequest(request) &amp;&amp; !ServletFileUpload.isMultipartContent(request)) &#123;</span><br><span class="line">            ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(JSP_500);</span><br><span class="line">            <span class="keyword">if</span> (rootCause <span class="keyword">instanceof</span> IBaseException) &#123;</span><br><span class="line">                modelAndView.addObject(ERROR_MESSAGE, exception.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> modelAndView;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BaseResponseDTO baseResponseDTO = <span class="keyword">new</span> BaseResponseDTO(<span class="keyword">false</span>);</span><br><span class="line">            baseResponseDTO.setMessage(exception.getMessage());</span><br><span class="line">            <span class="keyword">if</span> (rootCause <span class="keyword">instanceof</span> IBaseException) &#123;</span><br><span class="line">                baseException = (IBaseException) rootCause;</span><br><span class="line">                baseResponseDTO.setCode(baseException.getCode());</span><br><span class="line">                baseResponseDTO.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baseResponseDTO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h5><p>@ExceptionHandler + @ControllerAdvice</p>
<p>Spring 3.2版本中添加了 新的注解 <strong>@ControllerAdvice</strong> 支持全局的异常处理，这样就可以单独用一个类处理异常了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;ExceptionException<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">String</span> <span class="title">handleError</span>(<span class="title">Exception</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        <span class="keyword">return</span> e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span>&lt;<span class="title">Object</span>&gt; <span class="title">handleAllException</span>(<span class="title">Exception</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(...); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充：</strong></p>
<p>​    全局异常捕捉还有一种方式，即实现 <strong>HandlerExceptionResolver</strong> 接口，要求实现其 <strong>resolveException</strong></p>
<p>方法，返回<strong>ModelAndView</strong>对象，要想返回 <strong>Json</strong> 对象，需要定制化，例如 直接在response 中回写，或者 用<strong>MappingJackson2JsonView</strong> 对象，但是 不推荐这样使用。</p>
<h3 id="3-配置文件相关"><a href="#3-配置文件相关" class="headerlink" title="3. 配置文件相关"></a>3. 配置文件相关</h3><h5 id="Value"><a href="#Value" class="headerlink" title="@Value"></a><strong>@Value</strong></h5><p>读取简单配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">String serverPort;</span><br></pre></td></tr></table></figure>



<h5 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a><strong>@ConfigurationProperties</strong></h5><p>读取配置信息，并且配合 <strong>@Configuration</strong> 或者 <strong>@Component</strong> 注解注册到上下文</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfigurationProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a>@EnableConfigurationProperties</h5><p>如果未添加 <strong>@Configuration</strong> 或者 <strong>@Component</strong> 注解 ，可以 在使用的地方 添加<strong>@EnableConfigurationProperties</strong> 注解指定配置类将其注入到 上下文中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnabledDemoAutoConfiguration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MyConfigurationProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringBootLogging02Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> MyConfigurationProperties configurationProperties;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SpringBootLogging02Application</span><span class="params">(MyConfigurationProperties configurationProperties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.configurationProperties = configurationProperties;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(SpringBootLogging02Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a><strong>@PropertySource</strong></h5><p><strong>读取指定 properties 文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:myself.properties"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myselfConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-JPA相关"><a href="#4-JPA相关" class="headerlink" title="4. JPA相关"></a>4. JPA相关</h3><table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@<strong>Entity</strong></td>
<td>声明一个类对应一个数据库实体。</td>
</tr>
<tr>
<td>@<strong>Table</strong></td>
<td>设置表名</td>
</tr>
<tr>
<td>@<strong>Id</strong></td>
<td>声明主键</td>
</tr>
<tr>
<td>@<strong>GeneratedValue</strong></td>
<td><strong>JPA</strong> 使用枚举定义了 4 中常见的主键生成策略：<strong>TABLE</strong>（特定表格存储），<strong>SEQUENCE</strong>（序列），<strong>IDENTITY</strong>（自增长），<strong>AUTO</strong>（交给持久化引擎决定，他会在以上三种选一个，默认使用这个）</td>
</tr>
<tr>
<td>@<strong>GenericGenerator</strong></td>
<td>声明一个主键策略，然后@<strong>GeneratedValue</strong>使用这个策略</td>
</tr>
<tr>
<td>@<strong>Column</strong></td>
<td>声明字段</td>
</tr>
<tr>
<td>@<strong>Transient</strong></td>
<td>声明指定不持久化字段</td>
</tr>
<tr>
<td>@<strong>Lob</strong></td>
<td>声明某个字段为大字段</td>
</tr>
<tr>
<td>@<strong>Basic</strong>(fetch = FetchType.EAGER)</td>
<td>指定 <strong>Lob</strong> 类型数据的获取策略， <strong>FetchType.EAGER</strong> 表示非延迟 加载，而 <strong>FetchType. LAZY</strong> 表示延迟加载</td>
</tr>
<tr>
<td>@<strong>Enumerated</strong></td>
<td>声明使用枚举类型的字段</td>
</tr>
<tr>
<td>@<strong>CreatedBy</strong></td>
<td>声明审计字段  创建者</td>
</tr>
<tr>
<td>@<strong>LastModifiedBy</strong></td>
<td>声明审计字段  上次修改者</td>
</tr>
<tr>
<td>@<strong>CreatedDate</strong></td>
<td>声明审计字段  上次修改时间</td>
</tr>
<tr>
<td>@<strong>LastModifiedDate</strong></td>
<td>声明审计字段  最后修改时间</td>
</tr>
<tr>
<td>@<strong>EnableJpaAuditing</strong></td>
<td>开启JPA审计功能，一般放启动类上</td>
</tr>
<tr>
<td>@<strong>EntityListeners</strong>(AuditingEntityListener.class)</td>
<td>设置实体类监听器，指定审计相关监听器</td>
</tr>
<tr>
<td>@<strong>OneToOne</strong></td>
<td>声明关联关系：一对一</td>
</tr>
<tr>
<td>@<strong>OneToMany</strong></td>
<td>声明关联关系：一对多</td>
</tr>
<tr>
<td>@<strong>ManyToOne</strong></td>
<td>声明关联关系：多对一</td>
</tr>
<tr>
<td>@<strong>ManyToMany</strong></td>
<td>声明关联关系：多对多</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"sys_user"</span>)</span><br><span class="line"><span class="meta">@ApiModel</span>(<span class="string">"用户表"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysUser</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span></span><br><span class="line">    <span class="meta">@Enumerated</span>(EnumType.STRING)</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="meta">@Column</span>(updatable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> Instant createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="keyword">private</span> Instant updatedAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedBy</span></span><br><span class="line">    <span class="meta">@Column</span>(updatable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String createdBy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedBy</span></span><br><span class="line">    <span class="keyword">private</span> String updatedBy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 暂存字段，不持久化</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> String depatmentName;</span><br><span class="line">   </span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-JSON处理相关"><a href="#5-JSON处理相关" class="headerlink" title="5. JSON处理相关"></a>5. JSON处理相关</h3><h4 id="5-1-Json过滤"><a href="#5-1-Json过滤" class="headerlink" title="5.1 Json过滤"></a>5.1 Json过滤</h4><h5 id="JsonIgnoreProperties"><a href="#JsonIgnoreProperties" class="headerlink" title="@JsonIgnoreProperties"></a><strong>@JsonIgnoreProperties</strong></h5><p>作用在类上用于过滤掉特定字段不返回或者不解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonIgnoreProperties</span>(&#123;<span class="string">"userRoles"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysUser</span> <span class="keyword">extends</span> <span class="title">BaseDTO</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户角色关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="JsonIgnore"><a href="#JsonIgnore" class="headerlink" title="@JsonIgnore"></a><strong>@JsonIgnore</strong></h5><p>用于类的<strong>属性</strong>上，作用和上面的*<em>@JsonIgnoreProperties *</em>一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonIgnoreProperties</span>(&#123;<span class="string">"userRoles"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysUser</span> <span class="keyword">extends</span> <span class="title">BaseDTO</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-2-格式化Json数据"><a href="#5-2-格式化Json数据" class="headerlink" title="5.2 格式化Json数据"></a>5.2 格式化Json数据</h4><h5 id="JsonFormat"><a href="#JsonFormat" class="headerlink" title="@JsonFormat"></a><strong>@JsonFormat</strong></h5><p>一般用来格式化 json 数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonFormat</span>(pattern=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>,timezone=<span class="string">"GMT+8"</span>)</span><br><span class="line"><span class="keyword">private</span> Date endTime;</span><br></pre></td></tr></table></figure>



<h5 id="JsonUnwrapped"><a href="#JsonUnwrapped" class="headerlink" title="@JsonUnwrapped"></a>@<strong>JsonUnwrapped</strong></h5><p>Json数据扁平化处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Country</span><span class="params">(String name, Province province)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 国家名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省会</span></span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> Province province;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Province <span class="title">getProvince</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProvince</span><span class="params">(Province province)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Province</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Province</span><span class="params">(String capital)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capital = capital;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 省会</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String capital;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCapital</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> capital;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCapital</span><span class="params">(String capital)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capital = capital;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JsonInclude"><a href="#JsonInclude" class="headerlink" title="@JsonInclude"></a>@JsonInclude</h5><p>指定字段的序列化条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonInclude</span>(JsonInclude.Include.NON_NULL)</span><br><span class="line"><span class="keyword">private</span> String code;</span><br><span class="line"><span class="meta">@JsonInclude</span>(JsonInclude.Include.NON_NULL)</span><br><span class="line"><span class="keyword">private</span> String message;</span><br></pre></td></tr></table></figure>

<p><strong>JsonJsonInclude.Include.ALWAYS</strong> 默认策略，任何情况下都序列化该字段，和不写这个注解是一样的效果。<br><strong>JsonJsonInclude.Include.NON_NULL</strong> 最常用，即如果加该注解的字段为null,那么就不序列化这个字段了。<br><strong>JsonJsonInclude.Include.NON_ABSENT</strong> 包含NON_NULL，即为null的时候不序列化</p>
<p><strong>JsonJsonInclude.Include.NON_EMPTY</strong>  属性包含NON_NULL，NON_ABSENT之后还包含如果字段为空也不序列化。这个也比较常用<br><strong>JsonJsonInclude.Include.NON_DEFAULT</strong>如果字段是默认值的话就不序列化。</p>
<h5 id="JsonProperty"><a href="#JsonProperty" class="headerlink" title="@JsonProperty"></a><strong>@JsonProperty</strong></h5><p>此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，</p>
<p>例如如把positionCode属性序列化为postCode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonProperty</span>(value=<span class="string">"postCode"</span>)</span><br><span class="line"><span class="keyword">private</span> String positionCode;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonProperty</span>(value=<span class="string">"postName"</span>)</span><br><span class="line"><span class="keyword">private</span> String positionName;</span><br></pre></td></tr></table></figure>





<h3 id="6-SpringBoot常用注解"><a href="#6-SpringBoot常用注解" class="headerlink" title="6. SpringBoot常用注解"></a>6. SpringBoot常用注解</h3><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><p>该注解是在创建SpringBoot项目后自动添加在主类上的，在项目启动时生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">		@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由代码可知，该注解其实是由 <strong>@Configuration</strong>  、 <strong>@EnableAutoConfiguration</strong> 和 <strong>@ComponentScan</strong> 三个注解组成，这三个注解的含义是：</p>
<ul>
<li>@<strong>EnableAutoConfiguration</strong>：启用 <strong>SpringBoot</strong> 的自动配置机制</li>
<li>@<strong>ComponentScan</strong>： 扫描被 <strong>@Component (@Service,@Controller,@Repository)</strong> 注解的 <strong>bean</strong>，注解默认会扫描该类所在的包下所有的类。</li>
<li>@<strong>Configuration</strong>：允许在 <strong>Spring</strong> 上下文中注册额外的 <strong>bean</strong> 或导入其他配置类</li>
</ul>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式架构之基础理论学习</title>
    <url>/2020/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="分布式系统特点"><a href="#分布式系统特点" class="headerlink" title="分布式系统特点"></a>分布式系统特点</h3><p>​        随着移动互联网的快速发展，互联网的用户数量越来越多，产生的数据规模也越来越大，对应用系统提出了更高的要求，我们的系统必须支持高并发访问和海量数据处理。</p>
<p>分布式系统技术就是用来解决集中式架构的性能瓶颈问题，来适应快速发展的业务规模，一般来说，分布式系统是建立在网络之上的硬件或者软件系统，<strong>彼此之间通过消息等方式进行通信和协调</strong>。</p>
<p>分布式系统的核心是<strong>可扩展性</strong>，通过对服务、存储的扩展，来提高系统的处理能力，通过对多台服务器协同工作，来完成单台服务器无法处理的任务，尤其是高并发或者大数据量的任务。</p>
<p>除了对可扩展性的需求，分布式系统还有<strong>不出现单点故障、服务或者存储无状态</strong>等特点。</p>
<ul>
<li><p><strong>单点故障</strong>（Single Point Failure）是指在系统中某个组件一旦失效，这会让整个系统无法工作，而不出现单点故障，单点不影响整体，就是分布式系统的设计目标之一；</p>
</li>
<li><p><strong>无状态</strong>，是因为无状态的服务才能满足部分机器宕机不影响全部，可以随时进行扩展的需求。</p>
</li>
</ul>
<h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><p>由于分布式系统的特点，在分布式环境中更容易出现问题，比如<strong>节点之间通信失败、网络分区故障、多个副本的数据不一致</strong>等，为了更好的在分布式系统下进行开发，出现了一系列的理论，其中具有代表性的就是 <strong>CAP 理论</strong>。</p>
<p><strong>CAP 理论</strong>可以表述为，一个分布式系统最多只能同时满足<strong>一致性</strong>（Consistency）、<strong>可用性</strong>（Availability）和<strong>分区容忍性</strong>（Partition Tolerance）这三项中的两项。</p>
<p><img src="/2020/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/CAP.png" alt></p>
<ul>
<li><p><strong>一致性</strong>是指“所有节点同时看到相同的数据”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，等同于所有节点拥有数据的最新版本。</p>
</li>
<li><p><strong>可用性</strong>是指“任何时候，读写都是成功的”，即服务一直可用，而且是正常响应时间。我们平时会看到一些 IT 公司的对外宣传，比如系统稳定性已经做到 3 个 9、4 个 9，即 99.9%、99.99%，这里的 N 个 9 就是对可用性的一个描述，叫做 SLA，即服务水平协议。比如我们说月度 99.95% 的 SLA，则意味着每个月服务出现故障的时间只能占总时间的 0.05%，如果这个月是 30 天，那么就是 21.6 分钟。</p>
</li>
<li><p><strong>分区容忍性</strong>具体是指“当部分节点出现消息丢失或者分区故障的时候，分布式系统仍然能够继续运行”，即系统容忍网络出现分区，并且在遇到某节点或网络分区之间网络不可达的情况下，仍然能够对外提供满足一致性和可用性的服务。</p>
</li>
</ul>
<p>在分布式系统中，由于系统的各层拆分，<strong>P</strong> 是确定的，CAP 的应用模型就是 <strong>CP 架构</strong>和 <strong>AP 架构</strong>。</p>
<h3 id="CP-和-AP-架构的取舍"><a href="#CP-和-AP-架构的取舍" class="headerlink" title="CP 和 AP 架构的取舍"></a>CP 和 AP 架构的取舍</h3><p>在通常的分布式系统中，为了保证数据的高可用，通常会将数据保留多个副本（Replica），<strong>网络分区</strong>是既成的现实，于是只能在<strong>可用性</strong>和<strong>一致性</strong>两者间做出选择。CAP 理论关注的是在绝对情况下，在工程上，<strong>可用性和一致性并不是完全对立的，我们关注的往往是如何在保持相对一致性的前提下，提高系统的可用性。</strong></p>
<p>业务上对一致性的要求会直接反映在系统设计中，典型的就是 <strong>CP</strong> 和 <strong>AP</strong> 架构。</p>
<p><strong>CP 架构：</strong>放弃可用性，追求一致性和分区容错性。</p>
<p>​    我们熟悉的 <strong>ZooKeeper</strong>，就是采用了 <strong>CP</strong> 一致性，ZooKeeper 是一个分布式的服务框架，主要用来解决分布式集群中应用系统的协调和一致性问题。Zookeeper 采用 数据一致性算法 <strong>ZAB</strong> （基于Paxos）保证数据一致性。在 Zookeeper中，当<strong>master</strong> 节点因为网络故障与其他节点失去联系时，其余节点会重新进行<strong>leader</strong> 选举，一般选举时间为 <strong>30~120 s</strong>，且选举期间整个zk集群都是<strong>不可用的</strong>，这会导致在选举期间注册服务瘫痪。失去可用性。</p>
<p><strong>AP 架构：</strong>放弃强一致性，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的 Base 也是根据 AP 来扩展的。</p>
<p>​    和 ZooKeeper 相对的是 Eureka，Eureka 是 Spring Cloud 微服务技术栈中的服务发现组件，Eureka 的各个节点都是平等的，几个节点挂掉不影响正常节点的工作，剩余的节点依然可以提供注册和查询服务，只要有一台 Eureka 还在，就能保证注册服务可用，只不过查到的信息可能不是最新的版本，不保证一致性。</p>
<h3 id="Base-理论"><a href="#Base-理论" class="headerlink" title="Base 理论"></a>Base 理论</h3><p>对于 CAP 来说，放弃<strong>强一致性</strong>（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择。在工程实践中，基于 CAP 定理逐步演化，就提出了 Base 理论。</p>
<p>Base 是三个短语的简写，即<strong>基本可用</strong>（Basically Available）、<strong>软状态</strong>（Soft State）和<strong>最终一致性</strong>（Eventually Consistent）。</p>
<img src="/2020/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/Base.png" style="zoom:70%;">

<p><strong>Base 理论</strong>的核心思想是<strong>最终一致性</strong>，即使无法做到强一致性（Strong Consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到<strong>最终一致性</strong>（Eventual Consistency）。</p>
<ul>
<li><strong>基本可用：</strong> 就是不追求 CAP 中的「任何时候，读写都是成功的」，而是系统能够基本运行，一直提供服务。基本可用强调了分布式系统在出现不可预知故障的时候，允许损失部分可用性，相比正常的系统，可能是响应时间延长，或者是服务被降级。</li>
<li><strong>软状态：</strong>软状态可以对应 ACID 事务中的原子性（在 ACID 的事务中，实现的是强制一致性，要么全做要么不做，所有用户看到的数据一致。其中的原子性（Atomicity）要求多个节点的数据副本都是一致的，强调数据的一致性，可以理解为一种“硬状态”），软状态则是允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</li>
<li><strong>最终一致性：</strong>数据不可能一直是软状态，必须在一个时间期限之后达到各个节点的一致性，在期限过后，应当保证所有副本保持数据一致性，也就是达到数据的最终一致性。在系统设计中，最终一致性实现的时间取决于网络延时、系统负载、不同的存储选型、不同数据复制方案设计等因素。</li>
</ul>
<p><strong>不同数据一致性模型</strong></p>
<p>一般来说，数据一致性模型可以分为<strong>强一致性</strong>和<strong>弱一致性</strong>，强一致性也叫做线性一致性，除此以外，所有其他的一致性都是弱一致性的特殊情况。弱一致性根据不同的业务场景，又可以分解为更细分的模型，不同一致性模型又有不同的应用场景。</p>
<p>在互联网领域的绝大多数场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p>
<img src="/2020/05/14/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/Consistency.png" style="zoom: 67%;">

<p>对于一致性，可以分为从服务端和客户端两个不同的视角，结合全局时钟概念，这里关注的主要是外部一致性。</p>
<p><strong>强一致性</strong></p>
<p>当更新操作完成之后，任何多个后续进程的访问都会返回最新的更新过的值，这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。</p>
<p><strong>弱一致性</strong></p>
<p>系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。用户读到某一操作对系统数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。</p>
<p><strong>最终一致性</strong></p>
<p>最终一致性是弱一致性的特例，强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<p>到达最终一致性的时间 ，就是不一致窗口时间，在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。</p>
<p>最终一致性模型根据其提供的不同保证可以划分为更多的模型，包括因果一致性和会话一致性等。</p>
<ul>
<li><p><strong>因果一致性</strong> ： 因果一致性要求有因果关系的操作顺序得到保证，非因果关系的操作顺序则无所谓。例如：进程 A 在更新完某个数据项后通知了进程 B，那么进程 B 之后对该数据项的访问都应该能够获取到进程 A 更新后的最新值，并且如果进程 B 要对该数据项进行更新操作的话，务必基于进程 A 更新后的最新值。</p>
</li>
<li><p><strong>会话一致性</strong>：会话一致性将对系统数据的访问过程框定在了一个会话当中，约定了系统能保证在同一个有效的会话中实现“读己之所写”的一致性，就是在你的一次访问中，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。实际开发中有分布式的 Session 一致性问题，可以认为是会话一致性的一个应用。</p>
</li>
</ul>
<p><strong>CAP  和 Base  的关系</strong></p>
<p>Base 理论是在 CAP 上发展的，CAP 理论描述了分布式系统中数据一致性、可用性、分区容错性之间的制约关系，当你选择了其中的两个时，就不得不对剩下的一个做一定程度的牺牲。</p>
<p>Base 理论则是对 CAP 理论的实际应用，也就是在分区和副本存在的前提下，通过一定的系统设计方案，放弃强一致性，实现基本可用，这是大部分分布式系统的选择，比如 NoSQL 系统、微服务架构。在这个前提下，如何把基本可用做到最好，就是分布式工程师们追求的。</p>
<p>除了 CAP 和 Base，还有 ACID 原理，ACID 是一种强一致性模型，强调原子性、一致性、隔离性和持久性，主要用于在<strong>数据库</strong>实现中。Base 理论面向的是高可用、可扩展的分布式系统，ACID 适合传统金融等业务，在实际场景中，不同业务对数据的一致性要求不一样，ACID 和 Base 理论往往会结合使用。</p>
<h3 id="全局时钟和逻辑时钟"><a href="#全局时钟和逻辑时钟" class="headerlink" title="全局时钟和逻辑时钟"></a>全局时钟和逻辑时钟</h3><p>​    分布式系统解决了<strong>传统单体架构的单点问题和性能容量问题</strong>，另一方面也带来了很多新的问题，其中一个问题就是<strong>多节点的时间同步问题</strong>：不同机器上的物理时钟难以同步，导致无法区分在分布式系统中多个节点的事件时序。</p>
<p>没有全局时钟，绝对的<strong>内部一致性</strong>是没有意义的，一般来说，我们讨论的一致性都是外部一致性，而外部一致性主要指的是多并发访问时更新过的数据如何获取的问题。</p>
<p>和全局时钟相对的，是<strong>逻辑时钟</strong>，逻辑时钟描绘了分布式系统中事件发生的时序，是为了区分现实中的物理时钟提出来的概念。</p>
<p>一般情况下我们提到的时间都是指物理时间，但实际上很多应用中，只要所有机器有相同的时间就够了，这个时间不一定要跟实际时间相同。更进一步解释：如果两个节点之间不进行交互，那么它们的时间甚至都不需要同步。 因此问题的关键点在于节点间的交互要在事件的发生顺序上达成一致，而不是对于时间达成一致。</p>
<p>逻辑时钟的概念也被用来解决分布式一致性问题。</p>
<p><strong>以上学习内容均来自邴越老师《分布式技术原理与实战》课程，用于学习记录，希望大家共同进步，欧耶。</strong></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式架构之事务管理</title>
    <url>/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><blockquote>
<p>事务（Transaction），一般是指要做的或所做的事情。在计算机<a href="https://baike.baidu.com/item/术语" target="_blank" rel="noopener">术语</a>中是指访问并可能更新数据库中各种<a href="https://baike.baidu.com/item/数据项/3227309" target="_blank" rel="noopener">数据项</a>的一个程序执行单元(unit)。事务通常由<a href="https://baike.baidu.com/item/高级数据库/1439366" target="_blank" rel="noopener">高级数据库</a>操纵语言或编程语言（如SQL，C++或Java）书写的<a href="https://baike.baidu.com/item/用户程序/7450916" target="_blank" rel="noopener">用户程序</a>的执行所引起，并用形如<strong>begin transaction</strong>和<strong>end transaction</strong>语句（或<a href="https://baike.baidu.com/item/函数调用/4127405" target="_blank" rel="noopener">函数调用</a>）来界定。事务由事务开始(<strong>begin transaction</strong>)和事务结束(<strong>end transaction</strong>)之间执行的全体操作组成。</p>
<p>— 来自百度百科</p>
</blockquote>
<h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><p>数据库事务的特性包括<strong>原子性</strong>（Atomicity）、<strong>一致性</strong>（Consistency）、<strong>隔离性</strong>（Isolation）和<strong>持久性</strong>（Durabilily），简称 <strong>ACID</strong>。</p>
<p>在数据库执行中，多个并发执行的事务如果涉及到同一份数据的读写就容易出现数据不一致的情况，不一致的异常现象有以下几种。</p>
<p><strong>脏读</strong>，是指一个事务中访问到了另外一个事务未提交的数据。</p>
<p>例如事务 T1 中修改的数据项在尚未提交的情况下被其他事务（T2）读取到，如果 T1 进行回滚操作，则 T2 刚刚读取到的数据实际并不存在。</p>
<p><strong>不可重复读</strong>，是指一个事务读取同一条记录 2 次，得到的结果不一致。</p>
<p>例如事务 T1 第一次读取数据，接下来 T2 对其中的数据进行了更新或者删除，并且 Commit 成功。这时候 T1 再次读取这些数据，那么会得到 T2 修改后的数据，发现数据已经变更，这样 T1 在一个事务中的两次读取，返回的结果集会不一致。</p>
<p><strong>幻读</strong>，是指一个事务读取 2 次，得到的记录条数不一致。</p>
<p>例如事务 T1 查询获得一个结果集，T2 插入新的数据，T2 Commit 成功后，T1 再次执行同样的查询，此时得到的结果集记录数不同。</p>
<p>脏读、不可重复读和幻读有以下的包含关系，如果发生了脏读，那么幻读和不可重复读都有可能出现。</p>
<img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_01.png" style="zoom:80%;">

<h3 id="不同隔离级别"><a href="#不同隔离级别" class="headerlink" title="不同隔离级别"></a>不同隔离级别</h3><p>SQL 标准根据三种不一致的异常现象，将隔离性定义为<strong>四个隔离级别</strong>（Isolation Level），<strong>隔离级别和数据库的性能呈反比，隔离级别越低，数据库性能越高；而隔离级别越高，数据库性能越差</strong>，具体如下：</p>
<img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_02.png" style="zoom: 50%;">

<h4 id="Read-uncommitted-读未提交"><a href="#Read-uncommitted-读未提交" class="headerlink" title="Read uncommitted 读未提交"></a>Read uncommitted 读未提交</h4><p>字面理解，即读取其他事务未提交的数据。</p>
<p>在该级别下，一个事务对数据修改的过程中，不允许另一个事务对该行数据进行修改，但允许另一个事务对该行数据进行读，不会出现更新丢失，但会出现<strong>脏读、不可重复读</strong>的情况。</p>
<h4 id="Read-committed-读已提交"><a href="#Read-committed-读已提交" class="headerlink" title="Read committed 读已提交"></a>Read committed 读已提交</h4><p>字面理解，即读取其他事务已提交的数据。</p>
<p>在该级别下，未提交的写事务不允许其他事务访问该行，不会出现脏读，但是读取数据的事务允许其他事务访问该行数据，因此会出现<strong>不可重复读</strong>的情况。</p>
<h4 id="Repeatable-read-可重复读"><a href="#Repeatable-read-可重复读" class="headerlink" title="Repeatable read 可重复读"></a>Repeatable read 可重复读</h4><p>字面理解，即一个事务内重复读取相同数据结果一致的。（幻读是记录条数不一致，所以不能避免幻读）</p>
<p>在该级别下，在同一个事务内的查询都是和事务开始时刻一致的，保证对同一字段的多次读取结果都相同，除非数据是被本身事务自己所修改，不会出现同一事务读到两次不同数据的情况。因为没有约束其他事务的新增Insert操作，所以 SQL 标准中可重复读级别会出现<strong>幻读</strong>。</p>
<p>值得一提的是，可重复读是 MySQL InnoDB 引擎的默认隔离级别，但是在 MySQL 额外添加了间隙锁（Gap Lock），可以防止幻读。</p>
<h4 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h4><p>该级别要求所有事务都必须串行执行，可以避免各种并发引起的问题，效率也最低。</p>
<p>对不同隔离级别的解释，其实是为了保持数据库事务中的隔离性（Isolation），目标是使并发事务的执行效果与串行一致，隔离级别的提升带来的是并发能力的下降，两者是负相关的关系。</p>
<h3 id="分布式事务产生的原因"><a href="#分布式事务产生的原因" class="headerlink" title="分布式事务产生的原因"></a>分布式事务产生的原因</h3><p>分布式事务是伴随着系统拆分出现的，分布式系统解决了海量数据服务对扩展性的要求，但是增加了架构上的复杂性，在这一点上，分布式事务就是典型的体现。</p>
<p>在实际开发中，分布式事务产生的原因主要来源于<strong>存储和服务的拆分</strong>。</p>
<h4 id="存储层拆分"><a href="#存储层拆分" class="headerlink" title="存储层拆分"></a>存储层拆分</h4><p>存储层拆分，最典型的就是数据库分库分表，一般来说，当单表容量达到千万级，就要考虑数据库拆分，从单一数据库变成多个分库和多个分表。在业务中如果需要进行跨库或者跨表更新，同时要保证数据的一致性，就产生了分布式事务问题。</p>
<img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_03.png" style="zoom:67%;">

<h4 id="服务层拆分"><a href="#服务层拆分" class="headerlink" title="服务层拆分"></a>服务层拆分</h4><p>服务层拆分也就是业务的服务化，系统架构的演进是从集中式到分布式，业务功能之间越来越解耦合。</p>
<p>比如电商网站系统，业务初期可能是一个单体工程支撑整套服务，但随着系统规模进一步变大，参考康威定律，大多数公司都会将核心业务抽取出来，以作为独立的服务。商品、订单、库存、账号信息都提供了各自领域的服务，业务逻辑的执行散落在不同的服务器上。</p>
<p>用户如果在某网站上进行一个下单操作，那么会同时依赖订单服务、库存服务、支付扣款服务，这几个操作如果有一个失败，那下单操作也就完不成，这就需要分布式事务来保证了。</p>
<img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_04.png" style="zoom: 67%;">

<h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><p>分布式事务的解决方案，典型的有<strong>两阶段和三阶段提交协议</strong>、 <strong>TCC 分段提交</strong>，和<strong>基于消息队列的最终一致性</strong>设计。</p>
<h4 id="2PC-两阶段提交"><a href="#2PC-两阶段提交" class="headerlink" title="2PC 两阶段提交"></a>2PC 两阶段提交</h4><p>两阶段提交（2PC，Two-phase Commit Protocol）是非常经典的<strong>强一致性</strong>、<strong>中心化的原子提交协议</strong>，在各种事务和一致性的解决方案中，都能看到两阶段提交的应用。</p>
<p>二阶段提交算法的成立是基于以下假设的：</p>
<ul>
<li>在该分布式系统中，存在一个节点作为<strong>协调者</strong>（Coordinator），其他节点作为<strong>参与者</strong>（Participants），且节点之间可以进行网络通信；</li>
<li>所有节点都采用<strong>预写式</strong>日志，日志被写入后被保存在可靠的存储设备上，即使节点损坏也不会导致日志数据的丢失；</li>
<li>所有节点不会永久性损坏，即使损坏后仍然可以恢复。</li>
</ul>
<p>两阶段提交中的两个阶段，指的是 <strong>Commit-request</strong> 阶段和 <strong>Commit</strong> 阶段，两阶段提交的流程如下：</p>
<p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_07.png" alt></p>
<h5 id="提交请求阶段"><a href="#提交请求阶段" class="headerlink" title="提交请求阶段"></a>提交请求阶段</h5><p>在提交请求阶段，协调者将通知事务参与者准备提交事务，然后进入表决过程。在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地事务执行成功）或取消（本地事务执行故障），在第一阶段，参与节点并没有进行Commit操作。</p>
<h5 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h5><p>在提交阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消这个事务。这个结果的处理和前面基于半数以上投票的一致性算法不同，必须<strong>当且仅当所有的参与者同意提交</strong>，协调者才会通知各个参与者提交事务，否则协调者将通知各个参与者取消事务。</p>
<p>参与者在接收到协调者发来的消息后将执行对应的操作，也就是本地 Commit 或者 Rollback。</p>
<h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h5><p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_08.png" alt></p>
<p>两阶段提交协议有几个明显的问题：</p>
<ul>
<li>资源被同步阻塞<br>在执行过程中，所有参与节点都是事务独占状态，当参与者占有公共资源时，那么第三方节点访问公共资源会被阻塞。</li>
<li>协调者可能出现单点故障<br>一旦协调者发生故障，参与者会一直阻塞下去。</li>
<li>在 Commit 阶段出现数据不一致<br>在第二阶段中，假设协调者发出了事务 Commit 的通知，但是由于网络问题该通知仅被一部分参与者所收到并执行 Commit，其余的参与者没有收到通知，一直处于阻塞状态，那么，这段时间就产生了数据的不一致性。</li>
</ul>
<h4 id="3PC-三阶段提交"><a href="#3PC-三阶段提交" class="headerlink" title="3PC 三阶段提交"></a>3PC 三阶段提交</h4><p>三阶段提交协议（3PC，Three-phase_commit_protocol）是在 2PC 之上扩展的提交协议，主要是为了解决两阶段提交协议的阻塞问题，从原来的两个阶段扩展为三个阶段，增加了超时机制。<strong>并且把两阶段提交协议的第一个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。</strong></p>
<p>三阶段中的 Three Phase 分别为 <strong>CanCommit</strong>、<strong>PreCommit</strong>、<strong>DoCommit</strong> 阶段。</p>
<p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_09.png" alt></p>
<h5 id="CanCommit-阶段"><a href="#CanCommit-阶段" class="headerlink" title="CanCommit 阶段"></a>CanCommit 阶段</h5><p>3PC 的 CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 Commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。</p>
<h5 id="PreCommit-阶段"><a href="#PreCommit-阶段" class="headerlink" title="PreCommit 阶段"></a>PreCommit 阶段</h5><p>协调者根据参与者的反应情况来决定是否可以继续事务的 PreCommit 操作。根据响应情况，有以下两种可能。</p>
<ul>
<li><p>A. 假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会进行事务的预执行：</p>
<p>发送预提交请求，协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段；<br>事务预提交，参与者接收到 PreCommit 请求后，会执行事务操作；<br>响应反馈，如果参与者成功执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。</p>
</li>
<li><p>B. 假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就中断事务：</p>
<p>发送中断请求，协调者向所有参与者发送 abort 请求；<br>中断事务，参与者收到来自协调者的 abort 请求之后，执行事务的中断。</p>
</li>
</ul>
<h5 id="DoCommit-阶段"><a href="#DoCommit-阶段" class="headerlink" title="DoCommit 阶段"></a>DoCommit 阶段</h5><p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p>
<ul>
<li><p>A. 执行提交</p>
<p>发送提交请求。协调者接收到参与者发送的 ACK 响应后，那么它将从预提交状态进入到提交状态，并向所有参与者发送 doCommit 请求。<br>事务提交。参与者接收到 doCommit 请求之后，执行正式的事务提交，并在完成事务提交之后释放所有事务资源。<br>响应反馈。事务提交完之后，向协调者发送 ACK 响应。<br>完成事务。协调者接收到所有参与者的 ACK 响应之后，完成事务。</p>
</li>
<li><p>B. 中断事务<br>协调者没有接收到参与者发送的 ACK 响应，可能是因为接受者发送的不是 ACK 响应，也有可能响应超时了，那么就会执行中断事务。</p>
</li>
<li><p>C.超时提交<br>参与者如果没有收到协调者的通知，超时之后会执行 Commit 操作。</p>
</li>
</ul>
<h5 id="三阶段提交做的改进"><a href="#三阶段提交做的改进" class="headerlink" title="三阶段提交做的改进"></a>三阶段提交做的改进</h5><p><strong>引入超时机制</strong><br>在 2PC 中，只有协调者拥有超时机制，如果在一定时间内没有收到参与者的消息则默认失败，3PC 同时在协调者和参与者中都引入超时机制。</p>
<p><strong>添加预提交阶段</strong><br>在 2PC 的准备阶段和提交阶段之间，插入一个准备阶段，使 3PC 拥有 CanCommit、PreCommit、DoCommit 三个阶段，PreCommit 是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的</p>
<h5 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h5><p>三阶段提交协议同样存在问题，具体表现为，在阶段三中，如果参与者接收到了 PreCommit 消息后，出现了不能与协调者正常通信的问题，在这种情况下，参与者依然会进行事务的提交，这就出现了数据的不一致性。</p>
<h5 id="二阶段和三阶段提交的应用"><a href="#二阶段和三阶段提交的应用" class="headerlink" title="二阶段和三阶段提交的应用"></a>二阶段和三阶段提交的应用</h5><p>两阶段提交是一种比较精简的一致性算法/协议，很多关系型数据库都是采用两阶段提交协议来完成分布式事务处理的，典型的比如 MySQL 的 XA 规范。</p>
<p>在事务处理、数据库和计算机网络中，两阶段提交协议提供了分布式设计中的数据一致性的保障，整个事务的参与者要么一致性全部提交成功，要么全部回滚。MySQL Cluster 内部数据的同步就是用的 2PC 协议。</p>
<p><strong>MySQL 的主从复制</strong><br>    在 MySQL 中，二进制日志是 server 层，主要用来做主从复制和即时点恢复时使用的；而事务日志（Redo Log）是 InnoDB 存储引擎层，用来保证事务安全的。</p>
<p>​    在数据库运行中，需要保证 Binlog 和 Redo Log 的一致性，如果顺序不一致， 则意味着 Master-Slave 可能不一致。</p>
<p>​    在开启 Binlog 后，如何保证 Binlog 和 InnoDB redo 日志的一致性呢？MySQL 使用的就是二阶段提交，内部会自动将普通事务当做一个 XA 事务（内部分布式事务）来处理：</p>
<ul>
<li>Commit 会被自动的分成 Prepare 和 Commit 两个阶段；</li>
<li>Binlog 会被当做事务协调者（Transaction Coordinator），Binlog Event 会被当做协调者日志。</li>
</ul>
<h4 id="TCC-分段提交"><a href="#TCC-分段提交" class="headerlink" title="TCC 分段提交"></a>TCC 分段提交</h4><p>TCC 是一个分布式事务的处理模型，将事务过程拆分为 Try、Confirm、Cancel 三个步骤，在保证强一致性的同时，最大限度提高系统的可伸缩性与可用性。</p>
<p>TCC 提出了一种新的事务模型，基于<strong>业务层面的事务定义</strong>，锁粒度完全由业务自己控制，目的是解决复杂业务中，跨表跨库等大颗粒度资源锁定的问题。TCC 把事务运行过程分成 Try、Confirm / Cancel 两个阶段，每个阶段的逻辑由业务代码控制，避免了长事务，可以获取更高的性能。</p>
<h5 id="TCC-的各个阶段"><a href="#TCC-的各个阶段" class="headerlink" title="TCC 的各个阶段"></a>TCC 的各个阶段</h5><p>TCC 的具体流程如下图所示：</p>
<p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_10.png" alt></p>
<p><strong>Try 阶段</strong>：调用 Try 接口，尝试执行业务，完成所有业务检查，预留业务资源。</p>
<p><strong>Confirm 或 Cancel 阶段</strong>：两者是互斥的，只能进入其中一个，并且都满足幂等性，允许失败重试。</p>
<ul>
<li>Confirm 操作：对业务系统做确认提交，确认执行业务操作，不做其他业务检查，只使用 Try 阶段预留的业务资源。</li>
<li>Cancel 操作：在业务执行错误，需要回滚的状态下执行业务取消，释放预留资源。<br>Try 阶段失败可以 Cancel，如果 Confirm 和 Cancel 阶段失败了怎么办？</li>
</ul>
<p>TCC 中会添加事务日志，如果 Confirm 或者 Cancel 阶段出错，则会进行重试，所以这两个阶段需要支持幂等；如果重试失败，则需要人工介入进行恢复和处理等。</p>
<h5 id="应用-TCC-的优缺点"><a href="#应用-TCC-的优缺点" class="headerlink" title="应用 TCC 的优缺点"></a>应用 TCC 的优缺点</h5><p>实际开发中，TCC 的本质是把数据库的二阶段提交上升到微服务来实现，从而避免数据库二阶段中长事务引起的低性能风险。</p>
<p>所以说，TCC 解决了跨服务的业务操作原子性问题，比如下订单减库存，多渠道组合支付等场景，通过 TCC 对业务进行拆解，可以让应用自己定义数据库操作的粒度，可以降低锁冲突，提高系统的业务吞吐量。</p>
<p>TCC 的不足主要体现在对微服务的<strong>侵入性强</strong>，TCC 需要对业务系统进行改造，业务逻辑的每个分支都需要实现 try、Confirm、Cancel 三个操作，并且 Confirm、Cancel 必须保证幂等。</p>
<p>另外 TCC 的事务管理器要记录事务日志，也会损耗一定的性能。</p>
<h5 id="从真实业务场景分析-TCC"><a href="#从真实业务场景分析-TCC" class="headerlink" title="从真实业务场景分析 TCC"></a>从真实业务场景分析 TCC</h5><p>下面以一个电商中的支付业务来演示，用户在支付以后，需要进行更新订单状态、扣减账户余额、增加账户积分和扣减商品操作。</p>
<p>在实际业务中为了防止超卖，有下单减库存和付款减库存的区别，支付除了账户余额，还有各种第三方支付等，这里我们为了描述方便，统一使用扣款减库存，扣款来源是用户账户余额。</p>
<p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_11.png" alt></p>
<p><strong>业务逻辑拆解</strong></p>
<p>我们把订单业务拆解为以下几个步骤：</p>
<ul>
<li>订单更新为支付完成状态</li>
<li>扣减用户账户余额</li>
<li>增加用户账户积分</li>
<li>扣减当前商品的库存</li>
</ul>
<p>​    如果不使用事务，上面的几个步骤都可能出现失败，最终会造成大量的数据不一致，比如订单状态更新失败，扣款却成功了；或者扣款失败，库存却扣减了等情况，这个在业务上是不能接受的，会出现大量的客诉。</p>
<p>如果直接应用事务，不使用分布式事务，比如在代码中添加 Spring 的声明式事务 @Transactional 注解，这样做实际上是在事务中嵌套了远程服务调用，一旦服务调用出现超时，事务无法提交，就会导致数据库连接被占用，出现大量的阻塞和失败，会导致服务宕机。另一方面，如果没有定义额外的回滚操作，比如遇到异常，非 DB 的服务调用失败时，则无法正确执行回滚。</p>
<p><strong>业务系统改造</strong></p>
<p>下面应用 TCC 事务，需要对业务代码改造，抽象 Try、Confirm 和 Cancel 阶段。</p>
<p><strong>Try 操作</strong><br>    Try 操作一般都是锁定某个资源，设置一个预备的状态，冻结部分数据。比如，订单服务添加一个预备状态，修改为 UPDATING，也就是更新中的意思，冻结当前订单的操作，而不是直接修改为支付成功。</p>
<p>​    库存服务设置冻结库存，可以扩展字段，也可以额外添加新的库存冻结表。积分服务和库存一样，添加一个预增加积分，比如本次订单积分是 100，添加一个额外的存储表示等待增加的积分，账户余额服务等也是一样的操作。</p>
<p><strong>Confirm 操作</strong><br>    Confirm 操作就是把前边的 Try 操作锁定的资源提交，类比数据库事务中的 Commit 操作。在支付的场景中，包括订单状态从准备中更新为支付成功；库存数据扣减冻结库存，积分数据增加预增加积分。</p>
<p><strong>Cancel 操作</strong><br>    Cancel 操作执行的是业务上的回滚处理，类比数据库事务中的 Rollback 操作。首先订单服务，撤销预备状态，还原为待支付状态或者已取消状态，库存服务删除冻结库存，添加到可销售库存中，积分服务也是一样，将预增加积分扣减掉。</p>
<p><strong>执行业务操作</strong></p>
<p>​    下面来分析业务的实际执行操作，首先业务请求过来，开始执行 Try 操作，如果 TCC 分布式事务框架感知到各个服务的 Try 阶段都成功了以后，就会执行各个服务的 Confirm 逻辑。</p>
<p>如果 Try 阶段有操作不能正确执行，比如订单失效、库存不足等，就会执行 Cancel 的逻辑，取消事务提交。</p>
<h5 id="TCC-对比-2PC-两阶段提交"><a href="#TCC-对比-2PC-两阶段提交" class="headerlink" title="TCC 对比 2PC 两阶段提交"></a>TCC 对比 2PC 两阶段提交</h5><p>TCC 事务模型的思想类似 2PC 提交，对比 TCC 和基于 2PC 事务 XA 规范：</p>
<p><strong>对比 2PC 提交</strong></p>
<p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_12.png" alt></p>
<p><strong>第一阶段</strong><br>    在 XA 事务中，各个 RM 准备提交各自的事务分支，事实上就是准备提交资源的更新操作（insert、delete、update 等）；而在 TCC 中，是主业务操作请求各个子业务服务预留资源。</p>
<p><strong>第二阶段</strong><br>    XA 事务根据第一阶段每个 RM 是否都 prepare 成功，判断是要提交还是回滚。如果都 prepare 成功，那么就 commit 每个事务分支，反之则 rollback 每个事务分支。</p>
<p>​    在 TCC 中，如果在第一阶段所有业务资源都预留成功，那么进入 Confirm 步骤，提交各个子业务服务，完成实际的业务处理，否则进入 Cancel 步骤，取消资源预留请求。</p>
<p><strong>与 2PC/XA 两阶段提交的区别</strong></p>
<p>​    2PC/XA 是数据库或者存储资源层面的事务，实现的是强一致性，在两阶段提交的整个过程中，一直会持有数据库的锁。<br>​    TCC 关注业务层的正确提交和回滚，在 Try 阶段不涉及加锁，是业务层的分布式事务，关注最终一致性，不会一直持有各个业务资源的锁。<br>​    TCC 的核心思想是针对每个业务操作，都要添加一个与其对应的确认和补偿操作，同时把相关的处理，从数据库转移到业务中，以此实现跨数据库的事务。</p>
<h5 id="TCC-分布式服务组件"><a href="#TCC-分布式服务组件" class="headerlink" title="TCC 分布式服务组件"></a>TCC 分布式服务组件</h5><p>在业务中引入 TCC 一般是依赖单独的 TCC 事务框架，可以选择自研或者应用开源组件。TCC 框架扮演了资源管理器的角色，常用的 TCC 开源组件有 Tcc-transaction、ByteTCC、Spring-cloud-rest-tcc 等。</p>
<p>前面介绍过的 Seata，可以选择 <strong>TCC 事务模式</strong>，也支持了 <strong>AT 模式</strong>及 <strong>Saga 模式</strong>。（这俩种模式及框架解决方案可自行查阅）</p>
<h4 id="基于消息补偿的最终一致性"><a href="#基于消息补偿的最终一致性" class="headerlink" title="基于消息补偿的最终一致性"></a>基于消息补偿的最终一致性</h4><p>异步化在分布式系统设计中随处可见，基于消息队列的最终一致性就是一种异步事务机制，在业务中广泛应用。</p>
<p>在具体实现上，基于消息补偿的一致性主要有<strong>本地消息表</strong>和<strong>第三方可靠消息队列</strong>等。</p>
<h5 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h5><p>本地消息表的方案最初是由 ebay 的工程师提出，核心思想是将分布式事务拆分成本地事务进行处理，通过消息日志的方式来异步执行。</p>
<p>本地消息表是一种业务耦合的设计，消息生产方需要额外建一个事务消息表，并记录消息发送状态，消息消费方需要处理这个消息，并完成自己的业务逻辑，另外会有一个异步机制来定期扫描未完成的消息，确保最终一致性。</p>
<p>下面我们用下单减库存业务来简单模拟本地消息表的实现过程：</p>
<p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_05.png" alt></p>
<p>（1）系统收到下单请求，将订单业务数据存入到订单库中，并且同时存储该订单对应的消息数据，比如购买商品的 ID 和数量，消息数据与订单库为同一库，更新订单和存储消息为一个本地事务，要么都成功，要么都失败。</p>
<p>（2）库存服务通过消息中间件收到库存更新消息，调用库存服务进行业务操作，同时返回业务处理结果。</p>
<p>（3）消息生产方，也就是订单服务收到处理结果后，将本地消息表的数据删除或者设置为已完成。</p>
<p>（4）设置异步任务，定时去扫描本地消息表，发现有未完成的任务则重试，保证最终一致性。</p>
<p>以上就是基于本地消息表一致性的主流程，在具体实践中，还有许多分支情况，比如消息发送失败、下游业务方处理失败等。</p>
<h5 id="不要求最终一致性的柔性事务"><a href="#不要求最终一致性的柔性事务" class="headerlink" title="不要求最终一致性的柔性事务"></a>不要求最终一致性的柔性事务</h5><p>除了上述几种，还有一种不保证最终一致性的柔性事务，也称为尽最大努力通知，这种方式适合可以接受部分不一致的业务场景。</p>
<h3 id="分布式事务有哪些开源组件"><a href="#分布式事务有哪些开源组件" class="headerlink" title="分布式事务有哪些开源组件"></a>分布式事务有哪些开源组件</h3><p>分布式事务开源组件应用比较广泛的是蚂蚁金服开源的 <strong>Seata</strong>，也就是 <strong>Fescar</strong>，前身是阿里中间件团队发布的 TXC（Taobao Transaction Constructor）和升级后的 GTS（Global Transaction Service）。</p>
<p><img src="/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/transaction_06.png" alt></p>
<p>Seata 的设计思想是把一个分布式事务拆分成一个包含了若干分支事务（Branch Transaction）的全局事务（Global Transaction）。分支事务本身就是一个满足 ACID 的 本地事务，全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚。 </p>
<p>在 Seata 中，全局事务对分支事务的协调基于两阶段提交协议，类似数据库中的 XA 规范，XA 规范定义了三个组件来协调分布式事务，分别是 AP 应用程序、TM 事务管理器、RM 资源管理器、CRM 通信资源管理器。关于 XA 规范的详细内容，将会在后面的课时中介绍。</p>
<p><strong>以上学习内容均来自邴越老师《分布式技术原理与实战》课程，用于学习记录，希望大家共同进步，欧耶。</strong></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式架构之分布式锁</title>
    <url>/2020/06/10/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h3 id="分布式锁应用场景"><a href="#分布式锁应用场景" class="headerlink" title="分布式锁应用场景"></a>分布式锁应用场景</h3><p>​    电商网站都会遇到秒杀、特价之类的活动，大促活动有一个共同特点就是访问量激增，在高并发下会出现成千上万人抢购一个商品的场景。虽然在系统设计时会通过限流、异步、排队等方式优化，但整体的并发还是平时的数倍以上，参加活动的商品一般都是限量库存，如何防止库存超卖，避免并发问题呢？分布式锁就是一个解决方案。</p>
<h3 id="如何理解分布式锁"><a href="#如何理解分布式锁" class="headerlink" title="如何理解分布式锁"></a>如何理解分布式锁</h3><p>​    在业务开发中，为了保证在多线程下处理共享数据的安全性，需要保证同一时刻只有一个线程能处理共享数据。</p>
<p>​    <strong>Java</strong> 语言给我们提供了线程锁，开放了处理锁机制的 API，比如 <strong>Synchronized</strong>、<strong>Lock</strong> 等。当一个锁被某个线程持有的时候，另一个线程尝试去获取这个锁会失败或者阻塞，直到持有锁的线程释放了该锁。</p>
<p>在单台服务器内部，可以通过线程加锁的方式来同步，避免并发问题，那么在分布式场景下呢？</p>
<p><img src="/2020/06/10/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/lock_01.png" alt></p>
<p>​    分布式场景下解决并发问题，需要应用分布式锁技术。如上图所示，分布式锁的目的是保证在分布式部署的应用集群中，多个服务在请求同一个方法或者同一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行，避免出现并发问题。</p>
<h3 id="分布式锁的常用实现"><a href="#分布式锁的常用实现" class="headerlink" title="分布式锁的常用实现"></a>分布式锁的常用实现</h3><h5 id="一个完备的分布式锁，需要支持哪些特性？"><a href="#一个完备的分布式锁，需要支持哪些特性？" class="headerlink" title="一个完备的分布式锁，需要支持哪些特性？"></a>一个完备的分布式锁，需要支持哪些特性？</h5><p><img src="/2020/06/10/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/lock_03.png" alt></p>
<p>一般来说，生产环境可用的分布式锁需要满足以下几点：</p>
<ul>
<li>互斥性，互斥是锁的基本特征，同一时刻只能有一个线程持有锁，执行临界操作；</li>
<li>超时释放，超时释放是锁的另一个必备特性，可以对比 MySQL InnoDB 引擎中的 innodb_lock_wait_timeout 配置，通过超时释放，防止不必要的线程等待和资源浪费；</li>
<li>可重入性，在分布式环境下，同一个节点上的同一个线程如果获取了锁之后，再次请求还是可以成功；</li>
<li>高性能和高可用，加锁和解锁的开销要尽可能的小，同时也需要保证高可用，防止分布式锁失效；</li>
<li>支持阻塞和非阻塞性，对比 Java 语言中的 wait() 和 notify() 等操作，这个一般是在业务代码中实现，比如在获取锁时通过 while(true) 或者轮询来实现阻塞操作。</li>
</ul>
<p>​    可以看到，实现一个相对完备的分布式锁，并不是锁住资源就可以了，还需要满足一些额外的特性，否则会在业务开发中出现各种各样的问题。</p>
<p>实现分布式锁目前有三种流行方案，即基于<strong>数据库</strong>、<strong>Redis</strong>、<strong>ZooKeeper</strong> 的方案。</p>
<h4 id="基于关系型数据库"><a href="#基于关系型数据库" class="headerlink" title="基于关系型数据库"></a>基于关系型数据库</h4><p>​    基于关系型数据库实现分布式锁，是依赖数据库的唯一性来实现资源锁定，比如主键和唯一索引等。</p>
<p>​    以唯一索引为例，创建一张锁表，定义方法或者资源名、失效时间等字段，同时针对加锁的信息添加唯一索引，比如方法名，当要锁住某个方法或资源时，就在该表中插入对应方法的一条记录，插入成功表示获取了锁，想要释放锁的时候就删除这条记录。</p>
<p>下面创建一张基于数据库的分布式锁表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line"><span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法或者资源'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'对方法加锁'</span>;</span><br></pre></td></tr></table></figure>

<p>当希望对某个方法加锁时，执行以下 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name) <span class="keyword">values</span> (<span class="string">'method_name'</span>);</span><br></pre></td></tr></table></figure>

<p>​    在数据表定义中，我们对 <strong>method_name</strong> 做了唯一性约束，如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么就可以认为操作成功的那个线程获得了该方法的锁，可以执行后面的业务逻辑。</p>
<p>当方法执行完毕之后，想要释放锁的话，在数据库中删除对应的记录即可。</p>
<p>基于数据库实现分布式锁操作简单，<strong>但是并不是一个可以落地的方案，有很多地方需要优化</strong>。</p>
<ul>
<li><p><strong>存在单点故障风险</strong></p>
<p>数据库实现方式强依赖数据库的可用性，一旦数据库挂掉，则会导致业务系统不可用，为了解决这个问题，需要配置数据库主从机器，防止单点故障。</p>
</li>
<li><p><strong>超时无法失效</strong></p>
<p>如果一旦解锁操作失败，则会导致锁记录一直在数据库中，其他线程无法再获得锁，解决这个问题，可以添加独立的定时任务，通过时间戳对比等方式，删除超时数据。</p>
</li>
<li><p><strong>不可重入</strong></p>
<p>可重入性是锁的一个重要特性，以 Java 语言为例，常见的 <strong>Synchronize</strong>、<strong>Lock</strong> 等都支持可重入。在数据库实现方式中，同一个线程在没有释放锁之前无法再次获得该锁，因为数据已经存在，再次插入会失败。实现可重入，需要改造加锁方法，额外存储和判断线程信息，不阻塞获得锁的线程再次请求加锁。</p>
</li>
<li><p><strong>无法实现阻塞</strong></p>
<p>其他线程在请求对应方法时，插入数据失败会直接返回，不会阻塞线程，如果需要阻塞其他线程，需要不断的重试 insert 操作，直到数据插入成功，这个操作是服务器和数据库资源的极大浪费。</p>
<p>可以看到，借助数据库实现一个完备的分布式锁，存在很多问题，并且读写数据库需要一定的性能，可能会影响业务执行的耗时。</p>
</li>
</ul>
<h4 id="基于Redis实现"><a href="#基于Redis实现" class="headerlink" title="基于Redis实现"></a>基于Redis实现</h4><p>​    相比基于数据库实现分布式锁，缓存的性能更好，并且各种缓存组件也提供了多种集群方案，可以解决单点问题。</p>
<p>​    常见的开源缓存组件都支持分布式锁，包括 Redis、Memcached 及 Tair。以常见的 Redis 为例，应用 Redis 实现分布式锁，最直接的想法是利用 <strong>setnx</strong> 和 <strong>expire</strong> 命令实现加锁。</p>
<h5 id="使用-setnx-实现分布式锁"><a href="#使用-setnx-实现分布式锁" class="headerlink" title="使用 setnx 实现分布式锁"></a>使用 setnx 实现分布式锁</h5><p>​    Redis 支持 setnx 指令，只在 key 不存在的情况下，将 key 的值设置为 value，若 key 已经存在，则 setnx 命令不做任何动作。使用 setnx 实现分布式锁的方案，获取锁的方法很简单，只要以该锁为 key，设置一个随机的值即可。如果 setnx 返回 1，则说明该进程获得锁；如果 setnx 返回 0，则说明其他进程已经获得了锁，进程不能进入临界区；如果需要阻塞当前进程，可以在一个循环中不断尝试 setnx 操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(setnx(key,value)==<span class="number">1</span>)&#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//业务处理</span></span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">       <span class="comment">//释放锁</span></span><br><span class="line">       del(key)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    释放锁时只要删除对应的 key 就可以，为了防止系统业务进程出现异常导致锁无法释放，使用 Java 中的 try-catch-finally 来完成锁的释放。</p>
<p>​    对比一下上面说的分布式锁特性，使用这种方式实现分布式锁的问题很明显：<strong>不支持超时释放锁</strong>，如果进程在加锁后宕机，则会导致锁无法删除，其他进程无法获得锁。</p>
<h5 id="使用-setnx-和-expire-实现"><a href="#使用-setnx-和-expire-实现" class="headerlink" title="使用 setnx 和 expire 实现"></a>使用 setnx 和 expire 实现</h5><p>​    在分布式锁的实现中，依赖业务线程进行锁的释放，如果进程宕机，那么就会出现死锁。Redis 在设置一个 key 时，支持设置过期时间，利用这一点，可以在缓存中实现锁的超时释放，解决死锁问题。</p>
<p>在使用 setnx 获取锁之后，通过 expire 给锁加一个过期时间，利用 Redis 的缓存失效策略，进行锁的超时清除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(setnx(key,value)==<span class="number">1</span>)&#123;</span><br><span class="line">     expire(key,expireTime)</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//业务处理</span></span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">       <span class="comment">//释放锁</span></span><br><span class="line">       del(key)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过设置过期时间，避免了占锁到释放锁的过程发生异常而导致锁无法释放的问题，但是在 Redis 中，setnx 和 expire 这两条命令不具备原子性。如果一个线程在执行完 setnx 之后突然崩溃，导致锁没有设置过期时间，那么这个锁就会一直存在，无法被其他线程获取。</p>
<h5 id="使用-set-扩展命令实现"><a href="#使用-set-扩展命令实现" class="headerlink" title="使用 set 扩展命令实现"></a>使用 set 扩展命令实现</h5><p>为了解决这个问题，在 Redis 2.8 版本中，扩展了 set 命令，支持 set 和 expire 指令组合的原子操作，解决了加锁过程中失败的问题。</p>
<p>set 扩展参数的语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET key value expireTime nx</span></span><br></pre></td></tr></table></figure>

<p><strong>nx</strong> 表示仅在键不存在时设置，这样可以在同一时间内完成设置值和设置过期时间这两个操作，防止设置过期时间异常导致的死锁。那么这种方式还存在问题吗？</p>
<p>​    使用 setex 方式看起来解决了锁超时的问题，但在实际业务中，如果对超时时间设置不合理，存在这样一种可能：在加锁和释放锁之间的业务逻辑执行的太长，以至于超出了锁的超时限制，缓存将对应 key 删除，其他线程可以获取锁，出现对加锁资源的并发操作。</p>
<p>我们来模拟下这种情况：</p>
<ul>
<li>客户端 A 获取锁的时候设置了 key 的过期时间为 2 秒，客户端 A 在获取到锁之后，业务逻辑方法执行了 3 秒；</li>
<li>客户端 A 获取的锁被 Redis 过期机制自动释放，客户端 B 请求锁成功，出现并发执行；</li>
<li>客户端 A 执行完业务逻辑后，释放锁，删除对应的 key；</li>
<li>对应锁已经被客户端 B 获取到了，客户端A释放的锁实际是客户端B持有的锁。</li>
</ul>
<p>​    可以看到，第一个线程的逻辑还没执行完，第二个线程也成功获得了锁，加锁的代码或者资源并没有得到严格的串行操作，同时由于叠加了删除和释放锁操作，导致了加锁的混乱。</p>
<p>​    如何避免这个问题呢？首先，基于 Redis 的分布式锁一般是用于耗时比较短的瞬时性任务，业务上超时的可能性较小；其次，在获取锁时，可以设置 value 为一个随机数，在释放锁时进行读取和对比，确保释放的是当前线程持有的锁，一般是通过 Redis 结合 Lua 脚本的方案实现；最后，需要添加完备的日志，记录上下游数据链路，当出现超时，则需要检查对应的问题数据，并且进行人工修复。</p>
<h5 id="分布式锁的高可用"><a href="#分布式锁的高可用" class="headerlink" title="分布式锁的高可用"></a>分布式锁的高可用</h5><p>​    上面分布式锁的实现方案中，都是针对单节点 Redis 而言的，在生产环境中，为了保证高可用，避免单点故障，通常会使用 Redis 集群。</p>
<h5 id="集群下分布式锁存在哪些问题"><a href="#集群下分布式锁存在哪些问题" class="headerlink" title="集群下分布式锁存在哪些问题"></a>集群下分布式锁存在哪些问题</h5><p>​    集群环境下，Redis 通过<strong>主从复制</strong>来实现数据同步，Redis 的主从复制（Replication）是异步的，所以单节点下可用的方案在集群的环境中可能会出现问题，在故障转移（Failover） 过程中丧失锁的安全性。</p>
<p>​    由于 Redis 集群数据同步是异步的，假设 Master 节点获取到锁后在未完成数据同步的情况下，发生节点崩溃，此时在其他节点依然可以获取到锁，出现多个客户端同时获取到锁的情况。</p>
<p>我们模拟下这个场景，按照下面的顺序执行：</p>
<ul>
<li>客户端 A 从 Master 节点获取锁；</li>
<li>Master 节点宕机，主从复制过程中，对应锁的 key 还没有同步到 Slave 节点上；</li>
<li>Slave 升级为 Master 节点，于是集群丢失了锁数据；</li>
<li>其他客户端请求新的 Master 节点，获取到了对应同一个资源的锁；</li>
<li>出现多个客户端同时持有同一个资源的锁，不满足锁的互斥性。</li>
</ul>
<p>可以看到，<strong>单实例场景和集群环境实现分布式锁是不同的</strong>，关于集群下如何实现分布式锁，Redis 的作者 Antirez（Salvatore Sanfilippo）提出了 Redlock 算法，我们一起看一下。</p>
<h5 id="Redlock-算法的流程"><a href="#Redlock-算法的流程" class="headerlink" title="Redlock 算法的流程"></a>Redlock 算法的流程</h5><p>Redlock 算法是在单 Redis 节点基础上引入的高可用模式，Redlock 基于 N 个完全独立的 Redis 节点，一般是大于 3 的奇数个（通常情况下 N 可以设置为 5），可以基本保证集群内各个节点不会同时宕机。</p>
<p>假设当前集群有 5 个节点，运行 Redlock 算法的客户端依次执行下面各个步骤，来完成获取锁的操作：</p>
<ul>
<li><p>客户端记录当前系统时间，以毫秒为单位；</p>
</li>
<li><p>依次尝试从 5 个 Redis 实例中，使用相同的 key 获取锁，当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，超时时间应该小于锁的失效时间，避免因为网络故障出现的问题；</p>
</li>
<li><p>客户端使用当前时间减去开始获取锁时间就得到了获取锁使用的时间，当且仅当从半数以上的 Redis 节点获取到锁，并且当使用的时间小于锁失效时间时，锁才算获取成功；</p>
</li>
<li><p>如果获取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间，减少超时的几率；</p>
</li>
<li><p>如果获取锁失败，客户端应该在所有的 Redis 实例上进行解锁，即使是上一步操作请求失败的节点，防止因</p>
<p>服务端响应消息丢失，但是实际数据添加成功导致的不一致。</p>
</li>
</ul>
<p>在 Redis 官方推荐的 Java 客户端 Redisson 中，内置了对 RedLock 的实现。</p>
<p>分布式系统设计是实现复杂性和收益的平衡，考虑到集群环境下的一致性问题，也要避免过度设计。在实际业务中，一般使用基于单点的 Redis 实现分布式锁就可以，出现数据不一致，通过人工手段去回补。</p>
<h4 id="基于-ZooKeeper-实现"><a href="#基于-ZooKeeper-实现" class="headerlink" title="基于 ZooKeeper 实现"></a>基于 ZooKeeper 实现</h4><p>​    ZooKeeper 有四种节点类型，包括<strong>持久节点</strong>、<strong>持久顺序节点</strong>、<strong>临时节点</strong>和<strong>临时顺序节点</strong>，利用 ZooKeeper 支持临时顺序节点的特性，可以实现分布式锁。</p>
<p>当客户端对某个方法加锁时，在 ZooKeeper 中该方法对应的指定节点目录下，生成一个唯一的临时有序节点。</p>
<p><img src="/2020/06/10/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/lock_02.png" alt></p>
<p>​    判断是否获取锁，只需要判断持有的节点是否是有序节点中序号最小的一个，当释放锁的时候，将这个临时节点删除即可，这种方式可以避免服务宕机导致的锁无法释放而产生的死锁问题。</p>
<p>下面描述使用 ZooKeeper 实现分布式锁的算法流程，根节点为 /lock：</p>
<ul>
<li>客户端连接 ZooKeeper，并在 /lock 下创建临时有序子节点，第一个客户端对应的子节点为 /lock/lock01/00000001，第二个为 /lock/lock01/00000002；</li>
<li>其他客户端获取 /lock01 下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；</li>
<li>如果是则认为获得锁，执行业务代码，否则通过 watch 事件监听 /lock01 的子节点变更消息，获得变更通知后重复此步骤直至获得锁；</li>
<li>完成业务流程后，删除对应的子节点，释放分布式锁。</li>
</ul>
<p>特点：</p>
<ul>
<li>Zookeeper 唯一特性保证锁的互斥性。</li>
<li>ZooKeeper节点的递增有序性，可以确保锁的公平。</li>
<li>临时节点可以保证超时释放。</li>
<li>ZooKeeper的节点监听机制，能避免羊群效应，每一个等通知的Znode节点，只需要监听（linsten）或者监视（watch）排号在自己前面那个，而且紧挨在自己前面的那个节点，就能收到其删除事件了。<br>只要上一个节点被删除了，就进行再一次判断，看看自己是不是序号最小的那个节点，如果是，自己就获得锁。</li>
</ul>
<p>在实际开发中，可以应用 Apache Curator 来快速实现分布式锁，Curator 是 Netflix 公司开源的一个 ZooKeeper 客户端，对 ZooKeeper 原生 API 做了抽象和封装。</p>
<p><strong>以上学习内容均来自邴越老师《分布式技术原理与实战》课程，用于学习记录，希望大家共同进步，欧耶。</strong></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>复习计划</title>
    <url>/2021/01/05/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><ul>
<li><h4 id="Java知识点复习"><a href="#Java知识点复习" class="headerlink" title="Java知识点复习"></a>Java知识点复习</h4></li>
<li><h4 id="常用算法积累"><a href="#常用算法积累" class="headerlink" title="常用算法积累"></a>常用算法积累</h4></li>
<li><h4 id="现有项目理解"><a href="#现有项目理解" class="headerlink" title="现有项目理解"></a>现有项目理解</h4></li>
<li><h4 id="面试准备（目标公司、部门，面试题，时间安排）"><a href="#面试准备（目标公司、部门，面试题，时间安排）" class="headerlink" title="面试准备（目标公司、部门，面试题，时间安排）"></a>面试准备（目标公司、部门，面试题，时间安排）</h4></li>
</ul>
<h2 id="Java复习知识点"><a href="#Java复习知识点" class="headerlink" title="Java复习知识点"></a>Java复习知识点</h2><ul>
<li><p>操作系统与计算机网络</p>
</li>
<li><p>Java语言特性与设计模式</p>
</li>
<li><p>深入浅出JVM</p>
</li>
<li><p>并发与多线程</p>
</li>
<li><p>数据结构与算法</p>
</li>
<li><p>常用工具集</p>
</li>
<li><p>必会框架：Spring全家桶、RPC与ORM、Netty等</p>
</li>
<li><p>缓存（Redis、MonggoDB）</p>
</li>
<li><p>消息队列</p>
</li>
<li><p>Mysql调优（Oracle、PostgreSQL）</p>
</li>
<li><p>架构演进与前言技术（理念）</p>
</li>
<li><p>微服务、云原生（结合项目）</p>
</li>
</ul>
<h3 id="操作系统与计算机网络"><a href="#操作系统与计算机网络" class="headerlink" title="操作系统与计算机网络"></a>操作系统与计算机网络</h3><h5 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a><a href="http://blogsea.cn/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">操作系统</a></h5><ol>
<li>计算机组成原理：冯 · 诺依曼 模型、CPU亲和性、CPU位宽、程序执行过程、存储器分级（寄存器、L1\L2\L3 、内存、SSD）等</li>
<li>Linux指令入门：常用Linux命令( 网络、权限、日志操作)、（grep/sed/awk)</li>
<li>操作系统基础知识：内核、用户态与内核态、中断与中断向量、各操作系统区别、操作系统常用基础知识</li>
<li>进程与线程：区别联系、线程调度（切换、并发、协同）、进程调度（IPC）、协程</li>
<li>内存管理：内存分页管理与swap</li>
</ol>
<h5 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><a href="http://blogsea.cn/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="noopener">计算机网络</a></h5><ol>
<li>网络模型：4/7层网络模型</li>
<li>TCP协议：三次握手、四次挥手、滑动窗口与流量控制</li>
<li>UDP协议：优缺点，对比</li>
<li>HTTP协议：组成、状态码、https与http2</li>
<li>I/O模型：阻塞IO、非阻塞IO、IO复用、信号驱动IO、异步IO</li>
<li>I/O多路复用模型：select / poll / epoll 区别</li>
<li>虚拟化（了解）</li>
</ol>
<h3 id="Java语言特性与设计模式"><a href="#Java语言特性与设计模式" class="headerlink" title="Java语言特性与设计模式"></a>Java语言特性与设计模式</h3><h5 id="Java语言特性"><a href="#Java语言特性" class="headerlink" title="Java语言特性"></a><a href="http://blogsea.cn/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">Java语言特性</a></h5><ol>
<li>数据类型：空间占用、基本数据结构、拆箱装箱、自动转型与常用转型、特殊类型场景（String、Interge等）</li>
<li>对象引用：几种引用类型、Java类的特性</li>
<li>动态代理与反射</li>
<li>JUC：Java并发工具包</li>
<li>常用集合：Map（ConcurrentHashMap）、List、Set等</li>
<li>异常机制：异常处理、全局异常捕捉</li>
<li>注解机制：jdk内置注解，元注解，自定义注解</li>
<li>Jdk 版本差异与新特性：7、8、9、11</li>
</ol>
<h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><a href>设计模式</a></h5><p>设计模式分为 3 大类型共 23 种：</p>
<ul>
<li><strong>创建型</strong>：<strong>对象实例化的模式，创建型模式用于解耦对象的实例化过程。</strong>有工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>
<li><strong>结构型</strong>：<strong>把类或对象结合在一起形成一个更大的结构。</strong>有适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li><strong>行为型</strong>：<strong>类和对象如何交互，及划分责任和算法。</strong>策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ul>
<p>提炼出最常见设计模式详细了解，主要分为俩个方向：</p>
<p>​        –    了解设计模式的实现</p>
<p>​        –    列举设计模式使用场景（框架）</p>
<p>最常见设计模式：</p>
<ul>
<li>单例模式（几种方式、线程安全）</li>
<li>工厂模式（Spring创建Bean）</li>
<li>代理模式（AOP）</li>
<li>建造者模式（Mybatis）</li>
<li>责任链模式（）</li>
<li>适配器模式（Slf4j 如何支持Log4J）</li>
<li>观察者模式</li>
</ul>
<h5 id="深入浅出jvm"><a href="#深入浅出jvm" class="headerlink" title="深入浅出jvm"></a><a href="http://blogsea.cn/2021/02/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJVM/" target="_blank" rel="noopener">深入浅出jvm</a></h5><ol>
<li>内存模型：程序计数器、方法区、堆、栈、本地方法栈。</li>
<li>JMM：Java内存模型；</li>
<li>类加载：双亲委派、Bootstrap类加载器、Extension类加载器、System类加载器、自定义类加载器</li>
<li>GC：分代回收、回收器</li>
<li>编译器优化：指令重排</li>
<li>性能调优：JVM参数、性能分析工具：jstat、jstack、JMC、MAT</li>
</ol>
<h5 id="并发与多线程（一）"><a href="#并发与多线程（一）" class="headerlink" title="并发与多线程（一）"></a><a href="http://blogsea.cn/2021/02/08/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">并发与多线程（一）</a></h5><h5 id="并发与多线程（二）"><a href="#并发与多线程（二）" class="headerlink" title="并发与多线程（二）"></a><a href="http://blogsea.cn/2021/02/08/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="noopener">并发与多线程（二）</a></h5><ol>
<li>线程创建，线程状态切换，线程生命周期；</li>
<li>线程常用方法；</li>
<li>详解同步和互斥：synchronized、Lock、CAS;</li>
<li>详解Java多线程机制：例如ThreadLocal线程独享，Fork/join 大任务拆分机制，Volatile 保证数据可见性原理，Interrupt 中断机制等。</li>
<li>详解Java线程池的使用。</li>
<li>Java多线程处理工具类（JUC）：ConcurrentXXX、AtomicXXX、CopyOnWriteArrayList、ConcurrentHashMap等。</li>
</ol>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p><strong>数据结构：</strong></p>
<ol>
<li>队列</li>
<li>栈</li>
<li>表：数组、单链表、双链表、循环链表、散列表</li>
<li>图：有向图、无向图、带权图</li>
<li>二叉树：平衡二叉树、红黑树、哈夫曼树、堆</li>
<li>多叉树：B\B+树、字典树</li>
</ol>
<p><strong>算法：</strong></p>
<ol>
<li>常用算法思路</li>
<li>复杂度：时间、空间</li>
<li>字符串匹配：</li>
<li>排序：选择、交换、插入、</li>
<li>查找：二叉查找、二叉树排序、B树等</li>
</ol>
<h3 id="常用工具集"><a href="#常用工具集" class="headerlink" title="常用工具集"></a>常用工具集</h3><ul>
<li>团队协作：Ant、Maven、Gradle、Git、SVN</li>
<li>质量保证：CheckStyle、FindBugs、SonarQube、</li>
<li>压测：JMeter、JMH、AB、LoadRunner</li>
<li>容器与代理：Tomcat、Jetty、Nginx、Envoy、</li>
<li>CI/CD: Gitlab-CI、Jenkins、Travls、CircleCI</li>
<li>JVM工具：JMC、jstack、jmap、jstat、jinfo、jcmd、btrace、MAT</li>
<li>系统分析：vmstat、lostat &amp; lotop、ifstat &amp; iftop 、netstat、dstat、strace、GDB、losf、tcpdump、traceroute</li>
<li>文档管理：javaDoc、Swagger</li>
<li>网络工具：PostMan、WireShark、Fiddler、Charles</li>
</ul>
<h3 id="必会框架"><a href="#必会框架" class="headerlink" title="必会框架"></a>必会框架</h3><ul>
<li><p>Spring 主要知识点：</p>
<ul>
<li>Spring Framework  ：IOC、Context、Bean 管理、AOP、动态代理SpringMVC</li>
<li>SpringBoot：常用注解、自动配置、约定大于配置</li>
<li>SpringData：JDBC、Redis、MonggoDB等相关数据源操作</li>
<li>SpringCloud：微服务解决方案 </li>
</ul>
</li>
<li><p>NIO框架 Netty 、以及基于Netty实现的 主流RPC 框架Motan、Dubbo和gRPC</p>
</li>
<li><p>ORM 框架 Mybatis</p>
</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ol>
<li>类型：本地缓存、分布式缓存、多级缓存</li>
<li>淘汰策略：FIFO、LRU、LFU</li>
<li>缓存问题：缓存不一致、缓存更新、缓存击穿、缓存雪崩</li>
<li>Memcache</li>
<li>Redis</li>
</ol>
<h3 id="消息队列与数据库知识点"><a href="#消息队列与数据库知识点" class="headerlink" title="消息队列与数据库知识点"></a>消息队列与数据库知识点</h3><p><strong>消息队列：</strong></p>
<ul>
<li>使用场景：应用解耦合、服务通信、异步任务、削峰填谷、消息广播</li>
<li>消息协议：JMS、AMQP</li>
<li>常用队列：RabbitMQ、ActiveMQ、RocketMQ、Kafka</li>
</ul>
<p><strong>数据库知识点：</strong></p>
<ul>
<li>数据库中间件：Sharding-Sphere、mycat</li>
<li>关系数据库：Oracle、Mysql、PostgreSQL</li>
<li>NoSQL：Redis、MongoDB、Hbase、</li>
<li>NewSql：TiDB、OceanBase</li>
<li>事务特性：原子性、一致性、隔离性、持久性</li>
<li>事务类型：扁平事务、带包存点的扁平事务、嵌套事务、分布式事务</li>
</ul>
<h3 id="Mysql调优（Oracle、PostgreSQL）"><a href="#Mysql调优（Oracle、PostgreSQL）" class="headerlink" title="Mysql调优（Oracle、PostgreSQL）"></a>Mysql调优（Oracle、PostgreSQL）</h3><ol>
<li>常用语句：条件查询、关联查询、排序查询、分组查询、逻辑关键字、函数</li>
<li>数据类型：整数、浮点、日期、时间、字符、二进制</li>
<li>引擎：MyIASM、InnoDB</li>
<li>锁：表锁、行级锁、共享锁、排他锁</li>
<li>索引：<ul>
<li>类型：唯一索引、主键索引、普通索引、联合索引、全文索引</li>
<li>实现：B-Tree、R-Tree、Hash</li>
</ul>
</li>
<li>存储过程与函数</li>
<li>新特性：隐藏索引、通用表达式、窗口函数</li>
<li>SQL优化：查看慢日志、explain 查看执行计划、优化sql语句</li>
</ol>
<h3 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h3><ul>
<li>单体</li>
<li>微服务</li>
<li>云原生</li>
<li>Mesh Service  sidecar</li>
</ul>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统与计算机网络（二）</title>
    <url>/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="操作系统与计算机网络（二）"><a href="#操作系统与计算机网络（二）" class="headerlink" title="操作系统与计算机网络（二）"></a>操作系统与计算机网络（二）</h1><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><h4 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h4><p>OSI（Open System Interconnection）开放系统互连参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>把复杂的网络划分成为更容易管理的层（将整个庞大而复杂的问题划分为若干个容易处理的小问题）；</li>
<li>没有一个厂家能完整的提供整套解决方案和所有的设备，协议；</li>
<li>独立完成各自该做的任务，互不影响，分工明确，上层不关心下层具体细节，分层同样有益于网络排错<br>功能与代表设备。</li>
</ol>
<table>
<thead>
<tr>
<th>分层</th>
<th>名字</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td>应用层</td>
<td>提供网络与用户软件之间的接口服务</td>
</tr>
<tr>
<td>6</td>
<td>表示层</td>
<td>提供格式化的表示和转换数据服务</td>
</tr>
<tr>
<td>5</td>
<td>会话层</td>
<td>提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制</td>
</tr>
<tr>
<td>4</td>
<td>传输层</td>
<td>提供建立、维护和取消传输连接功能，负责可靠或不可靠传输数据</td>
</tr>
<tr>
<td>3</td>
<td>网络层</td>
<td>处理网络间路由，确保数据及时传送</td>
</tr>
<tr>
<td>2</td>
<td>数据链路层</td>
<td>负责无错传输数据，确认帧，发错重传等</td>
</tr>
<tr>
<td>1</td>
<td>物理层</td>
<td>负责最后将信息编码成电流脉冲或其它信号用于网上传输。</td>
</tr>
</tbody></table>
<h4 id="TCP-IP四层网络模型"><a href="#TCP-IP四层网络模型" class="headerlink" title="TCP/IP四层网络模型"></a>TCP/IP四层网络模型</h4><p>TCP/IP分层模型（TCP/IP Layening Model）被称作因特网分层模型(Internet Layering Model)、因特网参考模型(Internet Reference Model)。</p>
<p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/computer_network_01.png" alt="网络模型"></p>
<p>区别：</p>
<ul>
<li>OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型。</li>
<li>OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。</li>
<li>OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。</li>
</ul>
<p>常用协议的总结，这里是根据TCP/IP模型来的，因为通常应用层、表示层、会话层的协议可以共用。</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>网络接口层</td>
<td>以太网协议</td>
</tr>
<tr>
<td>网络层</td>
<td>IP协议、ARP协议（地址解析协议）、RARP协议反向地址转换协议）</td>
</tr>
<tr>
<td>传输层</td>
<td>UDP协议、TCP协议</td>
</tr>
<tr>
<td></td>
<td>TELNET、FPT、SFTP、SMTP、HTTP\HTTPS等</td>
</tr>
</tbody></table>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>TCP 协议是<strong>基于链接</strong>的，也就是传输数据前需要先建立好链接，然后再进行传输。TCP 链接一旦建立，就可以在链接上进行<strong>双向</strong>的通信。</li>
<li>TCP 的传输是<strong>基于字节流</strong>而不是报文，将数据按字节大小进行编号，接收端通过 ACK 来确认收到的数据编号。</li>
<li>通过这种机制，TCP 协议能够保证接收数据的有序性和完整性，因此 TCP 能够提供<strong>可靠性传输</strong>。</li>
<li>TCP 还能提供流量控制能力，通过<strong>滑动窗口</strong>来控制数据的发送速率。滑动窗口的本质是动态缓冲区，接收端根据自己的处理能力，在 TCP 的 Header 中动态调整窗口大小，通过 ACK 应答包通知给发送端，发送端根据窗口大小调整发送的的速度。</li>
<li>仅仅有了流量控制能力还不够，TCP 协议还考虑到了网络问题可能会导致大量重传，进而导致网络情况进一步恶化，因此 TCP 协议还提供<strong>拥塞控制</strong>。TCP 处理拥塞控制主要用到了慢启动、拥塞避免、拥塞发生、快速恢复四个算法。</li>
</ul>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>TCP 是<strong>基于链接</strong>的，所以在传输数据前需要先建立链接，TCP 在传输上是<strong>双工传输</strong>，不区分 Client 端与 Server 端，为了便于理解，我们把主动发起建连请求的一端称作 Client 端，把被动建立链接的一端称作 Server 端。</p>
<p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/computer_network_02.png" alt="网络模型"></p>
<p>首先建立链接前需要 Server 端先监听端口，因此 Server 端建立链接前的初始状态就是 LISTEN 状态，这时 Client 端准备建立链接，先发送一个 SYN 同步包，发送完同步包后，Client 端的链接状态变成了 SYN_SENT 状态。Server 端收到 SYN 后，同意建立链接，会向 Client 端回复一个 ACK。</p>
<p> 由于 TCP 是双工传输，Server 端也会同时向 Client 端发送一个 SYN，申请 Server 向 Client 方向建立链接。发送完 ACK 和 SYN 后，Server 端的链接状态就变成了 SYN_RCVD。 </p>
<p>Client 收到 Server 的 ACK 后，Client 端的链接状态就变成了 ESTABLISHED 状态，同时，Client 向 Server 端发送 ACK，回复 Server 端的 SYN 请求。</p>
<p> Server 端收到 Client 端的 ACK 后，Server 端的链接状态也就变成了的 ESTABLISHED 状态，此时建连完成，双方随时可以进行数据传输。</p>
<p><strong>问题：SYN 洪水攻击</strong></p>
<p>发生的原因，就是 Server 端收到 Client 端的 SYN 请求后，发送了 ACK 和 SYN，但是 Client 端不进行回复，导致 Server 端大量的链接处在 SYN_RCVD 状态，进而影响其他正常请求的建连。可以设置 tcp_synack_retries = 0 加快半链接的回收速度，或者调大 tcp_max_syn_backlog 来应对少量的 SYN 洪水攻击。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/computer_network_03.png" alt="网络模型"></p>
<p>TCP 链接的关闭，通信双方都可以先发起，我们暂且把先发起的一方看作 Client，从图中看出，通信中 Client 和 Server 两端的链接都是 ESTABLISHED 状态，然后 Client 先主动发起了关闭链接请求，Client 向 Server 发送了一个 FIN 包，表示 Client 端已经没有数据要发送了，然后 Client 进入了 FIN_WAIT_1 状态。</p>
<p> Server 端收到 FIN 后，返回 ACK，然后进入 CLOSE_WAIT 状态。此时 Server 属于<strong>半关闭状态</strong>，因为此时 Client 向 Server 方向已经不会发送数据了，可是 Server 向 Client 端可能还有数据要发送。</p>
<p> 当 Server 端数据发送完毕后，Server 端会向 Client 端发送 FIN，表示 Server 端也没有数据要发送了，此时 Server 进入 LAST_ACK 状态，就等待 Client 的应答就可以关闭链接了。 </p>
<p>Client 端收到 Server 端的 FIN 后，回复 ACK，然后进入 TIME_WAIT 状态。TIME_WAIT 状态下需要<strong>等待 2 倍的最大报文段生存时间</strong>，来保证链接的可靠关闭，之后才会进入 CLOSED 关闭状态。而 Server 端收到 ACK 后直接就进入 CLOSED 状态。</p>
<p><strong>问题1</strong>：为什么需要等待 2 倍最大报文段生存时间之后再关闭链接？</p>
<ul>
<li><p>保证 TCP 协议的全双工连接能够可靠关闭；</p>
</li>
<li><p>保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆。</p>
</li>
</ul>
<p><strong>问题2</strong>：大量 Socket 处在 TIME_WAIT 或者 CLOSE_WAIT 状态</p>
<p>一般开启 tcp_tw_reuse 和 tcp_tw_recycle 能够加快 TIME-WAIT 的 Sockets 回收；</p>
<p>而大量 CLOSE_WAIT 可能是被动关闭的一方存在代码 bug，没有正确关闭链接导致的。</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>建立连接时，各端分配一个缓冲区用来存储接收的数据，并将缓冲区的尺寸发送给另一端。</p>
<p>接收方发送的确认消息中包含了自己剩余的缓冲区尺寸。剩余缓冲区空间的数量叫做窗口。其实就是建立连接的双虎互相知道彼此剩余的缓冲区大小。</p>
<p>TCP的滑动窗口是动态的，<strong>应用根据自身的处理能力变化，通过本端TCP接收窗口大小控制来对对对端的发送窗口流量限制。</strong></p>
<p>应用程序在需要（如内存不足）时，通过API通知TCP协议栈缩小TCP的接收窗口。然后TCP协议栈在下个段发送时包含新的窗口大小通知给对端，对端按通知的窗口来改变发送窗口，以此达到减缓发送速率的目的。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做<strong>网络拥塞</strong>。</p>
<p>在计算机网络中数位链路容量（即带宽）、交换结点中的缓存和处理机等，都是网络的资源。若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。</p>
<p>TCP拥塞控制：</p>
<ul>
<li>慢开始：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</li>
<li>拥塞避免：拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li>
<li>快重传：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。</li>
<li>快恢复：当发送方连续收到三个重复确认时，说明网络也不那么糟糕，可以快速恢复。</li>
</ul>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>无连接协议，也称透明协议，也位于传输层。</p>
<p><strong>与TCP协议的区别</strong>：</p>
<ol>
<li><p>TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）； UDP提供无连接的传输，通信前不需要建立连接。</p>
</li>
<li><p>TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。</p>
</li>
<li><p>TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。</p>
</li>
<li><p>TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制。</p>
</li>
</ol>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ul>
<li>http协议是基于TCP/IP协议之上的应用层协议。</li>
<li>基于请求-响应模式</li>
<li>无状态保存：HTTP是一种不保存状态,即无状态(stateless)协议。</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
</ul>
<h4 id="请求消息Request"><a href="#请求消息Request" class="headerlink" title="请求消息Request"></a>请求消息Request</h4><p><strong>组成</strong>：<strong>请求行（request line）、请求头部（header）、空行</strong>和<strong>请求数据</strong>四个部分组成。</p>
<p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/computer_network_04.png" alt="网络模型"></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET /abc.jpg HTTP/<span class="number">1.1</span></span><br><span class="line">Host    img.mukewang.com</span><br><span class="line">User-Agent    Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; WOW64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">51.0</span><span class="number">.2704</span><span class="number">.106</span> Safari/<span class="number">537.36</span></span><br><span class="line">Accept    image/webp,image<span class="comment">/*,*/</span>*;q=<span class="number">0.8</span></span><br><span class="line">Referer    http:<span class="comment">//www.www.baidu.com/</span></span><br><span class="line">Accept-Encoding    gzip, deflate, sdch</span><br><span class="line">Accept-Language    zh-CN,zh;q=<span class="number">0.8</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>请求行：用来说明  请求类型,要访问的资源以及所使用的HTTP版本。</p>
</li>
<li><p>请求头部：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。常用属性如下：</p>
<ul>
<li><p><strong>Accept</strong>     报文头属性告诉服务端 客户端接受什么类型的响应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Accept:text/plain</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Cookie</strong>   浏览器cookie信息</p>
</li>
<li><p><strong>Referer</strong>   表示这个请求是从哪个URL过来的</p>
</li>
<li><p><strong>Cache-Control</strong>   对缓存进行控制，对响应返回的内容在客户端被缓存，或不希望被缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>空行：请求头部后面的空行是必须的</p>
</li>
<li><p>请求数据：也叫主体。</p>
</li>
</ul>
<h4 id="响应消息Response"><a href="#响应消息Response" class="headerlink" title="响应消息Response"></a>响应消息Response</h4><p><strong>组成：状态行、消息报头、空行和响应正文。</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--body goes here--&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>状态行：由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>
</li>
<li><p>消息报头，用来说明客户端要使用的一些附加信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date: Fri, <span class="number">22</span> May <span class="number">2009</span> <span class="number">06</span>:<span class="number">07</span>:<span class="number">21</span> GMT <span class="comment">//生成响应的时间</span></span><br><span class="line">Content-Type: text/html; charset=UTF-<span class="number">8</span>  <span class="comment">//媒体类型信息</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>空行：消息报头后面的空行是必须的。</p>
</li>
<li><p>响应正文：服务器返回的正文文本。</p>
</li>
</ul>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><ul>
<li><p>1xx：指示信息–表示请求已接收，继续处理</p>
</li>
<li><p>2xx：成功–表示请求已被成功接收、理解、接受</p>
</li>
<li><p>3xx：重定向–要完成请求必须进行更进一步的操作</p>
</li>
<li><p>4xx：客户端错误–请求有语法错误或请求无法实现</p>
</li>
<li><p>5xx：服务器端错误–服务器未能实现合法的请求</p>
</li>
</ul>
<p>常见状态码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">200</span> OK                        <span class="comment">//客户端请求成功</span></span><br><span class="line"><span class="number">400</span> Bad Request               <span class="comment">//客户端请求有语法错误，不能被服务器所理解</span></span><br><span class="line"><span class="number">401</span> Unauthorized              <span class="comment">//请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span></span><br><span class="line"><span class="number">403</span> Forbidden                 <span class="comment">//服务器收到请求，但是拒绝提供服务</span></span><br><span class="line"><span class="number">404</span> Not Found                 <span class="comment">//请求资源不存在，eg：输入了错误的URL</span></span><br><span class="line"><span class="number">500</span> Internal Server Error     <span class="comment">//服务器发生不可预期的错误</span></span><br><span class="line"><span class="number">503</span> Server Unavailable        <span class="comment">//服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span></span><br></pre></td></tr></table></figure>

<h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET         <span class="comment">//请求指定的页面信息，并返回实体主体。</span></span><br><span class="line">HEAD        <span class="comment">//类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</span></span><br><span class="line">POST        <span class="comment">//向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</span></span><br><span class="line">PUT         <span class="comment">//从客户端向服务器传送的数据取代指定的文档的内容。</span></span><br><span class="line">DELETE      <span class="comment">//请求服务器删除指定的页面。</span></span><br><span class="line">CONNECT     <span class="comment">//HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</span></span><br><span class="line">OPTIONS     <span class="comment">//允许客户端查看服务器的性能。</span></span><br><span class="line">TRACE       <span class="comment">//回显服务器收到的请求，主要用于测试或诊断。</span></span><br></pre></td></tr></table></figure>



<h3 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h3><p>五种IO模型：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。</p>
<h4 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h4><p>最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。</p>
<p>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p>
<h4 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h4><p>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。</p>
<p>如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p>
<p> 所以事实上，在非阻塞IO模型中，用户线程需要<strong>不断地询问内核数据是否就绪</strong>，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p>
<h4 id="多路复用IO模型"><a href="#多路复用IO模型" class="headerlink" title="多路复用IO模型"></a>多路复用IO模型</h4><p>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。</p>
<p>多路复用实现了<strong>一个线程处理多个 I/O 句柄的操作</strong>。<strong>多路</strong>指的是多个<strong>数据通道</strong>，<strong>复用</strong>指的是使用一个或多个固定线程来处理每一个 Socket。</p>
<p>因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p>
<p>不过要注意的是，多路复用IO模型是通过<strong>轮询</strong>的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
<p>多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。</p>
<h4 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h4><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p>
<h4 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h4><p>异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要关心实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。</p>
<p><strong>异步 I/O 与信号驱动 I/O 这种半异步模式的主要区别</strong>：信号驱动 I/O 由内核通知何时可以开始一个 I/O 操作，而异步 I/O 由内核通知 I/O 操作何时已经完成。</p>
<p>异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。简称AIO。</p>
<h3 id="I-O多路复用模型"><a href="#I-O多路复用模型" class="headerlink" title="I/O多路复用模型"></a>I/O多路复用模型</h3><p>Linux 下有三种提供 I/O 多路复用的 API，分别是：</p>
<ul>
<li>select</li>
</ul>
<ul>
<li>poll</li>
</ul>
<ul>
<li>epoll</li>
</ul>
<p>一个 Socket 文件，可以由多个进程使用；而一个进程，也可以使用多个 Socket 文件。进程和 Socket 之间是<strong>多对多</strong>的关系。另一方面，一个 Socket 也会有不同的事件类型。因此操作系统很难判断，将哪样的事件给哪个进程。</p>
<p>这样在进程内部就需要一个数据结构来<strong>描述自己会关注哪些 Socket 文件的哪些事件</strong>（读、写、异常等）。通常有两种考虑方向，一种是利用<strong>线性结构</strong>，比如说数组、链表等，这类结构的查询需要遍历。每次内核产生一种消息，就<strong>遍历</strong>这个线性结构。另一种是<strong>索引结构</strong>，内核发生了消息可以通过索引结构马上知道这个消息进程关不关注。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h4><p><strong>select 和 poll 都采用线性结构</strong>，select 允许用户传入 3 个集合。如下面这段程序所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fd_set read_fd_set, write_fd_set, error_fd_set;</span><br><span class="line">while(true) &#123;</span><br><span class="line">  select(..., &amp;read_fd_set, &amp;write_fd_set, &amp;error_fd_set); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次 select 操作会阻塞当前线程，在阻塞期间所有操作系统产生的每个消息，都会通过遍历的手段查看是否在 3 个集合当中。上面程序<code>read_fd_set</code>中放入的是当数据可以读取时进程关心的 Socket；<code>write_fd_set</code>是当数据可以写入时进程关心的 Socket；<code>error_fd_set</code>是当发生异常时进程关心的 Socket。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><p>从写程序的角度来看，select 并不是一个很好的编程模型。<strong>一个好的编程模型应该是直接抽象成消息：用户不需要用 select 来设置自己的集合，而是可以通过系统的 API 直接拿到对应的消息，从而处理对应的文件描述符。</strong></p>
<p>比如下面这段伪代码就是一个更好的编程模型，具体的分析如下：</p>
<ol>
<li>poll 是一个阻塞调用，它将某段时间内操作系统内发生的且进程关注的消息告知用户程序；</li>
<li>用户程序通过直接调用 poll 函数拿到消息；</li>
<li>poll 函数的第一个参数告知内核 poll 关注哪些 Socket 及消息类型；</li>
<li>poll 调用后，经过一段时间的等待（阻塞），就拿到了是一个消息的数组；</li>
<li>通过遍历这个数组中的消息，能够知道关联的文件描述符和消息的类型；</li>
<li>通过消息类型判断接下来该进行读取还是写入操作；</li>
<li>通过文件描述符，可以进行实际地读、写、错误处理。</li>
</ol>
<p>poll 虽然优化了编程模型，但是从性能角度分析，它和 select 差距不大。因为内核在产生一个消息之后，依然需要遍历 poll 关注的所有文件描述符来确定这条消息是否跟用户程序相关。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll()"></a>epoll()</h4><p>为了解决上述问题，epoll 通过更好的方案实现了从操作系统订阅消息。epoll 将进程关注的文件描述符存入一棵二叉搜索树，通常是红黑树的实现。在这棵红黑树当中，Key 是 Socket 的编号，值是这个 Socket 关注的消息。</p>
<p>另外当有关注的事件发生时，epoll 会先放到一个队列当中。当用户调用epoll_wait时候，就会从队列中返回一个消息。epoll 函数本身是一个构造函数，只用来创建红黑树和队列结构。epoll_wait调用后，如果队列中没有消息，也可以马上返回。因此epoll是一个非阻塞模型。</p>
<blockquote>
<p>笔记来源：网络以及 林䭽 老师的《重学操作系统》课程</p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>面试复习</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统与计算机网络（一）</title>
    <url>/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="操作系统与计算机网络（一）"><a href="#操作系统与计算机网络（一）" class="headerlink" title="操作系统与计算机网络（一）"></a>操作系统与计算机网络（一）</h1><h3 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h3><h4 id="冯-·-诺依曼模型"><a href="#冯-·-诺依曼模型" class="headerlink" title="冯 · 诺依曼模型"></a>冯 · 诺依曼模型</h4><p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/operation_system_01.png" alt="冯·诺依曼模型"></p>
<p>1945 年冯诺依曼和其他几位科学家遵循图灵机的设计，提出用电子元件构造计算机，约定了用二进制进行计算和存储，并且将计算机结构分成以下 5 个部分：</p>
<ul>
<li>输入设备；</li>
</ul>
<ul>
<li>输出设备；</li>
</ul>
<ul>
<li>内存；</li>
</ul>
<ul>
<li>中央处理器；</li>
</ul>
<ul>
<li>总线</li>
</ul>
<h5 id="输入、输出设备"><a href="#输入、输出设备" class="headerlink" title="输入、输出设备"></a>输入、输出设备</h5><p>输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。</p>
<h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><p>在冯诺依曼模型中，程序和数据被存储在一个被称作<strong>内存</strong>的<strong>线性排列存储区域</strong>。</p>
<p>存储的数据单位是一个二进制位（bit）。最小的存储单位叫作字节（byte），也就是 8 位，每一个字节都对应一个内存地址。内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。</p>
<p>我们通常说的内存都是<strong>随机存取器</strong>，也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。</p>
<h5 id="中央处理器CPU"><a href="#中央处理器CPU" class="headerlink" title="中央处理器CPU"></a>中央处理器CPU</h5><p>冯诺依曼模型中 CPU 负责<strong>控制</strong>和<strong>计算</strong>。为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。</p>
<ul>
<li>如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；</li>
<li>如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU；</li>
</ul>
<p>这里的 32 和 64，称作 CPU 的<strong>位宽</strong>。</p>
<p>数据如何通过线路传递？其实是通过电压，低电压是 0，高电压是 1。如果只有一条线路，每次只能传递 1 个信号，因为你必须在 0,1 中选一个。比如你构造高高低低这样的信号，其实就是 1100，相当于你传了一个数字 10 过去。这种传递是相当慢的，因为你需要传递 4 次。</p>
<p>这种一个 bit 一个 bit 发送的方式，我们叫作<strong>串行</strong>。如果希望每次多传一些数据，就需要增加线路，也就是需要<strong>并行</strong>。</p>
<p>如果只有 1 条地址总线，那每次只能表示 0-1 两种情况，所以只能操作 2 个内存地址；如果有 10 条地址总线，一次就可以表示 2^10 种情况，也就是可以操作 2^10 个内存地址；如果你希望操作 4G 的内存，那么就需要 32 条线，因为 2^32 是 4G。所以通常32位CPU 支持最大内存容量为4G。</p>
<p><strong>CPU 三个主要参数：主频、总线频率、缓存容量</strong></p>
<ol>
<li><p>上面说过一次数据传输大小取决于位宽，那么单位时间数据传输频率就是<strong>主频</strong>，即<strong>CPU内核工作的时钟频率</strong>,代表一秒钟内脉冲信号运行了X个周期。主频对提高CPU运算速度至关重要。</p>
<p>主频的单位是 Hz（赫兹）、kHz（千赫）、兆赫（MHz）、吉赫（GHz）、太赫（THz）、拍赫（PHz）、艾赫（EHz）。Hz在电子技术中，是指一个按一定电压幅度，一定时间间隔连续发出的脉冲信号（脉冲信号之间的时间间隔称为周期，时间是s(秒)），一秒钟一个周期就是 1Hz。</p>
</li>
<li><p><strong>总线频率</strong>（FSB）:CPU标注的总线频率是指CPU连接到北桥芯片（北桥芯片用于CPU和内存、显卡、PCI交换数据，而南桥芯片主要负责I/O接口等一些外设接口的控制、IDE设备的控制，了解即可）总线的最高频率。该总线也是CPU与外界交换数据的主要通道，因此前端总线的数据传输能力对整机性能影响很大。</p>
</li>
<li><p><strong>缓存容量</strong>：1L（一级缓存）、2L（二级缓存）、3L（三级缓存）是处理器内部的缓冲存储器，工作在CPU 和内存之间。缓存大小直接影响CPU 的性能。</p>
</li>
</ol>
<p><strong>CPU的亲和性</strong></p>
<p>进程要<strong>在某个给定的 CPU 上尽量长时间地运行而不被迁移到其他处理器的倾向性</strong>，进程迁移的频率小就意味着产生的负载小。亲和性一词是从affinity翻译来的，实际可以称为CPU绑定。</p>
<p>在多核运行的机器上，每个CPU本身自己会有缓存，在缓存中存着进程使用的数据，而没有绑定CPU的话，进程可能会被操作系统调度到其他CPU上，如此CPU cache（高速缓冲存储器）命中率就低了。</p>
<p>缓存区没有这类数据，要先把内存或硬盘的数据载入缓存。而当缓存区绑定CPU后，程序就会一直在指定的CPU执行，不会被操作系统调度到其他CPU，性能上会有一定的提高。</p>
<p>另外一种使用CPU绑定考虑的是将关键的进程隔离开，对于部分实时进程调度优先级提高，可以将其绑定到一个指定CPU核上，可以保证实时进程的调度，也可以避免其他CPU上进程被该实时进程干扰。</p>
<p>操作系统部分Linux的调度程序同时提供 ” 软CPU亲和性 ”  和 ” 硬CPU亲和性 ”</p>
<ul>
<li>软亲和性：进程要在指定的 CPU 上尽量长时间地运行而不被迁移到其他CPU。</li>
<li>硬亲和性：将进程或者线程绑定到某一个指定的cpu核运行</li>
</ul>
<p>补充概念：</p>
<ul>
<li><p>物理CPU：机器上实际安装的CPU个数，比如说你的主板上安装了一块8核CPU，那么物理CPU个数就是1个，所以物理CPU个数就是主板上安装的CPU个数。</p>
</li>
<li><p>逻辑CPU：一般情况，我们认为一颗CPU可以有多个核，加上intel的超线程技术(HT), 可以在逻辑上再分一倍数量的CPU core出来。</p>
</li>
<li><p>超线程技术(Hyper-Threading)：就是利用特殊的硬件指令，把单个物理CPU模拟成两个CPU（逻辑CPU），实现多线程。我们常听到的双核四线程/四核八线程指的就是支持超线程技术的CPU。</p>
</li>
</ul>
<h5 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h5><p>CPU 和内存以及其他设备之间，需要通信，因此用一种特殊的设备进行控制，就是总线。</p>
<ul>
<li>地址总线：专门用来指定CPU 将操作的内存<strong>地址</strong>。</li>
<li>数据总线：用来读写内存中的<strong>数据</strong>。当 CPU 需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据。</li>
<li>控制总线：用来发送和接收关键<strong>信号</strong>。例如中断信号。</li>
</ul>
<h4 id="程序的执行过程"><a href="#程序的执行过程" class="headerlink" title="程序的执行过程"></a>程序的执行过程</h4><ol>
<li><p>首先，CPU 读取 PC 指针指向的<strong>指令</strong>，将它<strong>导入指令寄存器</strong>。</p>
<p>具体来说，完成读取指令这件事情有 3 个步骤：</p>
<ul>
<li><p>步骤 1：CPU 的控制单元操作地址总线指定需要访问的内存地址（简单理解，就是把 PC 指针中的值拷贝到地址总线中）。</p>
</li>
<li><p>步骤 2：CPU 通知内存设备准备数据（内存设备准备好了，就通过数据总线将数据传送给 CPU）。</p>
</li>
<li><p>步骤 3：CPU 收到内存传来的数据后，将这个数据存入指令寄存器。</p>
</li>
</ul>
<p>完成以上 3 步，CPU 成功读取了 PC 指针指向指令，存入了指令寄存器。</p>
</li>
<li><p>然后，CPU 分析指令寄存器中的指令，确定指令的类型和参数。</p>
</li>
<li><p>如果是计算类型的指令，那么就交给逻辑运算单元计算；如果是存储类型的指令，那么由控制单元执行。</p>
</li>
<li><p>PC 指针自增，并准备获取下一条指令。</p>
<p>在 32 位的机器上，指令是 32 位 4 个字节，需要 4 个内存地址存储，因此 PC 指针会自增 4。</p>
</li>
</ol>
<p>注意：</p>
<ul>
<li>内存虽然是一个随机存取器，但是我们通常不会把指令和数据存在一起，这是为了安全起见。</li>
</ul>
<ul>
<li>程序指针也是一个寄存器，64 位的 CPU 会提供 64 位的寄存器，这样就可以使用更多内存地址。64 位的寄存器可以寻址的范围非常大，但是也会受到地址总线条数的限制。比如和 64 位 CPU 配套工作的地址总线只有 40 条，那么可以寻址的范围就只有 1T，也就是 2^40。</li>
</ul>
<p>从 PC 指针读取指令、到执行、再到下一条指令，构成了一个循环，这个不断循环的过程叫作<strong>CPU 的指令周期</strong>。</p>
<h4 id="存储器分级"><a href="#存储器分级" class="headerlink" title="存储器分级"></a>存储器分级</h4><p>原因：</p>
<ul>
<li>存储器大小受体积制约</li>
<li>存储器电子元件密度越大，发热越严重。</li>
<li>与CPU距离越远传输速度越慢</li>
<li>价格</li>
</ul>
<p>不能用一块存储器来解决所有的需求，那就必须把需求分级。</p>
<h5 id="存储器分级策略"><a href="#存储器分级策略" class="headerlink" title="存储器分级策略"></a>存储器分级策略</h5><ol>
<li>寄存器；</li>
<li>L1-Cache；</li>
<li>L2-Cache；</li>
<li>L3-Cahce；</li>
<li>内存；</li>
<li>硬盘/SSD</li>
</ol>
<h5 id="寄存器（Register）"><a href="#寄存器（Register）" class="headerlink" title="寄存器（Register）"></a>寄存器（Register）</h5><p>寄存器紧挨着 CPU 的控制单元和逻辑计算单元，它所使用的材料速度也是最快的。存储器的速度越快、能耗越高、产热越大，而且花费也是最贵的，因此数量不能很多。</p>
<p>寄存器的数量通常在几十到几百之间，每个寄存器可以用来存储一定字节（byte）的数据。比如：</p>
<p>​        32 位 CPU 中大多数寄存器可以存储 4 个字节；</p>
<p>​        64 位 CPU 中大多数寄存器可以存储 8 个字节。</p>
<p>寄存机的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写。比如一条要在 4 个周期内完成的指令，除了读写寄存器，还需要解码指令、控制指令执行和计算。如果寄存器的速度太慢，那 4 个周期就可能无法完成这条指令了。</p>
<h5 id="L1-Cache"><a href="#L1-Cache" class="headerlink" title="L1-Cache"></a>L1-Cache</h5><p>L1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低。通常 L1-Cache 大小在几十 Kb 到几百 Kb 不等，读写速度在 2~4 个 CPU 时钟周期。</p>
<h5 id="L2-Cache"><a href="#L2-Cache" class="headerlink" title="L2-Cache"></a>L2-Cache</h5><p>L2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远。它的大小  比 L1-Cache 更大，具体大小要看 CPU 型号，有 2M 的，也有更小或者更大的，速度在 10~20 个 CPU 周期。</p>
<h5 id="L3-Cache"><a href="#L3-Cache" class="headerlink" title="L3-Cache"></a>L3-Cache</h5><p>L3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远。大小通常比 L2-Cache 更大，读写速度在 20~60 个 CPU 周期。L3 缓存大小也是看型号的，比如 i9 CPU 有 512KB L1 Cache；有 2MB L2 Cache； 有16MB L3 Cache。</p>
<h5 id="内存-1"><a href="#内存-1" class="headerlink" title="内存"></a>内存</h5><p>内存的主要材料是半导体硅，是插在主板上工作的。因为它的位置距离 CPU 有一段距离，所以需要用总线和 CPU 连接。因为内存有了独立的空间，所以体积更大，造价也比上面提到的存储器低得多。现在有的个人电脑上的内存是 16G，但有些服务器的内存可以到几个 T。内存速度大概在 200~300 个 CPU 周期之间。</p>
<h5 id="SSD-和硬盘"><a href="#SSD-和硬盘" class="headerlink" title="SSD 和硬盘"></a>SSD 和硬盘</h5><p>SSD 也叫固态硬盘，结构和内存类似，但是它的优点在于断电后数据还在。内存、寄存器、缓存断电后数据就消失了。内存的读写速度比 SSD 大概快 10~1000 倍。以前还有一种物理读写的磁盘，我们也叫作硬盘，它的速度比内存慢 100W 倍左右。因为它的速度太慢，现在已经逐渐被 SSD 替代</p>
<h3 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h3><p>以下为常用命令，不再过多赘述</p>
<ul>
<li>文件相关：cd 、mkdir、touch、mv、rm、cp、ls、find、whereis、which、locate、more、tail、cat、less、df、rpm、tar等</li>
<li>权限相关：chmod 、chown、chgrp、sudo等</li>
<li>网络相关：ifconfig、netstat、ifup、ifdown等</li>
</ul>
<p>由于开发常用为查看日志，所以需详细了解以下几个命令：</p>
<p>awk、grep、sed是linux操作文本的三大利器，合称文本三剑客。</p>
<p>三者的功能都是处理文本，但侧重点各不相同，其中属awk功能最强大，但也最复杂。</p>
<p><strong>grep</strong>用于单纯的查找或匹配文本，<strong>sed</strong>用于编辑匹配到的文本，<strong>awk</strong>更适合格式化文本，对文本进行较复杂格式处理。</p>
<h4 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h4><p>grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来) 是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [-acinv] [--color=auto] '搜寻字符串' filename</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line">-a ：将 binary 文件以 text 文件的方式搜寻数据</span><br><span class="line">-c ：计算找到 '搜寻字符串' 的次数</span><br><span class="line">-i ：忽略大小写的不同，所以大小写视为相同</span><br><span class="line">-n ：顺便输出行号</span><br><span class="line">-v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！</span><br><span class="line">--color=auto ：可以将找到的关键词部分加上颜色的显示</span><br></pre></td></tr></table></figure>

<h4 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h4><p>sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变除，非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed [-nefr] [动作]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line">-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">-e ：直接在命令列模式上进行 sed 的动作编辑；</span><br><span class="line">-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；</span><br><span class="line">-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)</span><br><span class="line">-i ：直接修改读取的文件内容，而不是输出到终端。</span><br><span class="line"></span><br><span class="line">动作说明： [n1[,n2]]function</span><br><span class="line">n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』</span><br><span class="line"></span><br><span class="line">function：</span><br><span class="line">a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</span><br><span class="line">c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</span><br><span class="line">d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</span><br><span class="line">i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</span><br><span class="line">p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</span><br><span class="line">s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g</span><br></pre></td></tr></table></figure>

<h4 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h4><p>awk是一个强大的文本分析工具，awk是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk` `[options] ``'program'` `var=value ``file``…</span><br><span class="line">awk` `[options] -f programfile var=value ``file``…</span><br><span class="line">awk` `[options] ``'BEGIN&#123; action;… &#125; pattern&#123; action;… &#125; END&#123; action;… &#125;'` `file` `...</span><br></pre></td></tr></table></figure>

<p>常用命令选项：</p>
<ul>
<li>-F fs：fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:</li>
<li>-v var=value：赋值一个用户定义变量，将外部变量传递给awk</li>
<li>-f scripfile：从脚本文件中读取awk命令</li>
</ul>
<p>内置变量：</p>
<ul>
<li>FS ：<strong>输入字段分隔符</strong>，默认为空白字符</li>
<li>OFS ：<strong>输出字段分隔符</strong>，默认为空白字符</li>
<li>RS ：<strong>输入记录分隔符</strong>，指定输入时的换行符，原换行符仍有效</li>
<li>ORS ：<strong>输出记录分隔符</strong>，输出时用指定符号代替换行符</li>
<li>NF ：字段数量，<strong>共有</strong>多少字段， <strong>$NF引用最后一列，$(NF-1)引用倒数第2列</strong></li>
<li>NR ：<strong>行号</strong>，后可跟多个文件，第二个文件行号继续从第一个文件最后行号开始</li>
<li>FNR ：各文件分别计数, 行号，后跟一个文件和NR一样，跟多个文件，第二个文件<strong>行号从1开始</strong></li>
<li>FILENAME ：<strong>当前文件名</strong></li>
<li>ARGC ：<strong>命令行参数</strong>的个数</li>
<li>ARGV ：数组，保存的是命令行所给定的各参数，<strong>查看参数</strong></li>
</ul>
<h3 id="操作系统基础知识"><a href="#操作系统基础知识" class="headerlink" title="操作系统基础知识"></a>操作系统基础知识</h3><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>对于一个现代的操作系统来说，它的内核至少应该提供以下 4 种基本能力：</p>
<ul>
<li>管理进程、线程（决定哪个进程、线程使用 CPU）；</li>
</ul>
<ul>
<li>管理内存（决定内存用来做什么）；</li>
</ul>
<ul>
<li>连接硬件设备（为进程、和设备间提供通信能力）；</li>
</ul>
<ul>
<li>提供系统调用（接收进程发送来的系统调用）。</li>
</ul>
<h5 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h5><p>CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序。</p>
<h5 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h5><p>只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取。</p>
<h5 id="存在原因"><a href="#存在原因" class="headerlink" title="存在原因"></a>存在原因</h5><p>限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据。</p>
<h5 id="用户态与内核态的切换"><a href="#用户态与内核态的切换" class="headerlink" title="用户态与内核态的切换"></a>用户态与内核态的切换</h5><p>所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作.</p>
<p>这时需要一个这样的机制: <strong>用户态程序切换到内核态</strong>, 但是不能控制在内核态中执行的指令</p>
<p>用户态切换到内核态的3种方式：</p>
<p><strong>a. 系统调用</strong></p>
<p>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
<p><strong>b. 异常</strong></p>
<p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
<p><strong>c. 外围设备的中断</strong></p>
<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<h4 id="中断与中断向量"><a href="#中断与中断向量" class="headerlink" title="中断与中断向量"></a>中断与中断向量</h4><p>以用户键盘按键为例，主板知道有新的按键后，通知 CPU，CPU 要中断当前执行的程序，将 PC 指针跳转到一个固定的位置，我们称为一次<strong>中断</strong>（interrupt）。CPU 不知道中断后PC指针的具体位置是多少，而只能跳转到一个固定位置，考虑到系统中会出现各种各样的事件，我们需要根据<strong>中断类型来判断PC 指针跳转的位置</strong>，中断类型不同，PC 指针跳转的位置也可能会不同。比如按键程序、打印机就绪程序、系统异常等都需要中断，包括上面说到的系统调用，也需要中断正在执行的程序，切换到内核态执行内核程序。</p>
<p>因此我们需要把不同的中断类型进行分类，这个类型叫作<strong>中断识别码</strong>。比如按键，我们可以考虑用编号 16，数字 16 就是按键中断类型的识别码。不同类型的中断发生时，CPU 需要知道 PC 指针该跳转到哪个地址，这个地址，称为<strong>中断向量</strong>（Interupt Vector）。</p>
<p>你可以考虑这样的实现：当编号 16 的中断发生时，32 位机器的 PC 指针直接跳转到内存地址 16<em>4 的内存位置。如果设计最多有 255 个中断，编号就是从 0~255，刚好需要 1K 的内存地址存储中断向量——这个 1K 的空间，称为*</em>中断向量表**。</p>
<p>因此 CPU 接收到中断后，CPU 根据中断类型操作 PC 指针，找到中断向量。操作系统必须在这之前，修改中断向量，插入一条指令。比如操作系统在这里写一条Jump指令，将 PC 指针再次跳转到自己处理对应中断类型的程序。</p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><h4 id="进程（Process）"><a href="#进程（Process）" class="headerlink" title="进程（Process）"></a>进程（Process）</h4><p>就是正在执行的应用程序，是软件的执行副本。而<strong>线程</strong>是轻量级的进程。</p>
<p>进程是分配资源的基础单位。而线程很长一段时间被称作轻量级进程（Light Weighted Process），是程序执行的基本单位。</p>
<h5 id="分时和调度"><a href="#分时和调度" class="headerlink" title="分时和调度"></a>分时和调度</h5><p>因为通常机器中 CPU 核心数量少（从几个到几十个）、进程&amp;线程数量很多（从几十到几百甚至更多），因此进程们在操作系统中只能排着队一个个执行。每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（线程）执行。</p>
<p>例如进程 1 执行到一半时，会先挂起，然后进程 2 开始执行。如果进程 2 一次可以执行完，然后进程 3 开始执行，不过进程 3 一次执行不完，在执行了 1 个时间片段后，进程 1 开始执行；就这样如此周而复始。这个就是<strong>分时</strong>技术。</p>
<h4 id="进程和线程的状态"><a href="#进程和线程的状态" class="headerlink" title="进程和线程的状态"></a>进程和线程的状态</h4><p>一个进程（线程）运行的过程，会经历以下 3 个状态：</p>
<ul>
<li>进程（线程）创建后，就开始排队，此时它会处在“就绪”（<strong>Ready</strong>）状态；</li>
<li>当轮到该进程（线程）执行时，会变成“运行”（<strong>Running</strong>）状态；</li>
<li>当一个进程（线程）将操作系统分配的时间片段用完后，会回到“就绪”（<strong>Ready</strong>）状态。</li>
</ul>
<p>有时候一个进程（线程）会等待磁盘读取数据，或者等待打印机响应，此时进程自己会进入“阻塞”（<strong>Block</strong>）状态。需要等待磁盘、打印机处理完成后，通过中断通知 CPU，然后 CPU 再执行一小段中断控制程序，将控制权转给操作系统，操作系统再将原来阻塞的进程（线程）置为“就绪”（Ready）状态重新排队。</p>
<h4 id="进程（线程）切换"><a href="#进程（线程）切换" class="headerlink" title="进程（线程）切换"></a>进程（线程）切换</h4><p>进程（线程）在操作系统中是不断切换的，<strong>现代操作系统中只有线程的切换</strong>。 每次切换需要先保存当前寄存器的值的内存，注意 PC 指针也是一种寄存器。当恢复执行的时候，就需要从内存中读出所有的寄存器，恢复之前的状态，然后执行。</p>
<p>进程（线程）切换分为以下 5 个步骤：</p>
<ol>
<li>当操作系统发现一个进程（线程）需要被切换的时候，直接控制 PC 指针跳转是非常危险的事情，所以操作系统需要发送一个“中断”信号给 CPU，停下正在执行的进程（线程）。</li>
<li>当 CPU 收到中断信号后，正在执行的进程（线程）会立即停止。注意，因为进程（线程）马上被停止，它还来不及保存自己的状态，所以后续操作系统必须完成这件事情。</li>
<li>操作系统接管中断后，趁寄存器数据还没有被破坏，必须马上执行一小段非常底层的程序（通常是汇编编写），帮助寄存器保存之前进程（线程）的状态。</li>
<li>操作系统保存好进程状态后，执行调度程序，决定下一个要被执行的进程（线程）。</li>
<li>最后，操作系统执行下一个进程（线程）。</li>
</ol>
<h4 id="多核处理"><a href="#多核处理" class="headerlink" title="多核处理"></a>多核处理</h4><p>进程（线程）可以<strong>并行</strong>执行。通常情况下，CPU 有几个核，就可以并行执行几个进程（线程）。</p>
<h4 id="锁、信号量和分布式锁"><a href="#锁、信号量和分布式锁" class="headerlink" title="锁、信号量和分布式锁"></a>锁、信号量和分布式锁</h4><h5 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h5><p>原子操作就是<strong>操作不可分</strong></p>
<h5 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h5><p><strong>临界区</strong>指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个<a href="https://baike.baidu.com/item/线程/103101" target="_blank" rel="noopener">线程</a>访问的特性。当有线程进入临界区段时，其他线程或是<a href="https://baike.baidu.com/item/进程/382503" target="_blank" rel="noopener">进程</a>必须等待有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥获得使用。</p>
<h5 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h5><p>竞争条件就是说多个线程对一个资源（内存地址）的读写存在竞争，在这种条件下，最后这个资源的值不可预测，而是取决于竞争时具体的执行顺序。</p>
<h5 id="解决竞争条件"><a href="#解决竞争条件" class="headerlink" title="解决竞争条件"></a>解决竞争条件</h5><p>解决竞争条件有很多方案，一种方案就是不要让程序同时进入临界区，这个方案叫作<strong>互斥</strong>。还有一些方案旨在避免竞争条件，比如 <strong>ThreadLocal</strong>、 <strong>cas 指令</strong>以及 <strong>乐观锁</strong>。</p>
<ul>
<li><strong>避免临界区</strong>：不让程序同时进入临界区这个方案比较简单，核心就是我们给每个线程一个变量i，比如利用 ThreadLocal，这样线程之间就不存在竞争关系了。这样做优点很明显，缺点就是并不是所有的情况都允许你这样做。有一些资源是需要共享的。</li>
<li><strong>cas 指令</strong>：另一个方案是利用 CPU 的指令，让i++成为一个原子操作。 很多 CPU 都提供 Compare And Swap 指令。这个指令的作用是更新一个内存地址的值，比如把i更新为i+1，但是这个指令明确要求使用者必须确定知道内存地址中的值是多少。比如一个线程想把i从100更新到101，线程必须明确地知道现在i是 100，否则就会更新失败。</li>
<li><strong>锁（lock）</strong>：目标是实现抢占（preempt）。就是只让给定数量的线程进入临界区。通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。所谓的锁，可以理解为内存中的一个整型数，拥有两种状态：空闲状态和上锁状态。加锁时，判断锁是否空闲，如果空闲，修改为上锁状态，返回成功。如果已经上锁，则返回失败。解锁时，则把锁状态修改为空闲状态。<strong>自旋锁</strong>：自旋锁与<a href="https://baike.baidu.com/item/互斥锁" target="_blank" rel="noopener">互斥锁</a>比较类似，它们都是为了解决对某项资源的互斥使用。无论是<strong><a href="https://baike.baidu.com/item/互斥锁" target="_blank" rel="noopener">互斥锁</a></strong>，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</li>
</ul>
<h5 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h5><p>一个合理的实现就是生产者消费者模型。 wait 是一个生产者，将当前线程挂到一个等待队列上，并休眠。notify 是一个消费者，从等待队列中取出一个线程，并重新排队。</p>
<p>Java 语言中为每个对象增加了一个 Object Header 区域，里面一个锁的位（bit），锁并不需要一个 32 位整数，一个 bit 足够。下面的代码用户使用 synchronized 关键字让临界区访问互斥。</p>
<p>synchronized 关键字的内部实现，用到了封装好的底层代码——<strong>Monitor</strong> 对象。每个 Java 对象都关联了一个 Monitor 对象。Monitor 封装了对锁的操作，这样简化了 Java 程序员的工作，你只需要调用 synchronized 关键字。</p>
<p>另外，Monitor 实现了生产者、消费者模型。</p>
<ul>
<li>如果一个线程拿到锁，那么这个线程继续执行；</li>
</ul>
<ul>
<li>如果一个线程竞争锁失败，Montior 就调用 wait 方法触发生产者的逻辑，把线程加入等待集合；</li>
</ul>
<ul>
<li>如果一个线程执行完成，Monitor 就调用一次 notify 方法恢复一个等待的线程。</li>
</ul>
<p>这样，Monitor 除了提供了互斥，还提供了线程间的通信，避免了使用自旋锁，还简化了程序设计。</p>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。而互斥锁是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，直到这个线程unlock，其他的线程才开始可以利用这个资源。比如对全局变量的访问，有时要加锁，操作完了，在解锁。有的时候锁和信号量会同时使用的。</p>
<p>也就是说，信号量不一定是锁定某一个资源，而是流程上的概念，比如：有A,B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，这个任务并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。而线程互斥量则是“锁住某一资源”的概念，在锁定期间内，其他线程无法对被保护的数据进行操作。在有些情况下两者可以互换。</p>
<h5 id="信号量与互斥锁之间的区别"><a href="#信号量与互斥锁之间的区别" class="headerlink" title="信号量与互斥锁之间的区别"></a>信号量与互斥锁之间的区别</h5><ol>
<li>互斥锁用于线程的互斥，信号量用于线程的同步。这是互斥锁和信号量的根本区别，也就是互斥和同步之间的区别。</li>
<li>互斥量值只能为0/1，信号量值可以为非负整数。也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。信号量是通过一个计数器控制对共享资源的访问，信号量的值是一个非负整数，所有通过它的线程都会将该整数减一。如果计数器大于0，则访问被允许，计数器减1；如果为0，则访问被禁止，所有试图通过它的线程都将处于等待状态。</li>
<li>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</li>
</ol>
<h5 id="互斥和同步的定义"><a href="#互斥和同步的定义" class="headerlink" title="互斥和同步的定义"></a>互斥和同步的定义</h5><ul>
<li><p>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p>
</li>
<li><p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p>
</li>
</ul>
<h5 id="死锁、悲观锁-乐观锁"><a href="#死锁、悲观锁-乐观锁" class="headerlink" title="死锁、悲观锁/乐观锁"></a>死锁、悲观锁/乐观锁</h5><p>两个线程互相等待对方获得的锁，就会发生<strong>死锁</strong>。你可以把死锁理解成一个环状的依赖关系。</p>
<p><strong>产生死锁有四个必要条件：</strong></p>
<ul>
<li><p><strong>互斥条件</strong>。一个资源只能被一个进程占用</p>
</li>
<li><p><strong>不可剥夺条件</strong>。某个进程占用了资源，就只能他自己去释放。</p>
</li>
<li><p><strong>请求和保持条件</strong>。进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。除非我自己不想用了，释放掉。</p>
</li>
<li><p><strong>循环等待条件</strong>。在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路。</p>
</li>
</ul>
<p>如何<strong>预防死锁</strong>：可以通过<strong>破坏死锁产生的4个必要条件来 预防死锁</strong>，由于资源互斥是资源使用的固有特性是无法改变的，所以通过破坏其他三个条件 预防死锁：</p>
<ul>
<li><strong>破坏 “不可剥夺条件” ：</strong>一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。</li>
<li><strong>破坏 “请求和保持条件”：</strong>第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。</li>
<li><strong>破坏“循环等待条件“：</strong>采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。</li>
</ul>
<p>临界区互斥的方法（对临界区上锁），具有强烈的排他性，对修改持保守态度，我们称为<strong>悲观锁</strong>（Pressimistic Lock）。通常意义上，我们说上锁，就是悲观锁，比如说 MySQL 的表锁、行锁、Java 的锁，本质是互斥（mutex）。</p>
<p>和悲观锁（PressimisticLock）持相反意见的，是<strong>乐观锁</strong>（Optimistic Lock）。即一开始认为没有冲突，在真正操作提交时判断版本是否一致，如果一致直接提交，不一致则打回。</p>
<h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p><a href="http://blogsea.cn/2020/06/10/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">详见：分布式架构之分布式锁</a></p>
<h4 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h4><h5 id="先到先服务"><a href="#先到先服务" class="headerlink" title="先到先服务"></a>先到先服务</h5><p>早期的操作系统是一个个处理作业（Job），比如很多保险业务，每处理一个称为一个作业（Job）。处理作业最容易想到的就是<strong>先到先服务</strong>（First Come First Service，FCFS），也就是先到的作业先被计算，后到的作业，排队进行。</p>
<p>这里需要用到一个叫作<strong>队列</strong>的数据结构，具有<strong>先入先出</strong>（First In First Out，FIFO）性质。先进入队列的作业，先处理，因此从公平性来说，这个算法非常朴素。另外，一个作业完全完成才会进入下一个作业，作业之间不会发生切换，从吞吐量上说，是最优的——因为没有额外开销。</p>
<p>但是这样对于等待作业的用户来说，是有问题的。比如一笔需要用时 1 天的作业 ，如果等待了 10 分钟，用户是可以接受的；一个用时 10 分钟的作业，用户等待一天就要投诉了。 因此如果用时 1 天的作业先到，用时 10 分钟的任务后到，应该优先处理用时少的，也就是<strong>短作业优先</strong>（Shortest Job First，SJF）。</p>
<h5 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h5><p>平均等待时间 = 总等待时间/任务数</p>
<p>平均等待时间和用户满意度是成反比的，等待时间越长，用户越不满意，因此在大多数情况下，应该优先处理用时少的，从而<strong>降低平均等待时长</strong>。</p>
<h5 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h5><p><strong>优先级队列</strong>可以给队列中每个元素一个优先级，优先级越高的任务就会被先执行。</p>
<p>优先级队列的一种实现方法就是用到了堆（Heap）这种数据结构，更最简单的实现方法，就是每次扫描一遍整个队列找到优先级最高的任务。也就是说，堆（Heap）可以帮助你在 O(1) 的时间复杂度内查找到最大优先级的元素。</p>
<p>这样，关于紧急任务如何插队？等待太久的任务如何插队？但是如果先执行的大任务导致后面来的小任务的情况如何处理？</p>
<h5 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h5><p>为了解决这个问题，我们需要用到<strong>抢占</strong>（Preemption）。</p>
<p>抢占就是<strong>把执行能力分时</strong>，分成时间片段。 让每个任务都执行一个时间片段。如果在时间片段内，任务完成，那么就调度下一个任务。如果任务没有执行完成，则中断任务，让任务重新排队，调度下一个任务。</p>
<p>拥有了抢占的能力，再结合之前我们提到的优先级队列能力，这就构成了一个基本的<strong>线程调度模型</strong>。</p>
<p>每个线程执行一个时间片段，然后每次执行完一个线程就执行一段调度程序。</p>
<p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/operation_system_02.png" alt="优先级队列"></p>
<p>图中用红色代表调度程序，其他颜色代表被调度线程的时间片段。调度程序可以考虑实现为一个单线程模型，这样不需要考虑竞争条件。</p>
<p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/operation_system_03.png" alt="线程调度模型"></p>
<h5 id="多级队列模型"><a href="#多级队列模型" class="headerlink" title="多级队列模型"></a>多级队列模型</h5><p>多级队列，就是多个队列执行调度。</p>
<ul>
<li><p>紧急任务仍然走高优队列，非抢占执行。</p>
</li>
<li><p>普通任务先放到优先级仅次于高优任务的队列中，并且只分配很小的时间片；如果没有执行完成，说明任务不是很短，就将任务下调一层。</p>
</li>
<li><p>下面一层，最低优先级的队列中时间片很大，长任务就有更大的时间片可以用。</p>
</li>
</ul>
<p>通过这种方式，短任务会在更高优先级的队列中执行完成，长任务优先级会下调，也就类似实现了最短作业优先的问题。</p>
<p>实际操作中，可以有 n 层，一层层把大任务筛选出来。 最长的任务，放到最闲的时间去执行。要知道，大部分时间 CPU 不是满负荷的。</p>
<p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/operation_system_04.png" alt="线程调度模型"></p>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>进程间通信（Intermediate Process Communication，IPC）。就是操作系统创建的进程们之间在交换数据。更广泛的意义——程序间的通信。 程序可以是进程，可以是线程，可以是一个进程的两个部分（进程自己发送给自己），也可以是分布式的。</p>
<h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>管道提供了一种非常重要的能力，就是组织计算。进程不用知道有管道存在，因此管道的设计是非侵入的。程序员可以先着重在程序本身的设计，只需要预留响应管道的接口，就可以利用管道的能力。</p>
<p>管道的核心是不侵入、灵活，不会增加程序设计负担，又能组织复杂的计算过程。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">进程1 | 进程2 | 进程3 | mysql -u... -p | 爬虫进程</span><br></pre></td></tr></table></figure>

<p>我们可以由进程 1、进程 2、进程 3 计算出 MySQL 需要的语句，然后直接通过管道执行。MySQL经过计算将结果传给一个爬虫进程，爬虫就开始工作。</p>
<h5 id="本地内存共享"><a href="#本地内存共享" class="headerlink" title="本地内存共享"></a>本地内存共享</h5><p>同一个进程的多个线程本身是共享进程内存的。 这种情况不需要特别考虑共享内存。如果是跨进程的线程（或者理解为跨进程的程序），可以考虑使用共享内存。</p>
<p>linux 内存共享库的实现原理是以虚拟文件系统的形式，从内存中划分出一块区域，供两个进程共同使用。看上去是文件，实际操作是内存。</p>
<p>共享内存的方式，速度很快，但是程序不是很好写，因为这是一种侵入式的开发，也就是说你需要为此撰写大量的程序。比如如果修改共享内存中的值，需要调用 API。如果考虑并发控制，还要处理同步问题等。因此，只要不是高性能场景，进程间通信通常不考虑共享内存的方式。</p>
<h5 id="本地消息-队列"><a href="#本地消息-队列" class="headerlink" title="本地消息/队列"></a>本地消息/队列</h5><p>内存共享不太好用，因此本地消息有两种常见的方法。一种是用<strong>消息队列</strong>——现代操作系统都会提供类似的能力。Unix 系可以使用 POSIX 标准的 mqueue。另一种方式，就是直接用网络请求（<strong>远程调用RPC</strong>），比如 TCP/IP 协议，也包括建立在这之上的更多的通信协议。</p>
<ul>
<li><p><strong>远程调用RPC</strong>：一种通过本地程序调用来封装远程服务请求的方法。</p>
<p>程序调用 RPC 的时候，程序看上去是在调用一个本地的方法，或者执行一个本地的任务，但是后面会有一个服务程序（通常称为 stub），将这种本地调用转换成远程网络请求。 同理，服务端接到请求后，也会有一个服务端程序（stub），将请求转换为一个真实的服务端方法调用。</p>
<p>RPC 调用的方式比较适合微服务环境的开发，当然 RPC 通常需要专业团队的框架以支持高并发、低延迟的场景。不过，硬要说 RPC 有额外转化数据的开销（主要是序列化），也没错，但这不是 RPC 的主要缺点。<strong>RPC 真正的缺陷是增加了系统间的耦合。当系统主动调用另一个系统的方法时，就意味着在增加两个系统的耦合。长期增加 RPC 调用，会让系统的边界逐渐腐化。这才是使用 RPC 时真正需要注意的东西。</strong></p>
</li>
<li><p><strong>消息队列</strong>：既然 RPC 会增加耦合，那么怎么办呢——可以考虑事件。事件不会增加耦合，如果一个系统订阅了另一个系统的事件，那么将来无论谁提供同类型的事件，自己都可以正常工作。系统依赖的不是另一个系统，而是某种事件。如果哪天另一个系统不存在了，只要事件由其他系统提供，系统仍然可以正常运转。</p>
</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>随着程序越来越复杂，会出现的内存不足的，程序员必须小心翼翼地处理内存的使用，避免超过允许的内存使用阈值。</p>
<p>那么如何来解决这些问题呢？</p>
<h4 id="交换（Swap）技术"><a href="#交换（Swap）技术" class="headerlink" title="交换（Swap）技术"></a>交换（Swap）技术</h4><p>Swap 技术允许一部分进程使用内存，不使用内存的进程数据先保存在磁盘上。这里提到的数据，是指完整的进程数据，包括正文段（程序指令）、数据段、堆栈段等。轮到某个进程执行的时候，尝试为这个进程在内存中找到一块空闲的区域。如果空间不足，就考虑把没有在执行的进程交换（Swap）到磁盘上，把空间腾挪出来给需要的进程。</p>
<p>每个进程独立得到一个空间——我们称为<strong>地址空间</strong>（Address Space）。你可以认为地址空间是<strong>一块连续分配的内存块</strong>。每个进程在不同地址空间中工作，构成了一个原始的虚拟化技术。</p>
<p>这种方法，是一种比较原始的虚拟化技术，进程使用的是基于地址空间的虚拟地址。但是这种方案有很多明显的缺陷，比如：</p>
<ul>
<li>碎片问题：上图中我们看到进程来回分配、回收交换，内存之间会产生很多缝隙。经过反反复复使用，内存的情况会变得十分复杂，导致整体性能下降。</li>
<li>频繁切换问题：如果进程过多，内存较小，会频繁触发交换。</li>
</ul>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虚拟化技术中，操作系统设计了虚拟内存（理论上可以无限大的空间），受限于 CPU 的处理能力，通常 64bit CPU，就是 2^64 个地址。</p>
<p>虚拟化技术中，应用使用的是虚拟内存，操作系统管理虚拟内存和真实内存之间的映射。操作系统将虚拟内存分成整齐小块，每个小块称为一个<strong>页（Page）</strong>。之所以这样做，原因主要有以下两个方面。</p>
<p>一方面应用使用内存是以页为单位，整齐的页能够避免内存碎片问题。</p>
<p>另一方面，每个应用都有高频使用的数据和低频使用的数据。这样做，操作系统就不必从应用角度去思考哪个进程是高频的，仅需思考哪些页被高频使用、哪些页被低频使用。如果是低频使用，就将它们保存到硬盘上；如果是高频使用，就让它们保留在真实内存中。</p>
<h4 id="页（Page）和页表"><a href="#页（Page）和页表" class="headerlink" title="页（Page）和页表"></a>页（Page）和页表</h4><p>操作系统将虚拟内存分块，每个小块称为一个<strong>页（Page）</strong>；真实内存也需要分块，每个小块我们称为一个 <strong>Frame</strong>。Page 到 Frame 的映射，需要一种叫作<strong>页表</strong>的结构。</p>
<p><img src="/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/operation_system_05.png" alt="页和页表"></p>
<blockquote>
<p>笔记来源：林䭽 老师的《重学操作系统》课程</p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语言特性与设计模式（一）</title>
    <url>/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Java语言特性与设计模式（一）"><a href="#Java语言特性与设计模式（一）" class="headerlink" title="Java语言特性与设计模式（一）"></a>Java语言特性与设计模式（一）</h1><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul>
<li>字符类型：char</li>
<li>布尔类型：boolean</li>
<li>数值类型：byte、short、int、long、float、double</li>
</ul>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>大小(字节)</th>
<th>默认值</th>
<th>封装类</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
<td>(byte)0</td>
<td>Byte</td>
<td>最小值-128（-2^7） 最大值 127（2^7-1）</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>(short)0</td>
<td>Short</td>
<td>最小值 -32768（-2^15） 最大值 32767（2^15 - 1）</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>0</td>
<td>Integer</td>
<td>最小值 -2,147,483,648（-2^31） 最大值 2,147,483,647（2^31 - 1）</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>0L</td>
<td>Long</td>
<td>最小值 -9,223,372,036,854,775,808（-2^63） 最大值 9,223,372,036,854,775,807（2^63 -1）</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>0.0f</td>
<td>Float</td>
<td>最小值1.4E-45 （2的-149次方） 最大值 3.4028235E38 （2的128次方-1）</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>0.0d</td>
<td>Double</td>
<td>最小值 4.9E-324 （2的-1074次方） 最大值 1.7976931348623157E308 （2的1024次方-1）</td>
</tr>
<tr>
<td>boolean</td>
<td>-</td>
<td>false</td>
<td>Boolean</td>
<td>true 和 false</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>\u0000(null)</td>
<td>Character</td>
<td>最小值 \u0000（即为0） 最大值 \uffff（即为65,535）</td>
</tr>
<tr>
<td>void</td>
<td>-</td>
<td>-</td>
<td>Void</td>
<td>-</td>
</tr>
</tbody></table>
<p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是对象，在实际使用时存在很多的不便，为了解决这个不足，在设计类时java为每个基本数据类型设计了一个对应的类，这些类统称为<strong>包装类</strong>（Wrapper Class），对于包装类说，他们的用途主要包含两种：</p>
<p>  1.作为和基本数据类型对应的类类型存在，方便涉及到对象的操作；</p>
<p>  2.包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法；</p>
<h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><ul>
<li><p><strong>装箱</strong>：就是自动将基本数据类型转换为包装类</p>
</li>
<li><p><strong>拆箱</strong>：就是自动将包装类转换为基本数据类型</p>
</li>
</ul>
<p><strong>问题1</strong>：通过阅读源码可知<strong>Integer、Short、Byte、Character</strong> 有缓存机制，<strong>Double</strong> 和 <strong>Float</strong> 没有缓存机制，其中<strong>Integer</strong>类型会缓存 <strong>-128~127</strong>  以内的数字，就有以下情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">100</span>;</span><br><span class="line">Integer b = <span class="number">100</span>;</span><br><span class="line">Integer c = <span class="number">300</span>;</span><br><span class="line">Integer d = <span class="number">300</span>;</span><br><span class="line">Integer e = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">a == b;  <span class="comment">// 使用缓存，所以为true</span></span><br><span class="line">c == d;  <span class="comment">// 大于128 所以新new Integer()</span></span><br><span class="line">a == e;</span><br><span class="line"></span><br><span class="line">结果为： <span class="keyword">true</span>、<span class="keyword">false</span>、<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p><strong>问题2</strong>：java常用数据类型比较大小</p>
<ol>
<li><p>基本类型 byte,char,int,short,long,float,long,double，直接比较大小，&lt; ,&gt;, == 都可以用来直接比较</p>
</li>
<li><p>包装类型,需要考虑<strong>装箱</strong>和<strong>拆箱</strong>，比如：</p>
<p>Integer类型比较，范围在-128到127之间可以直接比较用==进行比较，超过范围的，因为Integer类型在比较大小的时候会拆箱，在超过-128到127范围会重新new对象，此时比较==，两个地址已经不相同</p>
<p>其他类型Double,Float,Long比较“==”相当于比较地址,比较大于，小于还是可以的。</p>
</li>
<li><p>基本类型和包装类型</p>
<p>包装类型和基本类型比较大小，包装类型会先拆箱，转为基本类型然后再作比较，所以包装类型和基本类型可以直接使用&lt; &gt; ==</p>
</li>
</ol>
<h4 id="自动转型与强制转型"><a href="#自动转型与强制转型" class="headerlink" title="自动转型与强制转型"></a>自动转型与强制转型</h4><h5 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h5><p>容量小的数据类型可以自动转换为容量大的数据类型（容量指的是表数范围而不是字节数）；</p>
<p><img src="/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/java_language_01.png" alt="自动类型转换"></p>
<ul>
<li><p>实线表示无数据丢失的自动类型转换</p>
</li>
<li><p>虚线表示在转换过程可能出现精度损失</p>
<p>虽然float与double表示范围都远超过int与long，但是int与long都是全字节表示数字，float与double有部分字节表示正负与指数，这些字节被分担掉表示数字的字节，精确表示数字有限，所以转换时会有精度丢失。</p>
</li>
<li><p>特殊：可以将整型常量直接赋值给byte、short、char等类型变量，而不需要进行强制类型转换，只要不超过其表数范围。</p>
</li>
</ul>
<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>用于显式的转换一个数值的类型，当将一种类型强制转换为另一种类型而又超出了目标类型的表数范围，就会被截断成为一个完全不同的值。</p>
<p>强制类型转换：(转换类型)转换的变量，例：(char)(a+2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> s2 = s1 + <span class="number">2</span>;  <span class="comment">// 自动转换</span></span><br><span class="line"><span class="keyword">short</span> s3=(<span class="keyword">short</span>) s2;  <span class="comment">// 强转</span></span><br></pre></td></tr></table></figure>

<h3 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h3><blockquote>
<p>每种编程语言都有自己的数据处理方式。有些时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操作对象。所有这些在 Java 里都得到了简化，一切都被视为对象。因此，我们可采用一种统一的语法。尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。                                                                   《Java编程思想》</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"张三"</span>);</span><br></pre></td></tr></table></figure>

<p>有人会说，这里的person是一个对象，是Person类的一个实例。</p>
<p>也有人会说，这里的person并不是真正的对象，而是指向所创建的对象的引用。</p>
<p>到底哪种说法是对的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person;</span><br><span class="line">person = <span class="keyword">new</span> Person(<span class="string">"张三"</span>);</span><br></pre></td></tr></table></figure>

<p>这两行代码实现的功能和上面的一行代码是完全一样的。在Java中 new 是用来在堆上创建对象用的，如果person是一个对象的话，那么第二行为何还要通过new来创建对象呢？由此可见，person并不是所创建的对象，“操纵的标识符实际是指向一个对象的引用”，也就是说person是一个引用，是指向一个可以指向Person类的对象的引用。真正创建对象的语句是右边的new Person(“张三”);</p>
<ul>
<li>一个引用可以指向多个对象</li>
<li>一个对象也可以被多个引用所指</li>
</ul>
<p>从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：<strong>强引用</strong>、<strong>软引用</strong>、<strong>弱引用</strong>和<strong>虚引用</strong>。</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，<strong>垃圾回收器绝不会回收它</strong>。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<h4 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a><strong>软引用（SoftReference）</strong></h4><p>如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，<strong>如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<h4 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a><strong>弱引用（WeakReference）</strong></h4><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，<strong>不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<h4 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a><strong>虚引用（PhantomReference）</strong></h4><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，<strong>在任何时候都可能被垃圾回收</strong>。 虚引用主要用来跟踪对象被垃圾回收的活动。</p>
<p>虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<h3 id="动态代理与反射"><a href="#动态代理与反射" class="headerlink" title="动态代理与反射"></a>动态代理与反射</h3><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>在业务中使用动态代理，一般是为了给需要实现的方法添加预处理或者添加后续操作，但是不干预实现类的正常业务，把一些基本业务和主要的业务逻辑分离。我们一般所熟知的Spring的AOP原理就是基于动态代理实现的。</p>
<p><strong>目前java动态代理的实现分为两种</strong></p>
<ul>
<li><p>基于JDK的动态代理</p>
</li>
<li><p>基于CGILB的动态代理</p>
</li>
</ul>
<h5 id="基于JDK的动态代理"><a href="#基于JDK的动态代理" class="headerlink" title="基于JDK的动态代理"></a><strong>基于JDK的动态代理</strong></h5><ol>
<li><p>创建接口，并实现接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Person接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口的实现，并实现方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你好！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建代理类，实现 <strong>InvocationHandler</strong>接口，实现invoke方法，方法内调用代理对象的方法，可在前后注入非业务代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(PersonProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonProxy</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke调用原有方法，并在前后注入日志</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable 		</span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"------------- BEGIN ------------------"</span>);</span><br><span class="line">        Object invoke = method.invoke(<span class="keyword">this</span>.person, args);</span><br><span class="line">        LOGGER.info(<span class="string">"-------------  END  ------------------"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写实际调用类，这里用main方法。使用<strong>Proxy</strong>类创建代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person chinese = <span class="keyword">new</span> Chinese();</span><br><span class="line">        InvocationHandler proxy = <span class="keyword">new</span> PersonProxy(chinese);</span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        <span class="comment">// 参数1：代理类的类加载器</span></span><br><span class="line">        <span class="comment">// 参数2：实现类的接口，多个用数组</span></span><br><span class="line">        <span class="comment">// 参数3：代理类</span></span><br><span class="line">        Person person = (Person)Proxy.newProxyInstance(proxy.getClass().getClassLoader(), chinese.getClass().getInterfaces(), proxy);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        person.say();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\Java\jdk1<span class="number">.8</span><span class="number">.0_65</span>\bin\java </span><br><span class="line"><span class="number">11</span>:<span class="number">12</span>:<span class="number">35.918</span> [main] INFO com.example.demo.dto.PersonProxy - ------------- BEGIN ------------------</span><br><span class="line">你好！</span><br><span class="line"><span class="number">11</span>:<span class="number">12</span>:<span class="number">35.923</span> [main] INFO com.example.demo.dto.PersonProxy - -------------  END  ------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>Chinese</strong>类中只会输出“你好！”，但是在被代理之后，实际调用的方法是<strong>PersonProxy</strong>的<strong>invoke</strong>方法，这样可以在不修改业务类的情况下对业务类增加一些日志等其他操作，甚至可以直接修改有返回值方法的返回值。</p>
<p><strong>场景举例</strong>：<strong>Mybatis动态代理</strong></p>
<p><strong>Mybatis</strong> 的<strong>DeaultSqlSession</strong>中的<strong>getMapper</strong>方法开始，debug可知内部调用<strong>Configuration</strong> 的<strong>getMapper</strong>方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将将工作继续交到<strong>MapperRegistry</strong>的getMapper的方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到<strong>MapperRegistry</strong>的<strong>getMapper</strong>的方法,这里是通过<strong>MapperProxyFactory</strong>这个工厂生成我们所关注的<strong>MapperProxy</strong>的代理类，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后我们通过<strong>mapperProxyFactory.newInstance(sqlSession);</strong>进入<strong>MapperProxyFactory</strong>的<strong>newInstance</strong>方法中；我们看到这里使用了 <strong>Proxy.newProxyInstance</strong> 方法，这是 我们所说的 JDK动态代理方式创建代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">  <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<strong>MapperProxy</strong> 类，可以看到 其实现了InvocationHandler 接口，关注 invoke 方法中最终返回mapperMethod.execute(sqlSession, args);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    MapperMethod mapperMethod = methodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">      mapperMethod = <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration());</span><br><span class="line">      methodCache.put(method, mapperMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mapperMethod;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@UsesJava</span>7</span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">invokeDefaultMethod</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;MethodHandles.Lookup&gt; constructor = MethodHandles.Lookup<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">        .<span class="title">getDeclaredConstructor</span>(<span class="title">Class</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">      constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">    <span class="keyword">return</span> constructor</span><br><span class="line">        .newInstance(declaringClass,</span><br><span class="line">            MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED</span><br><span class="line">                | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC)</span><br><span class="line">        .unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Backport of java.lang.reflect.Method#isDefault()</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((method.getModifiers()</span><br><span class="line">        &amp; (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) == Modifier.PUBLIC)</span><br><span class="line">        &amp;&amp; method.getDeclaringClass().isInterface();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到类<strong>MapperMethod</strong>类的<strong>execute</strong>方法，发现<strong>execute</strong>中通过调用本类中的其他方法获取并封装返回结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName() </span><br><span class="line">          + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h5 id="基于CGLIB的动态代理"><a href="#基于CGLIB的动态代理" class="headerlink" title="基于CGLIB的动态代理"></a><strong>基于CGLIB的动态代理</strong></h5><p>基于JDK的动态代理，原对象一定要实现一个接口，而绝大部分情况原对象是一个POJO类，那么CGLIB就是一个很好的选择，在Hibernate框架中PO的字节码生产工作就是靠CGLIB来完成的。</p>
<ol>
<li><p>引入CGLIB的jar包。</p>
</li>
<li><p>创建被代理类。这里使用上面的<strong>Chinese</strong>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你好！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建方法拦截器，实现<strong>MethodInterceptor</strong>接口，对方法进行拦截处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(PersonInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"------------- BEGIN -----------"</span>);</span><br><span class="line">        <span class="comment">// 注意这里使用的是 invokeSuper方法</span></span><br><span class="line">        Object invoke = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        LOGGER.info(<span class="string">"-------------  END  -----------"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写实际调用类，利用<strong>Enhancer</strong>来创建被代理类对象，这样可以拦截方法，对方法进行前置和后置log的添加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// setSuperclass表示设置要代理的类</span></span><br><span class="line">	<span class="comment">// setCallback表示设置回调即MethodInterceptor的实现类</span></span><br><span class="line">	<span class="comment">// 使用create()方法生成一个代理对象，注意要强转一下，因为返回的是Object。</span></span><br><span class="line">       Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">       enhancer.setSuperclass(English<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       enhancer.setCallback(<span class="keyword">new</span> PersonInterceptor());</span><br><span class="line">       English english = (English)enhancer.create();</span><br><span class="line">       english.say();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span>:<span class="number">00</span>:<span class="number">40.809</span> [main] INFO com.example.demo.dto.PersonInterceptor - ------------- BEGIN -----------</span><br><span class="line">Hello World!</span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>:<span class="number">40.836</span> [main] INFO com.example.demo.dto.PersonInterceptor - -------------  END  -----------</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>总结：</strong></p>
<p><strong>Jdk动态代理</strong>的拦截对象是通过<strong>反射</strong>的机制来调用被拦截方法的，反射的效率比较低，所以cglib采用了<strong>FastClass</strong>的机制来实现对被拦截方法的调用（methodProxy.invokeSuper方法内部）。FastClass机制就是对一个类的方法建立索引，通过索引来直接调用相应的方法。</p>
<p><strong>FastClass</strong>有两个方法 getIndex() 和 invoke() 。</p>
<ul>
<li><strong>getIndex()方法</strong>：根据入参（方法名+方法的描述符），对Test的每个方法建立索引，并返回。</li>
<li><strong>invoke()方法</strong>：根据指定的索引，以ol为入参调用对象O的方法。这样就避免了反射调用，提高了效率。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FastClassInfo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    FastClass f1; <span class="comment">// net.sf.cglib.test.Target的fastclass</span></span><br><span class="line">    FastClass f2; <span class="comment">// Target$$EnhancerByCGLIB$$788444a0 的fastclass</span></span><br><span class="line">    <span class="keyword">int</span> i1; <span class="comment">//方法g在f1中的索引</span></span><br><span class="line">    <span class="keyword">int</span> i2; <span class="comment">//方法CGLIB$g$0在f2中的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MethodProxy 中的 invokeSuper 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeSuper</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">        MethodProxy.FastClassInfo fci = <span class="keyword">this</span>.fastClassInfo;</span><br><span class="line">        <span class="keyword">return</span> fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var4.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul>
<li><p><strong>JDK动态代理</strong>通过实现<strong>InvocationHandler</strong>接口创建自己的调用处理器；通过为<strong>Proxy</strong>类指定ClassLoader对象和一组interface来创建动态代理；</p>
<p><strong>CGLib动态代理</strong>使用<strong>Enhancer</strong>类中的<strong>create</strong>方法创建代理对象，<strong>MethodInterceptor</strong> 的实现类提供增强代码。</p>
</li>
<li><p><strong>JDK动态代理</strong>是面向接口的动态代理,被代理类必须实现接口。</p>
<p><strong>CGLib动态代理</strong>是基于子类的动态代理，被代理类不能为final类，方法也不能是final的。</p>
</li>
<li><p>如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）；</p>
<p>如果要被代理的对象不是个实现类那么，Spring会强制使用CGLib来实现动态代理。</p>
</li>
<li><p><strong>JDK动态代理</strong>通过实现该<strong>InvocationHandler</strong>接口定义横切逻辑（，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。</p>
<p><strong>CGLIB</strong>是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</p>
</li>
</ul>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>Java反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时调用任意一个对象的方法。</li>
<li>生成动态代理。</li>
</ul>
<p>Java中主要由以下的类来实现Java反射机制（这些类都位于java.lang.reflect包中）：</p>
<ul>
<li><strong>Class</strong>类：代表一个类。 </li>
<li><strong>Field</strong>类：代表类的成员变量（成员变量也称为类的属性）。</li>
<li><strong>Method</strong>类：代表类的方法。</li>
<li><strong>Constructor</strong>类：代表类的构造方法。</li>
<li><strong>Array</strong>类：提供了动态创建数组，以及访问数组的元素的静态方法。</li>
</ul>
<p><strong>Class</strong>类是Reflection API中的核心类，这里只列举其主要方法，其他方法可查看相应API：</p>
<ul>
<li><strong>getName</strong>()：获得类的完整名字。 getFields()：获得类的public类型的属性。</li>
<li><strong>getDeclaredFields</strong>()：获得类的所有属性。</li>
<li><strong>getMethods</strong>()：获得类的public类型的方法。</li>
<li><strong>getDeclaredMethods</strong>()：获得类的所有方法。</li>
<li><strong>getMethod</strong>(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes参数指定方法的参数类型。</li>
<li><strong>getConstrutors</strong>()：获得类的public类型的构造方法。</li>
<li><strong>getConstrutor</strong>(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes参数指定构造方法的参数类型。</li>
<li><strong>newInstance</strong>()：通过类的不带参数的构造方法创建这个类的一个对象。</li>
</ul>
<h5 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  	 <span class="comment">//1.源头：获取Class对象，用三种方式</span></span><br><span class="line">       Phone iPhone = <span class="keyword">new</span> Phone();</span><br><span class="line">       <span class="comment">//1.1.对象.getClass();获取对象</span></span><br><span class="line">       Class&lt;?&gt; clazz1 = iPhone.getClass();</span><br><span class="line">       <span class="comment">//1.2.类.class</span></span><br><span class="line">       clazz1 = Phone<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">       <span class="comment">//1.3.Class.forName("包名.类名");</span></span><br><span class="line">       clazz1 = Class.forName(<span class="string">"test.Phone"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建对象</span></span><br><span class="line">	<span class="comment">//2.1通过newInstence()</span></span><br><span class="line">       Phone instance1 = (Phone) clazz1.newInstance();</span><br><span class="line">       <span class="comment">//2.2先调用构造器，再通过newInstence()创建</span></span><br><span class="line">       Object instance2 = clazz1.getConstructor().newInstance();</span><br></pre></td></tr></table></figure>

<h5 id="效率提升"><a href="#效率提升" class="headerlink" title="效率提升"></a>效率提升</h5><p>由于反射方式动态创建类，所以效率比较低，例如 <strong>Class.forName</strong> 比较耗时，想要提升反射效率，可以有以下优化点：</p>
<ul>
<li><p>使用较高版本的JDK，Java开发团队一直有对反射优化；</p>
</li>
<li><p>善用API，例如：尽量不要<code>getMethods()</code>后再遍历筛选，而直接用<code>getMethod(methodName)</code>来根据方法名获取方法；</p>
</li>
<li><p>使用缓存，需要多次动态创建一个类的实例，可将其缓存起来，提高效率；</p>
</li>
<li><p>使用高性能的反射库；</p>
</li>
<li><p>field.setAccessible(true); 由于JDK的安全检查耗时较多.所以通过setAccessible(true)的方式关闭安全检查就可以达到提升反射速度的目的。 设置Field对象的Accessible的访问标志位为 true，就可以通过反射获取私有变量的值，在访问时会忽略访问修饰符的检查。这种方式 无法通过sonar 扫描，不推荐使用，实际可使用ReflectionUtils.makeAccessible(field);（未尝试） </p>
</li>
</ul>
<h3 id="常用集合"><a href="#常用集合" class="headerlink" title="常用集合"></a>常用集合</h3><p><img src="/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/java_language_02.gif" alt="Java集合框架图"></p>
<p>集合是一种工具类，就像是容器，储存任意数量的具有共同属性的对象。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>​    <strong>Collection</strong> 接口的接口 对象的集合（单列集合）<br>​    │——-<strong>List</strong> 接口：元素按进入先后有序保存，可重复<br>​    │—————-├ <strong>LinkedList</strong> 接口实现类， 链表， 插入删除， 没有同步， 线程不安全<br>​    │—————-├ <strong>ArrayList</strong> 接口实现类， 数组， 随机访问， 没有同步， 线程不安全<br>​    │—————-└ <strong>Vector</strong> 接口实现类 数组， 同步， 线程安全<br>​    │———————-└ <strong>Stack</strong> 是Vector类的实现类<br>​    │——-<strong>Set</strong> 接口： 仅接收一次，不可重复，并做内部排序<br>​    │—————-└<strong>HashSet</strong> 使用hash表（数组）存储元素<br>​    │————————└ <strong>LinkedHashSet</strong> 链表维护元素的插入次序<br>​    └ —————-<strong>TreeSet</strong> 底层实现为二叉树，元素排好序</p>
<p>​    <strong>Map</strong> 接口 键值对的集合 （双列集合）<br>​    │———<strong>Hashtable</strong> 接口实现类， 同步， 线程安全<br>​    │———<strong>HashMap</strong> 接口实现类 ，没有同步， 线程不安全-<br>​    │—————–├ <strong>LinkedHashMap</strong> 双向链表和哈希表实现<br>​    │—————–└ <strong>WeakHashMap</strong><br>​    │ ——–<strong>TreeMap</strong> 红黑树对所有的key进行排序<br>​    └ ———<strong>IdentifyHashMap</strong></p>
<p><strong>集合与数组对比</strong></p>
<ul>
<li>长度：数组固定，集合可变</li>
<li>内容：数组可以是基本类型和引用类型，集合只能是引用类型</li>
<li>元素内容：数组只能存储同一种类型元素；集合可以存储不同类型（一般存储同一类型）</li>
</ul>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p><strong>List</strong> 是一个接口，它继承于<strong>Collection</strong>的接口。它代表着<strong>有序</strong>的队列，元素可重复。</p>
<p><strong>ArrayList</strong>、 <strong>LinkedList</strong> 和 <strong>Vector</strong>都实现了List接口，是List的三种实现。</p>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><strong>ArrayList</strong></h5><p><strong>ArrayList</strong>实现<strong>List</strong>接口，继承<strong>AbstractList</strong>。</p>
<ul>
<li><p>底层是<strong>数组</strong>实现，在数组中搜索和读取数据是很快的。但是添加、删除时，该元素后面的所有元素都要移动，所以添加/删除数据效率不高。数组有容量，每次达到阈值需要扩容（1.5倍），这个操作比较影响效率。</p>
</li>
<li><p>是非线程安全的，一般用于单线程环境中（与<strong>Vector</strong>最大的区别就是，<strong>Vector</strong>是线程安全的，所以<strong>ArrayList</strong>比<strong>Vector</strong>的性能相对要好些），在多线程中，可以选择<strong>Vector</strong>或者<strong>CopyOnWriteArrayList</strong>。</p>
</li>
<li><p><strong>Arraylist</strong>实现了<strong>Serializable</strong>接口，支持序列化，能够通过序列化传输；</p>
</li>
<li><p>实现了<strong>RandomAccess</strong>接口（只是个标注接口，没有实际的方法），支持快速随机访问，主要变现为可以通过下标直接访问（因为<strong>Arraylist</strong>的底层是数组，可直接用数组下标来索引）；</p>
</li>
<li><p>实现了<strong>Cloneable</strong>接口，能被克隆。</p>
</li>
</ul>
<h5 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a><strong>ArrayList</strong> 源码分析</h5><p><strong>（JDK1.8，后面同上）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认初始容量大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认构造函数，空数组</span></span><br><span class="line"><span class="comment">    * 第一次 add()时，指定初始化长度 10 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">           <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">           <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">           <span class="comment">//创建空数组</span></span><br><span class="line">           <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">   * 如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       elementData = c.toArray();</span><br><span class="line">       <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">           <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">               <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// replace with empty array.</span></span><br><span class="line">           <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造方法：</strong></p>
<ul>
<li>无参构造器：初始化为空数组，第一次<strong>add</strong> 操作时，初始化容量。</li>
<li>指定容量构造器：直接初始化指定容量的数组。</li>
<li>指定Collection构造器：<strong>Arrays.copyOf</strong>  指定数组为传入集合数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 得到最小扩容量</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//判断是否需要扩容</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 要分配的最大数组大小,</span></span><br><span class="line"><span class="comment">    * 源码注释中说考虑到一些虚拟机存在数组元数据，占用8bytes的存储大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">       <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">      <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">      <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">       <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">       <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">       <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">       <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">           Integer.MAX_VALUE :</span><br><span class="line">           MAX_ARRAY_SIZE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><strong>add(e)</strong> 首先调用 <strong>ensureCapacityInternal</strong> 方法判断是否需要扩容，以及进行扩容操作，然后 将 元素 e 放入 数组末尾；</li>
<li><strong>ensureCapacityInternal</strong> 方法先比较 默认容量和传入参数（size + 1），取大值作为 <strong>最小扩容量</strong>，然后进入<strong>ensureExplicitCapacity</strong>方法判断是否需要扩容，如需要则调用 <strong>grow</strong> 方法进行扩容。</li>
<li><strong>grow</strong>是按照旧容量位运算右移一位，加上原容量，得到新容量大小，所以扩容大小为原来的 <strong>1.5 倍</strong>。如果扩容后的容量比最小扩容量小，则以最小扩容量为新容量。得到新容量后，再与<strong>MAX_ARRAY_SIZE</strong>比较，如果h还比其大，则设置最大容量为 <strong>Integer.MAX_VALUE</strong>。</li>
</ul>
<p><strong>ArrayList线程不安全的原因？替代方法？</strong></p>
<p>首先说一下什么是线程不安全：线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。</p>
<p><strong>ArrayList</strong>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">    * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">    * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">    * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<p>通过这两个字段我们可以看出，<strong>ArrayList</strong>的实现主要就是用了一个<strong>Object</strong>的数组，用来保存所有的元素，以及一个<strong>size</strong>变量用来保存当前数组中已经添加了多少元素。</p>
<p>观察源码可知：在多个线程进行<strong>add</strong>操作时可能会导致<strong>elementData</strong>数组越界，<strong>size ++</strong> 在多线程环同样会境下导致 数据问题，所以说 <strong>ArrayList</strong> 是线程不安全的。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>使用 <strong>Vector</strong></p>
</li>
<li><p>使用 <strong>Collections.synchronizedList</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> List&lt;Object&gt; arrayListSafe = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Object&gt;());</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用JUC中的<strong>CopyOnWriteArrayList</strong>类</p>
</li>
</ul>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><ul>
<li>基于双端链表，添加/删除元素只会影响周围的两个节点，开销很低；只能顺序遍历，无法按照索引获得元素，因此查询效率不高；没有固定容量，不需要扩容；</li>
<li>也是线程不安全的。线程安全可以使用 <strong>Collections.synchronizedList</strong>（类似<strong>ArrayList</strong>）。</li>
<li><strong>LinkedList</strong>实现了<strong>Serializable</strong>接口，支持序列化，能够通过序列化传输；</li>
<li>实现了<strong>Cloneable</strong>接口，能被克隆。</li>
<li>和<strong>ArrayList</strong> 一样，不是同步容器</li>
</ul>
<h5 id="LinkedList-源码分析"><a href="#LinkedList-源码分析" class="headerlink" title="LinkedList 源码分析"></a>LinkedList 源码分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到， <strong>LinkedList</strong> 的成员变量只有三个：</p>
<ul>
<li>头节点 <strong>first</strong></li>
<li>尾节点 <strong>last</strong></li>
<li>容量 <strong>size</strong></li>
</ul>
<p>节点是一个双向节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入到头部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取头节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//新建一个节点，尾部指向之前的 头元素 first</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">//first 指向新建的节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">//如果之前是空链表，新建的节点 也是最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//原来的第一个节点（现在的第二个）头部指向新建的头结点</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入到尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取尾部节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//新建一个节点，头部指向之前的 尾节点 last</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//last 指向新建的节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果之前是空链表， 新建的节点也是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//原来的尾节点尾部指向新建的尾节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 指定节点 前插入一个元素，这里假设 指定节点不为 null</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取指定节点 succ 前面的一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">//新建一个节点，头部指向 succ 前面的节点，尾部指向 succ 节点，数据为 e</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">//让 succ 节点头部指向 新建的节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">//如果 succ 前面的节点为空，说明 succ 就是第一个节点，那现在新建的节点就变成第一个节点了</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果前面有节点，让前面的节点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除头节点并返回该节点上的数据，假设不为 null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取数据，一会儿返回</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">//获取头节点后面一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">//使头节点上数据为空，尾部指向空</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">//现在头节点后边的节点变成第一个了</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">//如果头节点后面的节点为 null，说明移除这个节点后，链表里没节点了</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除尾部节点并返回，假设不为空</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="comment">//获取倒数第二个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">//尾节点数据、尾指针置为空</span></span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">//现在倒数第二变成倒数第一了</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除某个指定节点</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设 x 不为空</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="comment">//获取指定节点前面、后面的节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果前面没有节点，说明 x 是第一个</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//前面有节点，让前面节点跨过 x 直接指向 x 后面的节点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果后面没有节点，说 x 是最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//后面有节点，让后面的节点指向 x 前面的</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定位置的节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设指定位置有元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分一下，如果小于 size 的一半，从头开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//大于 size 一半，从尾部倒着遍历</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><ul>
<li><strong>Vector</strong> 的实现也是数组，继承了<strong>AbstractList</strong>，实现了<strong>List</strong>，支持相关的添加、删除、修改、遍历等功能。</li>
<li><strong>Vector</strong> 实现了<strong>RandmoAccess</strong>接口，即<strong>提供了随机访问功能</strong>。我们即可以通过元素的序号快速获取元素对象；</li>
<li><strong>Vector</strong> 实现了<strong>Cloneable</strong>接口，即实现clone()函数。它能被克隆。</li>
<li>和<strong>ArrayList</strong>不同，<strong>Vector中的操作是线程安全的</strong>。</li>
<li>Vector 默认容量是 10，当Vector容量不足以容纳全部元素时，Vector的容量会增加。<strong>若容量增加系数 &gt;0，则将容量的值增加到 “容量 + 系数”；否则，将容量大小增加一倍。</strong>（增加系数有构造器时指定）</li>
</ul>
<h5 id="Vector-源码分析"><a href="#Vector-源码分析" class="headerlink" title="Vector 源码分析"></a>Vector 源码分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 保存Vector中数据的数组</span></span><br><span class="line">    <span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际数据的数量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量增长系数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vector的序列版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2767605614048989439L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vector构造函数。默认容量是10。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定Vector容量大小的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定Vector"容量大小"和"增长系数"的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">// 新建一个数组，数组容量是initialCapacity</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="comment">// 设置容量增长系数</span></span><br><span class="line">        <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定集合的Vector构造函数。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取“集合(c)”的数组，并将其赋值给elementData</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">// 设置数组长度</span></span><br><span class="line">        elementCount = elementData.length;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, elementCount, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认“Vector容量”的帮助函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">// 当Vector的容量不足以容纳当前的全部元素，增加容量大小。</span></span><br><span class="line">        <span class="comment">// 若 容量增量系数&gt;0(即capacityIncrement&gt;0)，则将容量增大当capacityIncrement</span></span><br><span class="line">        <span class="comment">// 否则，将容量增大一倍。</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;</span><br><span class="line">            Object[] oldData = elementData;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = (capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                (oldCapacity + capacityIncrement) : (oldCapacity * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (newCapacity &lt; minCapacity) &#123;</span><br><span class="line">                newCapacity = minCapacity;</span><br><span class="line">            &#125;</span><br><span class="line">            elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定Vector的容量。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将Vector的改变统计数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置容量值为 newSize</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (newSize &gt; elementCount) &#123;</span><br><span class="line">            <span class="comment">// 若 "newSize 大于 Vector容量"，则调整Vector的大小。</span></span><br><span class="line">            ensureCapacityHelper(newSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若 "newSize 小于/等于 Vector容量"，则将newSize位置开始的元素都设置为null</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize ; i &lt; elementCount ; i++) &#123;</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elementCount = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><strong>Set</strong>继承于<strong>Collection</strong>接口，是一个不允许出现重复元素，并且无序的集合，主要有<strong>HashSet</strong>和<strong>TreeSet</strong>两大实现类。</p>
<p>在判断重复元素的时候，Set集合会调用<strong>hashCode</strong>()和<strong>equal</strong>()方法来实现。</p>
<h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><ul>
<li><strong>HashSet</strong>实现<strong>Set</strong>接口，底层由<strong>HashMap</strong>来实现，为哈希表结构；当有元素插入的时候，会计算元素的<strong>hashCode</strong>值，将元素插入到哈希表对应的位置中来；</li>
<li><strong>HashSet</strong>继承<strong>AbstractSet</strong>类，获得了Set接口大部分的实现，减少了实现此接口所需的工作，实际上是又继承了<strong>AbstractCollection</strong>类；</li>
<li><strong>HashSet</strong>实现<strong>Cloneable</strong>，得到了clone()方法，可以实现克隆功能；</li>
<li><strong>HashSet</strong>实现<strong>Serializable</strong>，表示可以被序列化，通过序列化去传输。</li>
<li>线程不安全。</li>
</ul>
<h5 id="HashSet-源码分析"><a href="#HashSet-源码分析" class="headerlink" title="HashSet 源码分析"></a>HashSet 源码分析</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment">     * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建指定容量的HashMap,传入集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建指定容量、指定负载因子的 HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建指定容量的 HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用map的 add 方法</span></span><br><span class="line"><span class="comment">     * 注意这里 元素为 HashMap 的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用map的remove 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a><strong>LinkedHashSet</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2851667679971038690L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.DISTINCT | Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="List和Set区别"><a href="#List和Set区别" class="headerlink" title="List和Set区别"></a>List和Set区别</h5><ul>
<li>有序性：<strong>List</strong> 有序；<strong>Set</strong>无序（元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）</li>
<li>唯一性：<strong>List</strong>可以重复；<strong>Set</strong>元素唯一，重复元素会覆盖掉</li>
<li>获取元素：<strong>List</strong>可以通过索引直接操作元素；<strong>Set</strong>不能</li>
<li>特点：<ul>
<li><strong>List</strong>：和数组类似，<strong>List</strong>可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</li>
<li><strong>Set</strong>：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li>
</ul>
</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><strong>Map</strong>用于保存具有映射关系的数据，<strong>Map</strong>里保存着两组数据：<strong>key</strong>和<strong>value</strong>，它们都可以使任何引用类型的数据，但key不能重复。所以通过指定的<strong>key</strong>就可以取出对应的<strong>value</strong>。区别于 <strong>Collection</strong> 的单列集合， <strong>Map</strong> 是双列集合。</p>
<p><strong>Map</strong> 的常用实现有：<strong>HashTable</strong>、<strong>HashMap</strong>（下面有<strong>LinkedHashMap</strong>）、<strong>TreeMap</strong>、<strong>IdentityHashMap</strong></p>
<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>HashMap</strong> 继承于<strong>AbstractMap</strong>，实现了<strong>Map</strong>接口，可以对它进行哈希表操作；</li>
<li>实现了<strong>Cloneable</strong>接口，能被克隆；</li>
<li>实现了<strong>Serializable</strong>接口，因此它支持序列化，能够通过序列化传输。</li>
<li><strong>HashMap</strong>是非线程安全的，只是用于单线程环境下，多线程环境下可以采用<strong>concurrent</strong>并发包下的<strong>concurrentHashMap</strong>。</li>
</ul>
<h5 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h5><p><strong>关键静态属性和成员变量：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap初始化容量的默认大小（16），必须是2的整数次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">// 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// HashMap初始化时的默认负载因子，基于准确率和资源浪费考虑，太小资源浪费，太大hash冲突几率大</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 将链表转为红黑树的阈值，当一个元素在被添加时，如果链表中的元素个数已经达到8个，则将链表转为红黑树形式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 将红黑树转为链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 链表被转化为红黑树时，哈希表最小的容量。为了避免冲突，该值至少为4 * TREEIFY_THRESHOLD</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储链表的数组，table在第一次使用时会进行初始化，如果有必要会有resize的操作</span></span><br><span class="line"><span class="comment">// table的大小总是2的整数次幂</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 保存entrySet()方法的缓存，要和AbstractMap的keySet()和values()区分，AbstractMap有自己的Set集合，来缓存这两个方法的返回值</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">// 键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// HsahMap结构的修改次数，用于fail-fast机制</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 下一次resize的阈值大小 = HashMap容量 * 负载因子</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//哈希表的负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p><strong>构造方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数指定了HashMap初始化时的容量以及负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数指定了HashMap初始化时的容量，负载因子使用默认负载因子0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 无参构造方法，默认的初始化容量为16，负载因子为默认的0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 根据其他Map来创建HashMap，负载因子为0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中需要注意构造器里的一个方法 ：<strong>tableSizeFor(initialCapacity)</strong> ,该方法的作用是，是返回<strong>大于输入参数且最近的2的整数次幂的数</strong>。比如输入10，则返回<strong>16</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">    * 补充知识点：</span></span><br><span class="line"><span class="comment">    * &gt;&gt;表示右移，如果该数为正，则高位补0，若为负数，则高位补1；</span></span><br><span class="line"><span class="comment">    * &gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里就涉及到一个常见问题： “<strong>为什么HashMap长度是2的幂次？</strong>”</p>
<p>原因是在于减少<strong>hash</strong>冲突，提高<strong>HashMap</strong>的效率。我们都知道<strong>HashMap</strong> 在查找某个元素时，需要根据<strong>key</strong>的<strong>hash</strong>值来求得对应数组中的位置。如何 计算这个位置就是 <strong>hash算法</strong>。<strong>HashMap</strong>的数据结构是<strong>数组+链表+红黑树</strong>，我们希望元素是均匀分布在每个位置上，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 </p>
<p>所以我们首先想到的就是把<strong>hashcode</strong>对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，<strong>java</strong>中使用了一种更高效的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先算得key 的hashcode值，</span></span><br><span class="line"><span class="comment">// 然后和（数组长度-1）做一次 “&amp;”运算</span></span><br><span class="line"><span class="comment">// 我们期望 （数组长度-1）二进制 全为 11111...</span></span><br><span class="line"><span class="comment">// 因为 &amp; 运算中 1 和 0 结果为 0， 0 和 0 结果也为 0 </span></span><br><span class="line"><span class="comment">// 而 1 和 1 结果为 1， 0 和 1 结果为 0</span></span><br><span class="line"><span class="comment">// 所以 固定数的二进制 每一位都为 1 可以减少 相同结果，降低 hash碰撞，提升效率</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HashMap的几个关键方法：put方法、get方法和remove方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若key为null，则直接返回0，否则通过h = key.hashCode()计算出key的hashcode，然后返回h ^ (h &gt;&gt;&gt; 16)的值。h &gt;&gt;&gt; 16为无符号向右移动16位，移位之后，h的高16位全部变成了0,这样做的好处是，低位的信息中混入了高位的信息，这样高位的信息被变相的保留了下来.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onlyIfAbsent为true时，则不覆盖key对应的value值，但是put在调用这个方法时，赋值为false，说明会覆盖原始value</span></span><br><span class="line"><span class="comment">// evict为false时，table处于创建模式，put在调用这个方法时，赋值为true</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table为null或者table长度为0，则通过resize方法来初始化table，其中，n为数组的长度</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash是计算出的节点在数组中的下标，若数组对应下标为null，则直接将节点赋值到tab[i]</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 若数组对应下标不为null，则表明发生了哈希冲突，其中，p为table[i]中的第一个节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果p节点与插入节点的hash和key相同，则e = p</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 否则，判断p节点是否为TreeNode，即判断链表是否已经调整为红黑树，若是的话，则通过putTreeVal来添加红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 否则，p为链表节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 在链表尾节点处插入新节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表节点个数在插入新的节点后，达到转为红黑树的阈值，则需要将链表转为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果插入节点和原链表中的某个key具有相同的hash且key相同，则停止查找</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e != null表明哈希表中已经存在键为key的节点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 若允许覆盖value值，或旧值为null，则更新key所对应的值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// HashMap结构修改次数加1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 若节点个数 &gt; threshold，则对table进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码中我们可以看出，<strong>HashMap</strong>的<strong>key</strong>和<strong>value</strong>都可以为<strong>null</strong>，因为在计算节点哈希值时，若<strong>key</strong>为<strong>null</strong>，则哈希值返回<strong>0</strong>，而且，插入元素时，会判断<strong>key</strong>对应的<strong>value</strong>是否为<strong>null</strong>，所以，<strong>key</strong>和<strong>value</strong>都可以为<strong>null</strong>。</p>
<p><strong>HashMap</strong>的扩容是通过 <strong>resize()</strong> 方法来完成的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化table或对table进行扩容</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果table的原容量 &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果原容量 &gt;= MAXIMUM_CAPACITY，则将阈值threshold修改为Integer.MAX_VALUE，并返回原table</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算新容量newCap = 原容量 * 2</span></span><br><span class="line">        <span class="comment">// 若newCap &lt; MAXIMUM_CAPACITY且旧容量oldCap &gt;= DEFAULT_INITIAL_CAPACITY，则新的阈值newThr = 旧阈值 * 2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，table的原容量为0，如果原阈值 &gt; 0，则新容量newCap = oldThr</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 否则，新容量newCap = DEFAULT_INITIAL_CAPACITY（16）</span></span><br><span class="line">    <span class="comment">// 新阈值newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY)</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果新阈值newThr为0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算阈值ft，ft = (float)newCap * loadFactor</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">// 根据ft来计算新阈值newThr</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 更新阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 创建新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">//更新table为newTab</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 如果原table不为null，则需要将原table中的节点复制到新table中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历原table数组，j为下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 原table的j下标存有节点，e为头结点</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将原table[j]处置为null，释放空间</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果e没有后继节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 将e赋值给新table对应的首节点</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果e为红黑树节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 重构红黑树结构到新table中</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// e为链表节点</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 将同一链表中的元素根据(e.hash &amp; oldCap)是否为0进行分割，分成两个不同的链表，完成rehash</span></span><br><span class="line">                    <span class="comment">// 若(e.hash &amp; oldCap)为0，则该节点在新table中的下标不变</span></span><br><span class="line">                    <span class="comment">// 若(e.hash &amp; oldCap)不为0，则该节点在新table中的下标变为j + oldCap</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新table</span></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的源码可知，<strong>HashMap</strong> 触发扩容的条件是：</p>
<ul>
<li>数组长度大于阈（yu）值 （= 容量 * 负载因子，例如容量为16，负载因子为 .75f ,则 阈值为 12）；</li>
<li>且 发生 <strong>hash</strong> 碰撞 。</li>
</ul>
<p>扩容大小为 原容量 的 <strong>2 倍</strong>。</p>
<p><strong>HashMap</strong>的<strong>refresh</strong>：</p>
<p><img src="/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/java_language_05.png" alt="HashMap的refresh"></p>
<ul>
<li><strong>rehash</strong> 方法 将数组扩容后，会将原来的元素重新计算，放入新位置，判断依据为 <ul>
<li>// 将同一链表中的元素根据<strong>(e.hash &amp; oldCap)</strong>是否为<strong>0</strong>进行分割，分成两个不同的链表，完成<strong>rehash</strong></li>
<li>// 若<strong>(e.hash &amp; oldCap)</strong>为<strong>0</strong>，则该节点在新table中的下标不变</li>
<li>// 若<strong>(e.hash &amp; oldCap)</strong>不为<strong>0</strong>，则该节点在新table中的下标变为  <strong>j + oldCap</strong></li>
</ul>
</li>
<li>由此看来扩容是一个比较耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用<strong>HashMap</strong>的时，最好能提前预估下<strong>HashMap</strong>中元素的个数，这样有助于提高<strong>HashMap</strong>的性能。</li>
</ul>
<p><strong>get(Object key)方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove(Object key)方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Node节点结构：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"> </span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">    <span class="comment">// 节点的哈希值等于key和value的哈希值求异或</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将链表转为红黑树之后，节点不再以<strong>Node</strong>方式存储，而被转化为了<strong>TreeNode</strong>节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="comment">// 左节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    <span class="comment">// 右节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    <span class="comment">// 删除节点时，需要断开链接，这个节点记录了删除节点的前一个节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 返回当前节点的树根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/java_language_04.png" alt="HashMap结构图"></p>
<h3 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h3><p><strong>异常</strong>指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。<strong>Java</strong>通 过API中<strong>Throwable</strong>类的众多子类描述各种不同的异常。因而，<strong>Java</strong>异常都是对象，是<strong>Throwable</strong>子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。</p>
<p><img src="/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/java_language_06.png" alt="异常类层次机构图"></p>
<p><strong>Throwable：</strong> 有两个重要的子类：<strong>Exception</strong>（异常）和 <strong>Error</strong>（错误）。</p>
<ul>
<li><strong>Error (错误)</strong>：是程序无法处理的错误，表示运行应用程序中较严重问题。<strong>大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题</strong>。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</li>
<li><strong>Exception (异常)</strong>： <strong>是程序本身可以处理的异常</strong>。<strong>Exception</strong> (异常) 按照性质又分为 <strong>编译异常</strong>（可检查）和<strong>运行时异常</strong>（不可检查）</li>
</ul>
<p><strong>编译时异常：</strong></p>
<p>又叫<strong>可检查异常</strong>，通常是由语法错误和环境因素（外部资源）造成的异常。比如输入输出异常<strong>IOException</strong>，数据库操作<strong>SQLException</strong>。其特点是，<strong>Java语言强制要求捕获和处理所有非运行时异常</strong>。通过行为规范，强化程序的健壮性和安全性。</p>
<p><strong>运行时异常：</strong></p>
<p>又叫<strong>不可检查异常</strong>(RuntimeException)，这些异常一般是由程序逻辑错误引起的，即语义错。比如算术异常，空指针异常<strong>NullPointerException</strong>，下标越界<strong>IndexOutOfBoundsException</strong>。运行时异常应该在程序测试期间被暴露出来，由程序员去调试，而避免捕获。</p>
<p><strong>异常处理程序机制：</strong></p>
<ul>
<li>抛出异常；</li>
<li>try-catch-finally 捕获和处理异常</li>
</ul>
<p><strong>如何选择异常？</strong></p>
<p>考虑这个异常出现之后是否调用者可以处理，并且你是否希望调用者进行处理，如果调用者可以处理，并且你也希望调用者进行处理，那么就要抛出<strong>受检异常</strong>，提醒调用者在使用你的方法时，考虑到如果抛出异常时如果进行处理，相似的，如果在写某个方法时，你认为这是个偶然异常，理论上说，你觉得运行时可能会碰到什么问题，而这些问题也许不是必然发生的，也不需要调用者显示的通过异常来判断业务流程操作的，那么这时就可以使用一个RuntimeException这样的<strong>非受检异常.</strong></p>
<p><strong>什么 时候抛异常？</strong></p>
<p>如果你觉得某些”问题”解决不了了，那么你就可以抛出异常了。比如，你在写一个service,其中在写到某段代码处,你发现可能会产生问题，那么就需要抛出异常。或者说该问题程序无法处理，需要告知用户处理，例如：文件不存在等。</p>
<p><strong>常见问题：</strong></p>
<p><strong>finally</strong>关键字中出现<strong>return</strong>等关键字导致的程序执行顺序问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">//出现异常</span></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;<span class="keyword">catch</span>(..)&#123;</span><br><span class="line">  a=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  a=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序返回：2</span></span><br><span class="line"><span class="comment">// 因为 finally语句块是最后执行</span></span><br></pre></td></tr></table></figure>

<h3 id="注解机制"><a href="#注解机制" class="headerlink" title="注解机制"></a>注解机制</h3><p><strong>Java</strong>注解是JDK1.5引入的一种注释机制，java语言的类、方法、变量、参数和包都可以被注解标注。和Javadoc不同，java注解可以通过反射获取标注内容。</p>
<p>在编译器生成<strong>.class</strong>文件时，注解可以被嵌入字节码中，而jvm也可以保留注解的内容，在运行时获取注解标注的内容信息。</p>
<p>完整的注解（从编写到最终运行）需要三方面的参与。</p>
<ul>
<li>需要定义一个注解。</li>
<li>需要一个被贴的程序元素（类，方法，字段，构造器等）</li>
<li>第三方程序的支持（赋予我注解的特殊功能）</li>
</ul>
<h4 id="JDK内置注解"><a href="#JDK内置注解" class="headerlink" title="JDK内置注解"></a>JDK内置注解</h4><table>
<thead>
<tr>
<th>注解名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>@Override</td>
<td>检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</td>
</tr>
<tr>
<td>@Deprecated</td>
<td>标记过时方法。如果使用该方法，会报编译警告。</td>
</tr>
<tr>
<td>@SuppressWarnings</td>
<td>指示编译器去忽略注释解中声明的警告。</td>
</tr>
<tr>
<td>@FunctionalInterface</td>
<td>java8支持，标识一个匿名函数或函数式接口。</td>
</tr>
</tbody></table>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>是指 <strong>注解的注解</strong>，可以在注解接口中使用的注解。</p>
<p>常见元注解：</p>
<ul>
<li><p><strong>@Target</strong> 表示该注解用于什么地方，可能的值在枚举类 <strong>ElemenetType</strong> 中，包括：</p>
<p> ElemenetType.<strong>CONSTRUCTOR</strong>—————————–构造器声明<br> ElemenetType.<strong>FIELD</strong> ———————————-域声明（包括 enum 实例）<br> ElemenetType.<strong>LOCAL_VARIABLE</strong>————————- 局部变量声明<br> ElemenetType.<strong>METHOD</strong> ———————————方法声明<br> ElemenetType.<strong>PACKAGE</strong> ——————————–包声明<br> ElemenetType.<strong>PARAMETER</strong> ——————————参数声明<br> ElemenetType.<strong>TYPE</strong>———————————– 类，接口（包括注解类型）或<strong>enum</strong>声明 </p>
</li>
<li><p><strong>@Retention</strong> 表示在什么级别保存该注解信息。可选的参数值在枚举类型 <strong>RetentionPolicy</strong> 中，包括：</p>
<p> RetentionPolicy.<strong>SOURCE</strong>————-注解将被编译器丢弃<br> RetentionPolicy.<strong>CLASS</strong> ————-注解在class文件中可用，但会被VM丢弃<br> RetentionPolicy.<strong>RUNTIME</strong> ———VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。</p>
</li>
<li><p><strong>@Documented</strong> 将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。相当与@see,@param 等。</p>
</li>
<li><p><strong>@Inherited</strong> 允许子类继承父类中的注解。</p>
</li>
<li><p><strong>@Repeatable</strong>标识某注解可以在同一个声明上使用多次</p>
</li>
</ul>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>第一步：创建注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如创建属性注解</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestFieldAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：使用注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性上添加注解</span></span><br><span class="line">    <span class="meta">@TestFieldAnnotation</span>(description = <span class="string">"这是一个名字字段"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestFieldAnnotation</span>(description = <span class="string">"这是一个年龄字段"</span>)</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：解析（常与AOP一起用，这里简单案例）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取全部属性</span></span><br><span class="line">        Field[] fields = UserDTO<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredFields</span>()</span>;</span><br><span class="line">        <span class="comment">// 遍历属性</span></span><br><span class="line">        Stream.of(fields).forEach(field -&gt; &#123;</span><br><span class="line">            <span class="comment">// 判断属性上是否有该注解</span></span><br><span class="line">            <span class="keyword">boolean</span> annotationPresent = </span><br><span class="line">                    field.isAnnotationPresent(TestFieldAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (annotationPresent) &#123;</span><br><span class="line">                TestFieldAnnotation annotation = </span><br><span class="line">                        field.getAnnotation(TestFieldAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="comment">// 打印注解description</span></span><br><span class="line">                System.out.println(annotation.description());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="版本差异与新特性"><a href="#版本差异与新特性" class="headerlink" title="版本差异与新特性"></a>版本差异与新特性</h3><p><img src="/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/java_language_03.png" alt="版本差异"></p>
<p>其中<strong>Java</strong> 的 <strong>1.8</strong> 和  <strong>1.11</strong> 版本为长期支持版本，重点关注其新特性。</p>
<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p><strong>关于函数式接口</strong></p>
<ol>
<li>如果一个接口只有一个抽象方法，那么这个接口就是函数式接口。（<strong>Java8</strong>开始接口可以存在接口方法的实现，即为默认方法）</li>
<li>如果一个接口上声明了@<strong>FunctionInterface</strong>，那么编译器就会按照函数式接口定义要求该接口；</li>
<li>如果一个接口只有一个抽象方法，但是没有声明@<strong>FunctionInterface</strong>,编译器仍然会将之看作为函数式接口；</li>
<li>函数式接口的实例可以用<strong>Lambda</strong>表达式，方法引用或构造方法创建。</li>
</ol>
<p>为什么设计函数式接口？</p>
<p>​        配合<strong>Lambda</strong>表达式，使得<strong>Java8</strong>中能够传递方法过程，即 <strong>函数式编程</strong>。</p>
<p>​        在函数式编程语言中，<strong>Lambda</strong>表达式的类型是函数，但是在Java中，<strong>Lambda</strong>表达式实际上是对象，它们必须依附于一类特别的对象类型：函数式接口。</p>
<p>Java内置四大常用核心函数式接口（java.util.function）</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
<th>Stream方法</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer<T>消费型</T></td>
<td>T</td>
<td>Void</td>
<td>对参数进行操作，void accept(T t)</td>
<td>forEach</td>
</tr>
<tr>
<td>Supplier<T>供给型</T></td>
<td>无</td>
<td>T</td>
<td>返回类型为T的对象，T get()</td>
<td>orElse</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;函数型</td>
<td>T</td>
<td>R</td>
<td>对T类型参数操作返回R类型结果</td>
<td>map</td>
</tr>
<tr>
<td>Predicate<T>判定型</T></td>
<td>T</td>
<td>boolean</td>
<td>判断T类型参数是否满足某一约束</td>
<td>filter</td>
</tr>
</tbody></table>
<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p><strong>Java Lambda</strong>表达式<em>的一个重要用法是简化某些</em>匿名内部类<strong>（<code>Anonymous Classes</code>）</strong>的写法。</p>
<p><strong>无参函数：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK7 匿名内部类写法</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;<span class="comment">// 接口名</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;<span class="comment">// 方法名</span></span><br><span class="line">		System.out.println(<span class="string">"Thread run()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK8 Lambda表达式写法</span></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">		() -&gt; System.out.println(<span class="string">"Thread run()"</span>)<span class="comment">// 省略接口名和方法名</span></span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<p><strong>带参函数：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK7 匿名内部类写法</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;<span class="comment">// 接口名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span></span>&#123;<span class="comment">// 方法名</span></span><br><span class="line">        <span class="keyword">if</span>(s1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK8 Lambda表达式写法</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">Collections.sort(list, (s1, s2) -&gt;&#123;<span class="comment">// 省略参数表的类型</span></span><br><span class="line">    <span class="keyword">if</span>(s1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码跟匿名内部类的作用是一样的。除了省略了接口名和方法名，代码中把参数表的类型也省略了。这得益于<code>javac</code>的<strong>类型推断</strong>机制，编译器能够根据上下文信息推断出参数的类型，当然也有推断失败的时候，这时就需要手动指明参数类型了。</p>
<p>也许你已经想到了，<strong>能够使用Lambda的依据是必须有相应的函数接口</strong>（<strong>函数接口，</strong>是指内部只有一个抽象方法的接口）。这一点跟<strong>Java</strong>是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写<strong>Lambda</strong>表达式。实际上<strong>Lambda</strong>的类型就是对应函数接口的类型。<strong>Lambda表达式另一个依据是类型推断机制</strong>，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。Lambda表达更多合法的书写形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lambda表达式的书写形式</span></span><br><span class="line">Runnable run = () -&gt; System.out.println(<span class="string">"Hello World"</span>);<span class="comment">// 1</span></span><br><span class="line">ActionListener listener = event -&gt; System.out.println(<span class="string">"button clicked"</span>);<span class="comment">// 2</span></span><br><span class="line">Runnable multiLine = () -&gt; &#123;<span class="comment">// 3 代码块</span></span><br><span class="line">    System.out.print(<span class="string">"Hello"</span>);</span><br><span class="line">    System.out.println(<span class="string">" Hoolee"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">BinaryOperator&lt;Long&gt; add = (Long x, Long y) -&gt; x + y;<span class="comment">// 4</span></span><br><span class="line">BinaryOperator&lt;Long&gt; addImplicit = (x, y) -&gt; x + y;<span class="comment">// 5 类型推断</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义函数式接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义函数接口，</span></span><br><span class="line"><span class="comment">// 注解可选，但加上该标注编译器会帮你检查接口是否符合函数接口规范</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerInterface</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">ConsumerInterface&lt;String&gt; consumer = str -&gt; System.out.println(str);</span><br></pre></td></tr></table></figure>

<p><strong>集合中Lambda的使用：</strong></p>
<p>为引入<strong>Lambda</strong>表达式，<strong>Java8</strong>新增了<code>java.util.funcion</code>包，里面包含常用的<strong>函数接口</strong>，这是<strong>Lambda</strong>表达式的基础，<strong>Java</strong>集合框架也新增部分接口，以便与<strong>Lambda</strong>表达式对接。</p>
<table>
<thead>
<tr>
<th align="left">接口名</th>
<th align="left">Java8新加入的方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Collection</td>
<td align="left">removeIf() spliterator() stream() parallelStream() forEach()</td>
</tr>
<tr>
<td align="left">List</td>
<td align="left">replaceAll() sort()</td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge()</td>
</tr>
</tbody></table>
<p><strong>举例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.forEach( str -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用removeIf()结合Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.removeIf(str -&gt; str.length()&gt;<span class="number">3</span>); <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.replaceAll(str -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// List.sort()方法结合Lambda表达式</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.sort((str1, str2) -&gt; str1.length()-str2.length());</span><br></pre></td></tr></table></figure>

<p><strong>拓展知识点：</strong></p>
<p>《阿里巴巴Java开发手册》中提到 谨慎使用 <strong>Arrays.asList</strong> 和 <strong>ArrayList 的 subList方法</strong>，原因如下：</p>
<ol>
<li><p><strong>Arrays.asList</strong> 方法 返回的 <strong>ArrayList</strong> 是 <strong>Arrays</strong> 的内部类（也叫<strong>ArrayList</strong>），但并非<code>java.util</code>包下的 <strong>ArrayList</strong>，其并未重写 <strong>add</strong> 方法，使用 <strong>add</strong> 方法添加元素时 ,会抛出 <strong>UnsupportedOperationException</strong> 异常。</p>
<p>不过在某些场景下可以使用，例如声明后不调用<strong>add</strong>方法的场景，比如 <strong>contains</strong> 判断是否包含某一元素的场景，因为其重写了 <strong>contains</strong> 方法。</p>
<p>改进方法，可以使用   <code>new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</code> 新建一个 <strong>ArrayList</strong>对象。</p>
</li>
<li><p><strong>ArrayList 的 subList方法</strong> 返回的 是<strong>ArrayList</strong>的部分视图，并非返回一个新的<strong>ArrayList</strong> ，所以会造成以下问题：</p>
<ol>
<li>修改原集合元素的值，会影响子集合</li>
<li>修改原集合的结构，会引起 <strong>ConcurrentModificationException</strong> 异常</li>
<li>修改子集合元素的值，会影响原集合</li>
<li>修改子集合的结构，会影响原集合</li>
</ol>
</li>
</ol>
<h4 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h4><p><strong>Stream</strong> 是<strong>Java8</strong>中处理集合的关键抽象概念，它可以对集合进行非常复杂的<strong>查找、过滤、筛选</strong>等操作。</p>
<p>使用 <strong>Stream API</strong>对集合数据进行操作就类似于使用<strong>SQL</strong>进行数据库查询；</p>
<p>简而言之，<strong>Stream API</strong> 提供了一种高效且易于使用的数据处理方式。</p>
<p><strong>概念</strong></p>
<p><strong>流</strong> 是数据渠道，用于操作数据源（集合，数组等）所生成的元素序列。</p>
<p>集合讲的是<strong>数据</strong>，流讲的是<strong>计算</strong>。</p>
<ul>
<li><strong>Stream</strong> 自己不会存储元素，需要通过数据源来构造</li>
<li><strong>Stream</strong> 的操作时延迟执行的，等到需要结果的时候才执行，即在存在终止操作时才会真正执行。</li>
</ul>
<p><strong>并行流（parallelStream）</strong> 与 <strong>串行流（默认生成的Stream</strong> </p>
<p><strong>并行流</strong> 就是把一个内容分成多个数据块，并用不同线程分别处理每个数据块的流，因此可以对数据进行多线程并行操作。</p>
<p><strong>Stream</strong> 的使用步骤：</p>
<ol>
<li><p><strong>源操作</strong>（创建<strong>Stream</strong>）：从一个数据源获得流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream();</span><br><span class="line">Stream.of(array);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>中间操作</strong>：一个中间操作链条，对数据源进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter(),map(),distinct()等</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>终止操作</strong>：执行中间操作链，产生一个结果。</p>
<p>注意：一个流经过终止操作后，不能再次进行其他任何操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">count(),findAny(),collect()等</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="常见源操作"><a href="#常见源操作" class="headerlink" title="常见源操作"></a><strong>常见源操作</strong></h5><ul>
<li><p><strong>Collection</strong>接口 被扩展，提供了俩个获取流的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个顺序流</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回一个并行流</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> ParallelStream&lt;E&gt; <span class="title">stream</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">list.stream();</span><br></pre></td></tr></table></figure>
</li>
<li><p>由数组创建流：<strong>Arrays</strong> 的静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态方法返回一个流</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Arrays.stream(arr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>由值创建流：使用 <strong>Stream</strong>的静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Stream.of(list);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="常见中间操作"><a href="#常见中间操作" class="headerlink" title="常见中间操作"></a>常见中间操作</h5><p><strong>Stream</strong> 的多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会进行任何处理，而是在终止操作时一次性全部处理，称为 “<strong>惰性求值</strong>“。</p>
<ul>
<li><p>筛选与切片</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter(Predicate p);<span class="comment">// 从流中排除某些元素</span></span><br><span class="line">distinct();<span class="comment">// 筛选，通过流中的元素 hashCode\equals方法去重</span></span><br><span class="line">limit(Long maxSize);<span class="comment">// 截断流，使其元素数量不超过 maxSize</span></span><br><span class="line">skip(<span class="keyword">long</span> n);<span class="comment">// 跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，返回一个空流，与limit(n)互补</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>映射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map(Function f); <span class="comment">// 通过f方法作用于流中的每个元素，获得队形的f方法的执行结果组成一个新的流</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sorted();<span class="comment">// 将流中的元素进行自然排序，产生一个新的流</span></span><br><span class="line">sorted(Comparator comp);<span class="comment">// 使用比较器进行排序产生一个新的流</span></span><br><span class="line"><span class="comment">// 默认升序排序，降序用reversed()</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="常见终止操作"><a href="#常见终止操作" class="headerlink" title="常见终止操作"></a>常见终止操作</h5><p><strong>Stream</strong> 的终止操作会将流生成一个结果，结果可以是任何不为流 的值，如<strong>List,Integer,void</strong> 等。</p>
<ul>
<li><p>匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查流中的元素是否全部匹配p的约束</span></span><br><span class="line"><span class="function">Boolean <span class="title">allMatch</span><span class="params">(Predicte p)</span></span>;</span><br><span class="line"><span class="comment">// 至少一个元素匹配</span></span><br><span class="line"><span class="function">Boolean <span class="title">anyMatch</span><span class="params">(Predicte p)</span></span>;</span><br><span class="line"><span class="comment">// 均不匹配</span></span><br><span class="line"><span class="function">Boolean <span class="title">noneMatch</span><span class="params">(Predicte p)</span></span>;</span><br><span class="line"><span class="comment">// 返回流中的第一个元素</span></span><br><span class="line"><span class="function">Optional <span class="title">findFirst</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回流中的任意一个元素</span></span><br><span class="line"><span class="function">Optional <span class="title">fundAny</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回流中元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 流中的元素经过比较器排序后，返回流中的最大值的元素</span></span><br><span class="line">max(Comparator comp);</span><br><span class="line"><span class="comment">// 流中的元素经过比较器排序后，返回流中的最小值的元素</span></span><br><span class="line">min(Comparator comp);</span><br><span class="line"><span class="comment">// 遍历操作</span></span><br><span class="line">forEach();</span><br></pre></td></tr></table></figure>
</li>
<li><p>归约</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reduce(T t,BinaryOperator b);<span class="comment">// 将流中元素反复结合起来得到一个值</span></span><br><span class="line">reduce(BinaryOperator b);<span class="comment">// 得到一个Optional的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>收集：<strong>Collection(Collector c)</strong>:将流转换成为其他形式。接受一个<strong>Collector</strong>接口的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collector 接口的实现方法决定了如何对流进行收集操作，Collectors(java.util.stream.Collectors)工具类提供了很多静态方法，方便创建收集器示例</span></span><br><span class="line"></span><br><span class="line">toList()/toSet(); <span class="comment">// 将流中元素收集到list，默认是ArrayList/HashSet</span></span><br><span class="line">toCollection(()-&gt;<span class="keyword">new</span> LinkedList); <span class="comment">// 将流中元素收集到LinkedList</span></span><br><span class="line">joining(); <span class="comment">// 连接流中的每个字符串</span></span><br><span class="line">groupingBy(); <span class="comment">// 根据某一属性值对流中的元素进行分组，属性值为k，元素为v</span></span><br><span class="line">collectingAndThen(); <span class="comment">// 包裹另一个收集器，对其这个收集器的结果在进行一次收集转换</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><p>从 <strong>Java 8</strong> 引入的一个很有趣的特性是 <strong><em>Optional</em></strong>  类。<strong>Optional</strong> 类主要解决的问题是臭名昭著的空指针异常（<strong>NullPointerException</strong>）    </p>
<p><strong>创建 Optional 实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Optional.empty() 创建一个空的 Optional 实例</span></span><br><span class="line">Optional&lt;User&gt; emptyOpt = Optional.empty();</span><br><span class="line">emptyOpt.get(); <span class="comment">// 也会抛出 NPE 异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用of() 和 ofNullable() 创建包含值的 Optional</span></span><br><span class="line">Optional&lt;User&gt; opt = Optional.of(user); <span class="comment">// 如果user 为null，会抛出NPE</span></span><br><span class="line">Optional&lt;User&gt; opt = Optional.ofNullable(user); <span class="comment">// 与of() 不同，允许user 为null</span></span><br><span class="line">Assert.isTrue(opt.isPresent(),<span class="string">"对象不可为空"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>访问 Optional 实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用orElse() 与 orElseGet()区别：如果对象非空, orElse() 方法仍然创建了 User 对象。与之相反，orElseGet() 方法不创建 User 对象。</span></span><br><span class="line">User user = <span class="keyword">null</span>;</span><br><span class="line">User result = Optional.ofNullable(user).orElse(() -&gt; <span class="keyword">new</span> User());</span><br><span class="line">User result2 = Optional.ofNullable(user).orElseGet(() -&gt; <span class="keyword">new</span> User());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用orElseThrow()</span></span><br><span class="line">User result = Optional.ofNullable(user)</span><br><span class="line">      .orElseThrow( () -&gt; <span class="keyword">new</span> IllegalArgumentException());</span><br></pre></td></tr></table></figure>

<p><strong>值转换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用map() 值转换</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"test@gmail.com"</span>, <span class="string">"1234"</span>);</span><br><span class="line">String email = Optional.ofNullable(user)</span><br><span class="line">    .map(u -&gt; u.getEmail()).orElse(<span class="string">"default@gmail.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用filter() 值过滤</span></span><br><span class="line">Optional&lt;User&gt; result = Optional.ofNullable(user)</span><br><span class="line">      .filter(u -&gt; u.getEmail() != <span class="keyword">null</span> &amp;&amp; u.getEmail().contains(<span class="string">"@"</span>));</span><br></pre></td></tr></table></figure>

<p><strong>Java 9 增强</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java 9 为 Optional 类添加了三个方法：or()、ifPresentOrElse() 和 stream()。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or() 的返回值是由 Supplier 参数产生的另一个 Optional 对象。如果对象包含值，则 Lambda 表达式不会执行。</span></span><br><span class="line">User result = Optional.ofNullable(user)</span><br><span class="line">      .or( () -&gt; Optional.of(<span class="keyword">new</span> User(<span class="string">"default"</span>,<span class="string">"1234"</span>))).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ifPresentOrElse()</span></span><br><span class="line">Optional.ofNullable(user).ifPresentOrElse( u -&gt; logger.info(<span class="string">"User is:"</span> + u.getEmail()),</span><br><span class="line">  () -&gt; logger.info(<span class="string">"User not found"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过把实例转换为 Stream 对象，让你从强大的 Stream API 中受益。</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"john@gmail.com"</span>, <span class="string">"1234"</span>);</span><br><span class="line">List&lt;String&gt; emails = Optional.ofNullable(user)</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(u -&gt; u.getEmail() != <span class="keyword">null</span> &amp;&amp; u.getEmail().contains(<span class="string">"@"</span>))</span><br><span class="line">    .map( u -&gt; u.getEmail())</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>Java语言特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语言特性与设计模式（二）</title>
    <url>/2021/01/26/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Java语言特性与设计模式（二）"><a href="#Java语言特性与设计模式（二）" class="headerlink" title="Java语言特性与设计模式（二）"></a>Java语言特性与设计模式（二）</h1><p><strong>设计模式（Design pattern）</strong>是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 </p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>设计模式分为 3 大类型共 23 种：</p>
<ul>
<li><p><strong>创建型</strong>：<strong>对象实例化的模式，创建型模式用于解耦对象的实例化过程。</strong>有工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
</li>
<li><p><strong>结构型</strong>：<strong>把类或对象结合在一起形成一个更大的结构。</strong>有适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
</li>
<li><p><strong>行为型</strong>：<strong>类和对象如何交互，及划分责任和算法。</strong>策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
</li>
</ul>
<p><strong>常用设计模式：</strong></p>
<p><img src="/2021/01/26/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/design_patterns_01.png" alt="常用设计模式"></p>
<p>下面将提炼出最常见设计模式详细了解，主要分为俩个方向：</p>
<ul>
<li><p>–    了解设计模式的实现</p>
</li>
<li><p>–    列举设计模式使用场景（框架）</p>
</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。<strong>通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。</strong></p>
<p>（1）将<strong>构造方法私有化</strong>，使其不能在类的外部通过new关键字实例化该类对象。</p>
<p>（2）在该类<strong>内部产生一个唯一的实例化对象，并且将其封装为private static类型</strong>。</p>
<p>（3）<strong>定义一个静态方法返回这个唯一对象</strong>。</p>
<p><strong>四种代理实现</strong></p>
<ul>
<li>饿汉模式</li>
<li>懒汉模式</li>
<li>线程安全的懒汉模式</li>
<li>DCL双检查锁机制（double check locking）</li>
</ul>
<h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自身实例化对象设置为一个属性，并用static、final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法返回该实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自身实例化对象设置为一个属性，并用static修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法返回该实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程安全的“懒汉模式”"><a href="#线程安全的“懒汉模式”" class="headerlink" title="线程安全的“懒汉模式”"></a>线程安全的“懒汉模式”</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自身实例化对象设置为一个属性，并用static修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法返回该实例，加synchronized关键字实现同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多线程情形下，<strong>synchronized方法</strong>通常效率低，因此这不是最佳的实现方案。</p>
<h4 id="DCL双检查锁机制"><a href="#DCL双检查锁机制" class="headerlink" title="DCL双检查锁机制"></a>DCL双检查锁机制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自身实例化对象设置为一个属性，并用static修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法返回该实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查instance是否被实例化出来，如果没有进入if块</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 某个线程取得了类锁，实例化对象前第二次检查instance是否已经被实例化出来，如果没有，才最终实例出对象</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DCL（双端检锁）机制就是在进来和出去的时候进行检测，这种方式也不一定是线程安全的，原因是有指令重排的存在，所以需要加入volatile禁止指令重排。</strong></p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p><strong>简单工厂模式</strong>是指一个工厂对象决定创建那种产品类的实例。</p>
<ul>
<li>只需传入一个正确的参数就能获取你需要的对象，无须知道具体的细节。</li>
<li>工厂类的职责相对过重，增加新的产品时需要修改工厂类的判断逻辑，违背开闭原则。<br>不易于扩展过于复杂的产品结构。</li>
</ul>
<p><strong>示例：Calendar.java</strong> 的 <strong><em>getInstance()</em></strong>方法的初始化用到的简单工厂模式。根据不同的<strong>Local</strong>时区，创建不同的<strong>Calendar</strong>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (aLocale.hasExtensions()) &#123;</span><br><span class="line">   String caltype = aLocale.getUnicodeLocaleType(<span class="string">"ca"</span>);</span><br><span class="line">   <span class="keyword">if</span> (caltype != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">switch</span> (caltype) &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">"buddhist"</span>:</span><br><span class="line">       cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">"japanese"</span>:</span><br><span class="line">           cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">"gregory"</span>:</span><br><span class="line">           cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="工厂方法模式（接口）"><a href="#工厂方法模式（接口）" class="headerlink" title="工厂方法模式（接口）"></a>工厂方法模式（接口）</h4><p><strong>工厂方法模式</strong>是指，定义一个创建对象的接口，但让<strong>实现这个接口的类</strong>来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。属于创建型设计模式。</p>
<ul>
<li>创建对象需要大量的重复代码。客户端(应用层)不依赖于产品类实例如何被创建、实现等细节。一个类通过其子类来指定创建哪个对象。</li>
<li>用户只需要关心所需产品对应的工厂，无需关键创建细节。</li>
<li>加入新产品符合开闭原则，提高系统的可扩展性。</li>
<li>类的个数容易过多，增加了代码结构的复杂度。也增加了系统的抽象性和理解难度。</li>
</ul>
<h4 id="抽象工厂模式（抽象类）"><a href="#抽象工厂模式（抽象类）" class="headerlink" title="抽象工厂模式（抽象类）"></a>抽象工厂模式（抽象类）</h4><p>抽象工厂模式是指提供一个创建一系列相关或相互依赖对象的接口，无需指定他们具体的类。属于创建型设计模式。</p>
<ul>
<li>客户端(应用层)不依赖于产品类实例如何被创建、实现等细节。</li>
<li>强调一系列相关的产品对象(属于同一产品族)一起使用创建对象需要大量复用的代码。</li>
<li>提供一个产品类库，所有的产品以同样的接口形式出现，从而使客户端不依赖于具体实现。</li>
<li>具体产品在应用层代码隔离，无须关心创建细节，将一个系列的产品族统一到一起创建。</li>
<li>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口<br>增加了抽象工厂的抽象性和理解难度。</li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>代理模式</strong>使得客户端在使用目标对象的时候间接通过操作代理对象进行，代理对象是对目标对象的增强。</p>
<p>代理模式包含如下几个角色：</p>
<ul>
<li><strong>客户端</strong>：客户端面向接口编程，使用代理角色完成某项功能。</li>
<li><strong>抽象主题</strong>：一般实现为接口，是对(被代理对象的)行为的抽象。</li>
<li><strong>被代理角色(目标类)</strong>：直接实现上述接口，是抽象主题的具体实现。</li>
<li><strong>代理角色(代理类)</strong>：实现上述接口，是对被代理角色的增强。</li>
</ul>
<p>代理模式又分为<strong>静态代理</strong>和<strong>动态代理</strong>俩种类型。</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理的实现模式一般是</p>
<ol>
<li>首先创建一个<strong>接口</strong>；</li>
<li>然后创建具体<strong>实现类</strong>来实现这个接口，实现类的方法中需要将接口中定义的方法的业务逻辑功能实现；</li>
<li>然后再创建一个<strong>代理类</strong>同样实现这个接口，不同之处在于，代理类中的方法只要调用具体实现类中的对应方法即可；</li>
<li>这样我们在需要使用接口中的某个方法的功能时直接调用代理类的方法即可，将具体的实现类隐藏在底层。</li>
</ol>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理可以在程序运行期间根据需要动态的创建代理类及其实例来完成具体的功能。</p>
<p>详见：<a href="http://blogsea.cn/2021/01/20/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84" target="_blank" rel="noopener">Java 语言特性之动态代理</a></p>
<h3 id="构造者模式"><a href="#构造者模式" class="headerlink" title="构造者模式"></a>构造者模式</h3><p>构造者模式,又称之为建造者模式,建造者模式。将一个复杂对象的<strong>构建</strong>与它的<strong>表示</strong>分离，使得同样的构建过程可以创建不同的表示。</p>
<p><strong>应用场景</strong>：当一个类有多个重载的构造器时，考虑使用构造者模式。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。</li>
<li>用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来）</li>
<li>代码复用性 &amp; 封装性（将对象构建过程和细节进行封装 &amp; 复用）</li>
<li>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序，一般用来创建更为复杂的对象</li>
</ul>
<p><strong>主要分为俩类</strong>：</p>
<ul>
<li>通过Client、Director、Builder和Product形成的建造者模式。例如 Mybatis 中的 SqlSessionFactoryBuilder。</li>
<li>通过静态内部类方式实现零件无序装配话构造。例如 SpringSecurity 中 Http 拦截设置。</li>
</ul>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p><strong>责任链模式</strong>指使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系， 将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。</p>
<p>举例：</p>
<ul>
<li>servlet 中的 filter。</li>
<li>dubbo 中的 filter。</li>
<li>mybatis 中的 plugin 。</li>
</ul>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式是一种<strong>结构型</strong>设计模式。适配器模式的思想是：<strong>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作</strong>。</p>
<p>适配器模式涉及3个角色：</p>
<ul>
<li><strong>源（Adaptee）</strong>：需要被适配的对象或类型，相当于插头。</li>
<li><strong>适配器（Adapter）</strong>：连接目标和源的中间对象，相当于插头转换器。</li>
<li><strong>目标（Target）</strong>：期待得到的目标，相当于插座。</li>
</ul>
<p>适配器模式可以分为三种类型：</p>
<ul>
<li>类适配器模式</li>
<li>对象适配器模式</li>
<li>接口适配器模式</li>
</ul>
<h4 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><strong>源（Adaptee）</strong> 实现 <code>methodA()</code> , 但是目标接口 需要实现 <code>methodA()</code> 和 <code>methodB()</code> ，</p>
<p>则实现方式为 <strong>适配器（Adapter）</strong> 继承 <strong>源（Adaptee）</strong>并实现 <strong>目标（Target）</strong>接口，内部补充实现 <code>methodB()</code>方法。</p>
<p><strong>Adapter 与 Adaptee 是继承关系</strong>，这决定了这是一个<strong>类适配器模式</strong>。</p>
<p><img src="/2021/01/26/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/design_patterns_02.png" alt="类适配器模式"></p>
<h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p><strong>适配器（Adapter）</strong>实现<strong>目标（Target）</strong>接口， 构造器中传入 <strong>源（Adaptee）</strong> 对象作为属性变量，内部提供的方法实现为 调用 <strong>源（Adaptee）</strong> 对象方法增强。</p>
<p><img src="/2021/01/26/Java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/design_patterns_03.png" alt="对象适配器模式"></p>
<h4 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p><strong>接口适配器模式（缺省适配模式</strong>）的思想是，为一个接口提供缺省实现，这样子类可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。</p>
<p>即为<strong>目标（Target）</strong>接口提供一个实现类，实现其全部方法， <strong>适配器（Adapter）</strong>继承其实现类，实现部分方法（这里是只需要使用的方法）。这样不必再把每个方法都实现一遍，代码看起来简洁多了。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>在对象之间定义了一对多的依赖，这样一来，<strong>当一个对象改变状态，依赖它的对象会收到通知并自动更新。</strong></p>
<p>观察者模式所涉及的角色有：</p>
<ul>
<li><p><strong>抽象主题(Subject)角色：</strong>抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</p>
</li>
<li><p><strong>具体主题(ConcreteSubject)角色：</strong>将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p>
</li>
<li><p><strong>抽象观察者(Observer)角色：</strong>为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p>
</li>
<li><p><strong>具体观察者(ConcreteObserver)角色：</strong>存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p>
</li>
</ul>
<blockquote>
<p>笔记来源：</p>
<p><a href="https://www.cnblogs.com/binaway/p/8889184.html" target="_blank" rel="noopener">https://www.cnblogs.com/binaway/p/8889184.html</a></p>
<p><a href="https://blog.csdn.net/qq_36629833/article/details/90764881" target="_blank" rel="noopener">https://blog.csdn.net/qq_36629833/article/details/90764881</a></p>
<p><a href="https://blog.csdn.net/justloveyou_/article/details/74203025" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/74203025</a></p>
<p><a href="https://www.jianshu.com/p/47329a94f5dc" target="_blank" rel="noopener">https://www.jianshu.com/p/47329a94f5dc</a></p>
<p><a href="https://blog.csdn.net/mrkohaku/article/details/79087688" target="_blank" rel="noopener">https://blog.csdn.net/mrkohaku/article/details/79087688</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出JVM</title>
    <url>/2021/02/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJVM/</url>
    <content><![CDATA[<h1 id="深入浅出JVM"><a href="#深入浅出JVM" class="headerlink" title="深入浅出JVM"></a>深入浅出JVM</h1><ul>
<li><p>内存模型：程序计数器、方法区、堆、栈、本地方法栈</p>
</li>
<li><p>类加载：类加载过程、Bootstrap类加载器、Extension类加载器、System类加载器、自定义类加载器、双亲委派机制；</p>
</li>
<li><p>GC：分代回收、回收器</p>
</li>
<li><p>编译器优化：指令重排</p>
</li>
<li><p>性能调优：JVM参数、性能分析工具：jstat、jstack、JMC、MAT</p>
</li>
<li><p>其他</p>
</li>
</ul>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>相比于 C++的手动内存管理、复杂难以理解的指针等，Java 引以为豪的就是它的<strong>自动内存管理机制</strong>。</p>
<blockquote>
<p>“Java 虚拟机具有一个<strong>堆</strong>，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”在JVM中堆之外的内存称为<strong>非堆内存</strong>(Non-heap memory)”。可以看出<strong>JVM主要管理两种类型的内存：堆和非堆</strong>。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中。 </p>
</blockquote>
<p><img src="/2021/02/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJVM/memory_model_01.png" alt="内存模型"></p>
<h4 id="JVM虚拟机栈"><a href="#JVM虚拟机栈" class="headerlink" title="JVM虚拟机栈"></a>JVM虚拟机栈</h4><p>JVM虚拟机描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“<strong>栈帧</strong>”。每个方法被调用到执行完的过程，就<strong>对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</strong>。声明周期与线程相同，是线程私有的。</p>
<p>每个栈帧，都包含四个区域：</p>
<ul>
<li><strong>局部变量表</strong>：局部标量表 是一组变量值的存储空间，用于存放 方法参数 和 局部变量。局部变量表存放了编译器可知的各种基本数据类型(<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)、对象引用(引用指针，并非对象本身)，局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。局部变量表最基本的存储单位是 <strong>变量槽</strong>（slot），<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</strong>如果当前帧是由构造方法或者实例方法创建的（意思是当前帧所对应的方法是构造器方法或者是普通的实例方法），那么<strong>该对象引用this将会存放在index为0的slot处</strong>,其余的参数按照参数表顺序排列。</li>
<li><strong>操作数栈</strong>：又称为 表达式栈。<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></li>
<li><strong>动态链接</strong>：在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Refenrence）保存在class字节码文件（javap反编译查看）的常量池里。那么<strong>动态链接的作用就是为了将这些符号引用（#）最终转换为调用方法的直接引用。</strong></li>
<li><strong>返回地址</strong>：方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者（方法的调用者可能也是一个方法）的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</strong></li>
</ul>
<p><img src="/2021/02/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJVM/memory_model_02.png" alt="栈帧模型"></p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。这里面存的，就是当前线程执行的进度。</p>
<p>多线程环境下，线程在CPU上的运行是交替获取时间片的方式工作的，线程获取时间片上是不可预知的，那么 <strong>程序计数器就是对线程正在运行的点位进行缓冲记录，以便在获取CPU时间片时能够快速恢复。</strong></p>
<p>程序计数器是因为线程而产生的，与虚拟机栈配合完成计算操作。程序计数器还存储了当前正在运行的流程，包括正在执行的指令、跳转、分支、循环、异常处理等。</p>
<h4 id="方法区（永久代到元空间）"><a href="#方法区（永久代到元空间）" class="headerlink" title="方法区（永久代到元空间）"></a>方法区（永久代到元空间）</h4><p>方法区是JVM规范的抽象定义；而非具体实现技术。这个区域存储的内容，包括：类的信息、常量池、方法数据、方法代码。</p>
<p>Java8 以前 方法区 是 <strong>堆（Heap）内存</strong>，这些类信息是放在一个叫做 永久代 (Perm区) 的内存里面，这个区里面有大小限制 容易造成堆内存 溢出。</p>
<p>Java8 以后，JVM使用 <strong>元空间</strong> 替代永久代。元空间使用 本地内存实现，即非堆内存。所以可以理论上物理机器还有多内存就可以分配，而不用再受限于JVM本身分配的内存了，也不用修改堆内存。</p>
<p><img src="/2021/02/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJVM/memory_model_03.png" alt="方法区"></p>
<h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><p>堆是 JVM 上最大的内存区域，我们申请的几乎所有的对象，都是在这里存储的。我们常说的垃圾回收，操作的对象就是堆。 堆空间一般是程序启动时，就申请了，但是并不一定会全部使用。</p>
<p>随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的<strong>对象进行回收</strong>。这个在 Java 中，就叫作 <strong>GC</strong>（Garbage Collection）。 </p>
<p>由于对象的大小不一，在长时间运行后，堆空间会被许多细小的碎片占满，造成空间浪费。所以，仅仅销毁对象是不够的，还需要<strong>堆空间整理</strong>。</p>
<p>Java 的对象可以分为<strong>基本数据类型</strong>和<strong>普通对象</strong>。</p>
<ul>
<li>对于普通对象来说，JVM 会首先在堆上创建对象，然后在其他地方使用的其实是它的<strong>引用</strong>。</li>
<li>对于基本数据类型来说，当你在方法体内声明了基本数据类型的对象，它就会在栈上直接分配。其他情况，都是在堆上分配。</li>
</ul>
<p>而堆是所有线程共享的，如果是多个线程访问，会涉及数据<strong>同步问题</strong>。</p>
<h3 id="JMM内存可见性"><a href="#JMM内存可见性" class="headerlink" title="JMM内存可见性"></a>JMM内存可见性</h3><p><strong>JMM 是 Java 内存模型</strong>，与 JVM 内存模型是两回事，JMM 的主要目标是定义程序中变量的访问规则，如图所示，<strong>所有的共享变量都存储在主内存中共享。每个线程有自己的工作内存，工作内存中保存的是主内存中变量的副本，线程对变量的读写等操作必须在自己的工作内存中进行，而不能直接读写主内存中的变量</strong>。</p>
<img src="/2021/02/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJVM/jvm_01.png" alt="JMM内存模型" style="zoom:40%;">

<p>在多线程进行数据交互时，例如线程 A 给一个共享变量赋值后，由线程 B 来读取这个值，A 修改完变量是修改在自己的工作区内存中，B 是不可见的，只有从 A 的工作区写回主内存，B 再从主内存读取自己的工作区才能进行进一步的操作。</p>
<p>由于<strong>指令重排序</strong>的存在，这个写—读的顺序有可能被打乱。因此 JMM 需要提供原子性、可见性、有序性的保证。</p>
<img src="/2021/02/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJVM/jvm_02.png" alt="保证可见性" style="zoom:40%;">

<p><strong>原子性</strong></p>
<p>JMM 保证对除 long 和 double 外的基础数据类型的读写操作是原子性的。另外关键字 synchronized 也可以提供原子性保证。synchronized 的原子性是通过 Java 的两个高级的字节码指令 monitorenter 和 monitorexit 来保证的。</p>
<p><strong>可见性</strong></p>
<p>JMM 可见性的保证，一个是通过 synchronized，另外一个就是 volatile。volatile 强制变量的赋值会同步刷新回主内存，强制变量的读取会从主内存重新加载，保证不同的线程总是能够看到该变量的最新值。</p>
<p><strong>有序性</strong></p>
<p>对有序性的保证，主要通过 volatile 和一系列 happens-before 原则。volatile 的另一个作用就是阻止指令重排序，这样就可以保证变量读写的有序性。</p>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>JVM类的加载主要有这几个过程：<strong>加载、验证、准备、解析、初始化、使用 和 卸载。</strong></p>
<img src="/2021/02/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJVM/memory_model_04.png" alt="类加载过程" style="zoom:67%;">

<ul>
<li><p><strong>加载 Loading</strong></p>
<p>加载的主要作用是将外部的 .class 文件，加载到 Java 的方法区。加载阶段主要是找到并加载类的二进制数据，将class字节码文件加载到内存中，并将这些数据转换成方法区中的运行时数据（静态变量、静态代码块、常量池等），在堆中生成一个Class类对象代表这个类（反射原理），作为方法区类数据的访问入口。</p>
</li>
<li><p><strong>验证 Verifying</strong></p>
<p>确保加载的类信息符合JVM规范，没有安全方面的问题。不符合规范的将抛出 java.lang.VerifyError 错误。像一些低版本的 JVM，是无法加载一些高版本的类库的，就是在这个阶段完成的。</p>
</li>
<li><p><strong>准备 Preparing</strong></p>
<p>从这部分开始，将为一些 <strong>类变量</strong> 分配内存，并将其初始化为默认值。此时，实例对象还没有分配内存，所以这些动作是在<strong>方法区</strong>上进行的。注意此时的设置初始值为默认值，具体赋值在初始化阶段完成。（即 <strong>static</strong> 变量有俩次赋值，这里赋默认值，初始化阶段赋予程序定义的值，因此，即使程序员没有为类变量赋值也没有关系，它仍然有一个默认的初始值。但局部变量就不一样了，如果没有给它赋初始值，是不能使用的。）</p>
</li>
<li><p><strong>解析 Resolving</strong></p>
<p>虚拟机常量池内的 <strong>符号引用替换为直接引用</strong>（地址引用）的过程。</p>
</li>
<li><p><strong>初始化 Initiallsing</strong></p>
<p>初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的<strong>赋值</strong>动作和<strong>静态语句块(static块)</strong>中的语句合并产生的。</clinit></clinit></p>
<ul>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类。</li>
<li>类构造器<clinit>()方法：静态类变量赋值代码和静态代码块<strong>从上到下顺序执行</strong>。</clinit></li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</clinit></li>
</ul>
<p>与 <strong>类构造器<clinit>()方法</clinit></strong> 相对立的则是<strong>实例初始化 <init>()方法，</init></strong>其中的区别是 类初始化只有一次，而实例初始化 将在每次创建对象时调用。</p>
</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>如果你在项目代码里，写一个 java.lang 的包，然后改写 String 类的一些行为，编译后，发现并不能生效。JRE 的类当然不能轻易被覆盖，否则就太危险了。</p>
<p>那类加载器是如何保证这个过程的安全性呢？其实，它是有着严格的等级制度的。</p>
<p>首先，我们了解下几个不同等级的类加载器。</p>
<ul>
<li><h5 id="根类加载器（Bootstrap-ClassLoader）"><a href="#根类加载器（Bootstrap-ClassLoader）" class="headerlink" title="根类加载器（Bootstrap ClassLoader）"></a>根类加载器（Bootstrap ClassLoader）</h5><p><strong>根类加载器</strong>（或者叫引导类加载器） 是加载器中等级最大的，任何类的加载行为都要经它过问。它的作用是 <strong>加载 核心类库</strong>，例如 <strong>rt.jar  \ resources.jar \ charsets.jar</strong> 等。</p>
<p>这个加载器 是 <strong>C++</strong> 编写的，随着JVM 启动。</p>
<p>下面这段代码可以获取 根类加载器加载的核心类库：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL urL : urLs) &#123;</span><br><span class="line">            System.out.println(urL.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// file:/D:/Java/jdk1.8.0_65/jre/lib/resources.jar</span></span><br><span class="line"><span class="comment">// file:/D:/Java/jdk1.8.0_65/jre/lib/rt.jar</span></span><br><span class="line"><span class="comment">// file:/D:/Java/jdk1.8.0_65/jre/lib/sunrsasign.jar</span></span><br><span class="line"><span class="comment">// file:/D:/Java/jdk1.8.0_65/jre/lib/jsse.jar</span></span><br><span class="line"><span class="comment">// file:/D:/Java/jdk1.8.0_65/jre/lib/jce.jar</span></span><br><span class="line"><span class="comment">// file:/D:/Java/jdk1.8.0_65/jre/lib/charsets.jar</span></span><br><span class="line"><span class="comment">// file:/D:/Java/jdk1.8.0_65/jre/lib/jfr.jar</span></span><br><span class="line"><span class="comment">// file:/D:/Java/jdk1.8.0_65/jre/classes</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="扩展类加载器（Extensions-ClassLoader）"><a href="#扩展类加载器（Extensions-ClassLoader）" class="headerlink" title="扩展类加载器（Extensions ClassLoader）"></a>扩展类加载器（Extensions ClassLoader）</h5><p>它用来加载 <strong>Java</strong> 的扩展库 <strong>(jre/ext/*.jar)</strong>。<strong>Java</strong> 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 <strong>Java</strong> 类。 </p>
<p>这个加载器是个 <strong>Java</strong> 类，继承自 <strong>URLClassLoader</strong>。</p>
</li>
<li><h5 id="系统类加载器（System-ClassLoader）"><a href="#系统类加载器（System-ClassLoader）" class="headerlink" title="系统类加载器（System ClassLoader）"></a>系统类加载器（System ClassLoader）</h5><p>它根据 <strong>Java</strong> 应用的类路径（<strong>CLASSPATH</strong>）来加载 <strong>Java</strong> 类。一般用来加载 <strong>classpath</strong> 下的其他所有 <strong>jar 包</strong>和 <strong>.class</strong> 文件，我们写的代码，会首先尝试使用这个类加载器进行加载。可以通过 <strong>ClassLoader.getSystemClassLoader()</strong>来获取它。</p>
</li>
<li><h5 id="自定义加载器（Custom-ClassLoader）"><a href="#自定义加载器（Custom-ClassLoader）" class="headerlink" title="自定义加载器（Custom ClassLoader）"></a>自定义加载器（Custom ClassLoader）</h5><p>自定义加载器，支持一些个性化的扩展功能。</p>
</li>
</ul>
<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>某个特定的类加载器在接到加载类的请求时，<strong>首先将加载任务委托交给父类加载器，父类加载器又将加载任务向上委托，直到最父类加载器，如果最父类加载器可以完成类加载任务，就成功返回，如果不行就向下传递委托任务，由其子类加载器进行加载。</strong></p>
<img src="/2021/02/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJVM/memory_model_05.png" alt="双亲委派机制" style="zoom:80%;">

<p><strong>双亲委派机制的好处：</strong></p>
<p>保证<strong>java</strong>核心库的安全性（例如：如果用户自己写了一个java.lang.String类就会因为双亲委派机制不能被加载，不会破坏原生的String类的加载）</p>
<h4 id="打破双亲委派机制的案例"><a href="#打破双亲委派机制的案例" class="headerlink" title="打破双亲委派机制的案例"></a>打破双亲委派机制的案例</h4><h5 id="Tomcat类加载机制"><a href="#Tomcat类加载机制" class="headerlink" title="Tomcat类加载机制"></a>Tomcat类加载机制</h5><p><strong>思考：</strong>Tomcat 作为 web 容器，需要解决什么问题？</p>
<ul>
<li>一个容器可能需要部署多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。 </li>
<li>部署在同一个web容器中相同的类库相同的版本可以共享。</li>
<li>web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。</li>
<li>web容器要支持jsp的修改而不重启。我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但是程序对于Jsp 的修改较为频繁，我们要求web容器需要 jsp 修改后不用重启。</li>
</ul>
<p><strong>那么Tomcat 是如何解决这些问题的呢？</strong></p>
<img src="/2021/02/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJVM/memory_model_06.png" alt="Tomcat类加载机制" style="zoom:80%;">

<p>如图：<strong>CommonClassLoader</strong>、<strong>CatalinaClassLoader</strong>、<strong>SharedClassLoader</strong> 和 <strong>WebappClassLoader</strong>则是Tomcat自己定义的类加载器，它们分别加载<code>/common/*</code>、<code>/server/*</code>、<code>/shared/*</code>（在tomcat 6之后已经合并到根目录下的lib目录下）和<code>/WebApp/WEB-INF/*</code>中的Java类库。</p>
<p>其中WebApp类加载器和Jsp类加载器通常会存在<strong>多个实例</strong>，每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应一个Jsp类加载器（修改Jsp则卸载该类加载器，重新创建类加载器，由此支持热部署）。</p>
<ul>
<li><strong>CommonClassLoader</strong>：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li>
<li><strong>CatalinaClassLoader</strong>：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</li>
<li><strong>SharedClassLoader</strong>：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li>
<li><strong>WebappClassLoader</strong>：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；</li>
<li><strong>JaserperLoader</strong>：每一个JSP文件对应一个Jsp类加载器。</li>
</ul>
<p><strong>Common ClassLoader</strong>能加载的类都可以被<strong>Catalina ClassLoader</strong>和<strong>Shared ClassLoader</strong>使用，从而实现了公有类库的共用，而<strong>CatalinaClassLoader</strong>和<strong>Shared ClassLoader</strong>自己能加载的类则与对方相互隔离。</p>
<p><strong>WebAppClassLoader</strong>可以使用<strong>SharedClassLoader</strong>加载到的类，但各个<strong>WebAppClassLoader</strong>实例之间相互隔离。</p>
<p>而<strong>JasperLoader</strong>的加载范围仅仅是这个JSP文件所编译出来的那一个<strong>.Class</strong>文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的<strong>JasperLoader</strong>的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能。</p>
<p><strong>问题1：tomcat是否违反了双亲委派原则？</strong></p>
<p>答：显然是的，双亲委派模型要求除了顶层的根类加载器以外，其余的类加载器都应当由自己的父类加载器加载。</p>
<p><strong>问题2：那么如果我自己定义一个恶意的核心API类（例如HashMap），会不会有风险呢？</strong></p>
<p>答：不会，tomcat不遵循双亲委派机制，只是自定义的classLoader顺序不同，但顶层还是相同的。</p>
<h5 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h5><p>这个类加载器可以通过 <strong>java.lang.Thread</strong> 类的 <strong>setContextClassLoader</strong> 方法进行设置。如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过多的话，那这个类加载器默认即使应用程序类加载器（系统类加载器）。</p>
<p><strong>该设计意在解决这样的问题：</strong>基础类总是由最顶层的类加载器加载，它们总是作为被用户代码调用的API，但没有绝对，如果<strong>基础类需要调用用户的代码</strong>呢？</p>
<p>一个典型的例子就是 JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时就放进去的rt.jar）,但<strong>它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI， Service Provider Interface）的代码</strong>，这些类不在rt.jar中，但是启动类加载器又需要加载。</p>
<p>有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的<strong>SPI</strong>代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。但这无可奈何，Java中所有涉及SPI的加载动作基本胜都采用这种方式。例如JNDI，JDBC，JCE，JAXB，JBI等。</p>
<h5 id="知识拓展：SPI"><a href="#知识拓展：SPI" class="headerlink" title="知识拓展：SPI"></a>知识拓展：SPI</h5><p><strong>SPI</strong>的英文名称是<strong>Service Provider Interface</strong>，是Java 内置的<strong>服务发现机制</strong>。</p>
<p><strong>Java SPI</strong> 实际上是 <strong>“ 基于接口的编程＋策略模式＋配置文件 ”</strong> 组合实现的<strong>动态加载机制</strong>。</p>
<p>系统设计的各个抽象，往往有很多不同的实现方案，在面向的对象的设计里，一般推荐模块之间<strong>基于接口编程</strong>，模块之间不对<strong>实现类</strong>进行硬编码。一旦代码里涉及具体的实现类，就违反了<strong>可拔插</strong>的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。</p>
<p>要使用Java SPI，需要遵循如下约定：</p>
<ol>
<li><p>当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以 “<strong>接口全限定名</strong>” 为命名的文件，内容为<strong>实现类的全限定名</strong>；例如：文件名为：<code>com.example.service.TestService</code>,内容则为 <code>com.example.service.TestServiceImpl</code></p>
</li>
<li><p>接口实现类所在的jar包放在主程序的classpath中；</p>
</li>
<li><p>主程序通过<strong>java.util.ServiceLoder</strong>动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceLoader&lt;TestService&gt; services = ServiceLoader.load(TestService<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SPI的实现类必须携带一个不带参数的构造方法；</p>
</li>
</ol>
<p><strong>常见案例：</strong></p>
<p>JDBC加载不同类型数据库的驱动</p>
<p>SLF4J加载不同提供商的日志实现类</p>
<p>Dubbo中也大量使用SPI的方式实现框架的扩展</p>
<p>此外，spring-boot 自动配置原理似乎也是借鉴SPI机制，详见 <a href="http://blogsea.cn/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">SpringBoot学习之自动配置原理</a></p>
<h3 id="GC垃圾回收器"><a href="#GC垃圾回收器" class="headerlink" title="GC垃圾回收器"></a>GC垃圾回收器</h3><p>JVM中堆是一个巨大的对象池。在这个对象池中管理着数量巨大的对象实例。而池中对象的引用层次，有的是很深的。一个被频繁调用的接口，每秒生成对象的速度，也是非常可观的。对象之间的关系，形成了一张巨大的网。虽然 Java 一直在营造一种无限内存的氛围，但对象不能只增不减，所以需要<strong>垃圾回收</strong>（GC）。</p>
<p>当我们的内存空间达到一定条件时，会自动触发。这个过程就叫作 <strong>GC</strong>，负责 GC 的组件，就叫作<strong>垃圾回收器</strong>。</p>
<h4 id="判断哪些对象被回收"><a href="#判断哪些对象被回收" class="headerlink" title="判断哪些对象被回收"></a><strong>判断哪些对象被回收</strong></h4><p>由 GC Roots 向下追溯、搜索，会产生一个叫作 <strong>Reference Chain</strong> 的链条。<strong>当一个对象不能和任何一个 GC Root 产生关系时，就会垃圾回收。</strong></p>
<ul>
<li>GC Roots 是一组<strong>必须活跃的引用</strong>。大体分为：<ul>
<li>活动线程相关的各种引用。</li>
<li>类的静态变量的引用。</li>
<li>JNI 引用。</li>
</ul>
</li>
<li><strong>活跃的引用，而不是对象</strong>，对象是不能作为 GC Roots 的。</li>
<li><strong>GC 过程是找出所有活对象，并把其余空间认定为“无用”；而不是找出所有死掉的对象，并回收它们占用的空间。</strong>所以，哪怕 JVM 的堆非常的大，基于 tracing 的 GC 方式，回收速度也会非常快。</li>
</ul>
<h4 id="引用级别"><a href="#引用级别" class="headerlink" title="引用级别"></a>引用级别</h4><p>能够找到 Reference Chain 的对象，就一定会存活么？不一定</p>
<p>对象的引用级别分为：<strong>强引用、软引用、弱引用、虚引用</strong>等。不同的引用级别，回收条件也不一样。</p>
<ul>
<li><p><strong>强引用 Strong references</strong>：当内存空间不足，系统撑不住了，JVM 就会抛出 OutOfMemoryError 错误。<strong>即使程序会异常终止，这种对象也不会被回收。</strong></p>
<p>这种引用属于最普通最强硬的一种存在，只有在和 GC Roots 断绝关系时，才会被消灭掉。</p>
</li>
<li><p><strong>软引用 Soft references</strong>：软引用用于维护一些可有可无的对象。在内存足够的时候，软引用对象不会被回收，<strong>只有在内存不足时，系统则会回收软引用对象</strong>，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。可以看到，这种特性非常适合用在缓存技术上。比如网页缓存、图片缓存等。Guava 的 CacheBuilder，就提供了软引用和弱引用的设置方式。</p>
<p>软引用需要显式的声明，使用泛型来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> SoftReference(object);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>弱引用 Weak references</strong>：弱引用对象相比较软引用，要更加无用一些，它拥有更短的生命周期。当 JVM 进行垃圾回收时，<strong>无论内存是否充足，都会回收被弱引用关联的对象</strong>。它的应用场景和软引用类似，可以在一些对内存更加敏感的系统里采用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; softRef = <span class="keyword">new</span> WeakReference(object);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>虚引用 Phantom References</strong>：这是一种<strong>形同虚设的引用，</strong>在现实场景中用的不是很多。虚引用主要用来跟踪对象被垃圾回收的活动。</p>
<p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象之前，把这个虚引用加入到与之关联的引用队列中。反之，程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
</li>
</ul>
<h4 id="典型OOM场景"><a href="#典型OOM场景" class="headerlink" title="典型OOM场景"></a>典型OOM场景</h4><p>JVM 中，除了程序计数器，其他区域都有OOM溢出的可能。但是<strong>最常见的还是发生在堆上</strong>。</p>
<p>常见OOM场景：</p>
<ul>
<li>内存的容量太小了，需要扩容，或者需要调整堆的空间。</li>
<li>错误的引用方式，发生了内存泄漏。</li>
<li>没有及时的切断与 GC Roots 的关系。比如线程池里的线程，在复用的情况下忘记清理 ThreadLocal 的内容。接口没有进行范围校验，外部传参超出范围。比如数据库查询时的每页条数等。</li>
<li>对堆外内存无限制的使用。这种情况一旦发生更加严重，会造成操作系统内存耗尽。</li>
</ul>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p><strong>GC 的过程</strong>是先找到活跃的对象，然后把其他不活跃的对象判定为垃圾，然后删除。所以垃圾回收只与活跃的对象有关，和堆的大小无关。</p>
<p>垃圾回收几个概念：</p>
<ul>
<li><strong>标记</strong>：垃圾回收的第一步，就是找出活跃的对象。根据 GC Roots 遍历所有的可达对象，这个过程，就叫作<strong>标记</strong>。</li>
<li><strong>清除</strong>：清除阶段就是把未被标记的对象回收掉。</li>
<li><strong>复制</strong>：经过清除后，剩下活跃对象分散分布，造成内存碎片。我们可以通过复制方式解决内存碎片：提供一个对等的内存空间，将存活的对象复制过去，然后清除原内存空间。</li>
<li><strong>整理</strong>：其实不用分配一个对等的额外空间，也是可以完成内存的整理工作，就是移动所有存活的对象，且按照内存地址顺序依次排列，然后将末端内存地址以后的内存全部回收。</li>
</ul>
<p>回收算法：</p>
<ul>
<li><strong>复制算法（Copy）</strong>复制算法是所有算法里面效率最高的，缺点是会造成一定的空间浪费。</li>
<li><strong>标记-清除（Mark-Sweep）</strong>效率一般，缺点是会造成内存碎片问题。</li>
<li><strong>标记-整理（Mark-Compact）</strong>效率比前两者要差，但没有空间浪费，也消除了内存碎片问题。</li>
</ul>
<h4 id="分代"><a href="#分代" class="headerlink" title="分代"></a>分代</h4><p>JVM 是计算节点，而不是存储节点。最理想的情况，就是对象在用完之后，它的生命周期立马就结束了。而那些被频繁访问的资源，我们希望它能够常驻在内存里。<br>研究表明，大部分对象，可以分为两类：<strong>大部分对象的生命周期都很短；其他对象则很可能会存活很长时间。</strong></p>
<p><strong>大部分死的快，其他的活的长。</strong>这个假设我们称之为<strong>弱代假设</strong>（weak generational hypothesis）。</p>
<p>现在的垃圾回收器，都会<strong>在物理上或者逻辑上</strong>，把这两类对象进行区分。我们把死的快的对象所占的区域，叫作<strong>年轻代（Young generation）</strong>。把其他活的长的对象所占的区域，叫作<strong>老年代（Old generation）</strong>（老年代在有些地方也会叫作 Tenured Generation）。</p>
<h5 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h5><p><strong>年轻代使用的垃圾回收算法是复制算法。</strong>因为年轻代发生 GC 后，只会有非常少的对象存活，复制这部分对象是非常高效的。</p>
<p>年轻代分为：<strong>一个伊甸园空间（Eden ），两个幸存者空间（Survivor ）</strong>。内存<strong>比例为 8:1:1</strong>。（这个比例，是由参数 <strong>-XX:SurvivorRatio</strong> 进行配置的（默认为 8））</p>
<ul>
<li><p>在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区（以下简称from）；</p>
</li>
<li><p>Eden 区再次 GC，这时会采用复制算法，将 Eden 和 from 区一起清理。存活的对象会被复制到 to 区（另一个Survivor 分区）；</p>
</li>
<li><p>接下来，只需要清空 from 区就可以了。</p>
</li>
</ul>
<p>所以在这个过程中，<strong>总会有一个 Survivor 分区是空置的，所以只会造成 10% 的空间浪费。</strong></p>
<h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><p><strong>老年代一般使用“标记-清除”、“标记-整理”算法</strong>，因为老年代的对象存活率一般是比较高的，空间又比较大，拷贝起来并不划算，还不如采取就地收集的方式。</p>
<p>对象进入老年代的方式：</p>
<ul>
<li><strong>提升（Promotion）</strong>：每当发生一次 Minor GC（年轻代 GC），存活下来的对象年龄都会加 1。直到达到一定的阈值，就会把这些“老顽固”给提升到老年代。（阈值可以通过参数 <strong>‐XX:+MaxTenuringThreshold</strong> 进行配置，最大值是 15，因为它是用 4bit 存储的）</li>
<li><strong>分配担保</strong>：Minor GC后，每次存活的对象，都会放入其中一个幸存区，这个区域默认的比例是 10%。但是我们无法保证每次存活的对象都小于 10%，当 Survivor 空间不够，就需要依赖其他内存（指老年代）进行分配担保。这个时候，对象也会直接在老年代上分配。</li>
<li><strong>大对象直接在老年代分配</strong>：超出某个大小的对象将直接在老年代分配。</li>
<li><strong>动态对象年龄判定</strong>：对于提升中，阈值不是一个固定值，而是有某个算法动态获得的age，大于或等于 age 的对象将会直接进入老年代。</li>
</ul>
<h5 id="卡片标记"><a href="#卡片标记" class="headerlink" title="卡片标记"></a>卡片标记</h5><p>对象的引用关系是一个巨大的网状。有的对象可能在 Eden 区，有的可能在老年代，那么这种<strong>跨代的引用</strong>是如何处理？由于 Minor GC 是单独发生的，如果一个老年代的对象引用了它，如何确保能够让年轻代的对象存活呢？</p>
<p>对于是、否的判断，我们通常都会用 Bitmap（位图）和布隆过滤器来加快搜索的速度。</p>
<p>JVM 也是用了类似的方法。老年代是被分成众多的卡页（card page）的（一般数量是 2 的次幂）。<br><strong>卡表（Card Table）</strong>就是用于标记卡页状态的一个集合，每个卡表项对应一个卡页。<br>如果年轻代有对象分配，而且老年代有对象指向这个新对象， 那么这个老年代对象所对应内存的卡页，就会标识为 dirty，卡表只需要非常小的存储空间就可以保留这些状态。垃圾回收时，就可以先读这个卡表，进行快速判断。</p>
<h4 id="HotSpot-垃圾回收器"><a href="#HotSpot-垃圾回收器" class="headerlink" title="HotSpot 垃圾回收器"></a><strong>HotSpot 垃圾回收器</strong></h4><ul>
<li><strong>年轻代垃圾回收器</strong><ul>
<li><strong>Serial 垃圾收集器</strong>：处理 GC 的只有一条线程，并且在垃圾回收的过程中暂停一切用户线程。</li>
<li><strong>ParNew 垃圾收集器</strong>：ParNew 是 Serial 的多线程版本。由多条 GC 线程并行地进行垃圾清理。清理过程依然要停止用户线程。</li>
<li><strong>Parallel Scavenge 垃圾收集器</strong>：另一个多线程版本的垃圾回收器。它与 ParNew 的主要区别是：Parallel Scavenge：追求 CPU 吞吐量，能够在较短时间内完成指定任务，适合没有交互的后台计算。<strong>弱交互强计算</strong>。ParNew：追求降低用户停顿时间，适合交互式应用。强交互弱计算。</li>
</ul>
</li>
<li><strong>老年代垃圾回收器</strong><ul>
<li><strong>Serial Old 垃圾收集器</strong>：与年轻代的 Serial 垃圾收集器对应，都是单线程版本。年轻代的 Serial，使用复制算法。老年代的 Old Serial，使用标记-整理算法。</li>
<li><strong>Parallel Old</strong>：Parallel Old 收集器是 Parallel Scavenge 的老年代版本，追求 CPU 吞吐量。</li>
<li><strong>CMS 垃圾收集器</strong>：CMS（Concurrent Mark Sweep）收集器是以获取最短 GC 停顿时间为目标的收集器，它在垃圾收集时使得<strong>用户线程和 GC 线程能够并发执行</strong>，因此在垃圾收集过程中用户也不会感到明显的卡顿。</li>
</ul>
</li>
</ul>
<p>除了上面几个垃圾回收器，我们还有 G1、ZGC 等更加高级的垃圾回收器，它们都有专门的配置参数来使其生效。</p>
<p>配置参数：</p>
<ul>
<li><strong>-XX:+UseSerialGC</strong> 年轻代和老年代都用串行收集器</li>
<li><strong>-XX:+UseParNewGC</strong> 年轻代使用 ParNew，老年代使用 Serial Old</li>
<li><strong>-XX:+UseParallelGC</strong> 年轻代使用 ParallerGC，老年代使用 Serial Old</li>
<li><strong>-XX:+UseParallelOldGC</strong> 新生代和老年代都使用并行收集器</li>
<li><strong>-XX:+UseConcMarkSweepGC</strong>，表示年轻代使用 ParNew，老年代的用 CMS</li>
<li><strong>-XX:+UseG1GC</strong> 使用 G1垃圾回收器</li>
<li><strong>-XX:+UseZGC</strong> 使用 ZGC 垃圾回收器</li>
</ul>
<p>Java7、8 的默认参数：-XX:+UseParallelGC。Java13 的默认参数：-XX:+UseG1GC。</p>
<ul>
<li><p><strong>java -XX:+PrintCommandLineFlags -version</strong>  ：查看详细参数</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\Users\charleyZZZZ&gt;java <span class="literal">-XX</span>:+PrintCommandLineFlags <span class="literal">-version</span></span><br><span class="line"><span class="literal">-XX</span>:InitialHeapSize=<span class="number">131691328</span> <span class="literal">-XX</span>:MaxHeapSize=<span class="number">2107061248</span> <span class="literal">-XX</span>:+PrintCommandLineFlags <span class="literal">-XX</span>:+UseCompressedClassPointers <span class="literal">-XX</span>:+UseCompressedOops <span class="literal">-XX</span>:<span class="literal">-UseLargePagesIndividualAllocation</span> <span class="literal">-XX</span>:+UseParallelGC</span><br><span class="line">java version <span class="string">"1.8.0_65"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build <span class="number">1.8</span>.<span class="number">0</span>_65<span class="literal">-b17</span>)</span><br><span class="line">Java HotSpot(TM) <span class="number">64</span><span class="literal">-Bit</span> Server VM (build <span class="number">25.65</span><span class="literal">-b01</span>, mixed mode)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>java -XX:+PrintGCDetails -version</strong> ：查看GC详情</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\Users\charleyZZZZ&gt;java <span class="literal">-XX</span>:+PrintGCDetails <span class="literal">-version</span></span><br><span class="line">java version <span class="string">"1.8.0_65"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build <span class="number">1.8</span>.<span class="number">0</span>_65<span class="literal">-b17</span>)</span><br><span class="line">Java HotSpot(TM) <span class="number">64</span><span class="literal">-Bit</span> Server VM (build <span class="number">25.65</span><span class="literal">-b01</span>, mixed mode)</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total <span class="number">37888</span>K, used <span class="number">3277</span>K [<span class="number">0</span><span class="type">x00000000d6200000</span>, <span class="number">0</span><span class="type">x00000000d8c00000</span>, <span class="number">0</span><span class="type">x0000000100000000</span>)</span><br><span class="line">  <span class="type">eden</span> <span class="type">space</span> <span class="number">32768</span><span class="type">K</span>, <span class="number">10</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000d6200000</span>,<span class="number">0</span><span class="type">x00000000d65335f0</span>,<span class="number">0</span><span class="type">x00000000d8200000</span>)</span><br><span class="line">  <span class="type">from</span> <span class="type">space</span> <span class="number">5120</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000d8700000</span>,<span class="number">0</span><span class="type">x00000000d8700000</span>,<span class="number">0</span><span class="type">x00000000d8c00000</span>)</span><br><span class="line">  <span class="type">to</span>   <span class="type">space</span> <span class="number">5120</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x00000000d8200000</span>,<span class="number">0</span><span class="type">x00000000d8200000</span>,<span class="number">0</span><span class="type">x00000000d8700000</span>)</span><br><span class="line"> <span class="type">ParOldGen</span>       <span class="type">total</span> <span class="number">86016</span><span class="type">K</span>, <span class="type">used</span> <span class="number">0</span><span class="type">K</span> [<span class="number">0</span><span class="type">x0000000082600000</span>, <span class="number">0</span><span class="type">x0000000087a00000</span>, <span class="number">0</span><span class="type">x00000000d6200000</span>)</span><br><span class="line">  <span class="type">object</span> <span class="type">space</span> <span class="number">86016</span><span class="type">K</span>, <span class="number">0</span>% <span class="type">used</span> [<span class="number">0</span><span class="type">x0000000082600000</span>,<span class="number">0</span><span class="type">x0000000082600000</span>,<span class="number">0</span><span class="type">x0000000087a00000</span>)</span><br><span class="line"> <span class="type">Metaspace</span>       <span class="type">used</span> <span class="number">2367</span><span class="type">K</span>, <span class="type">capacity</span> <span class="number">4480</span><span class="type">K</span>, <span class="type">committed</span> <span class="number">4480</span><span class="type">K</span>, <span class="type">reserved</span> <span class="number">1056768</span><span class="type">K</span></span><br><span class="line">  <span class="type">class</span> <span class="type">space</span>    <span class="type">used</span> <span class="number">259</span><span class="type">K</span>, <span class="type">capacity</span> <span class="number">384</span><span class="type">K</span>, <span class="type">committed</span> <span class="number">384</span><span class="type">K</span>, <span class="type">reserved</span> <span class="number">1048576</span><span class="type">K</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
<h4 id="STW（Stop-the-world）"><a href="#STW（Stop-the-world）" class="headerlink" title="STW（Stop the world）"></a>STW（Stop the world）</h4><p>为了保证程序不会乱套，<strong>在垃圾回收的时候（不管是标记还是整理复制）,暂停用户的一切线程</strong>。也就是在这段时间，你是不能 new 对象的，只能等待。表现在 JVM 上就是短暂的卡顿，什么都干不了。这种现象，就叫作 Stop the world。简称 <strong>STW</strong>。</p>
<p>标记阶段，大多数是要 STW 的。</p>
<p>现在的垃圾回收器，都会尽量去减少这个过程。但即使是最先进的 ZGC，也会有短暂的 STW 过程。</p>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><h5 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h5><p>CMS 的全称是 Mostly Concurrent Mark and Sweep Garbage Collector（主要并发­标记­清除­垃圾收集器），它在年轻代使用<strong>复制</strong>算法，而对老年代使用<strong>标记-清除</strong>算法。年轻代使用 <strong>ParNew</strong>，老年代的用 <strong>CMS</strong>。CMS 的设计目标，是避免在老年代 GC 时出现长时间的卡顿（但它并不是一个老年代回收器）。</p>
<ul>
<li>CMS 主要优点是获得更少的停顿。</li>
<li>CMS 使用的是 Sweep 而不是 Compact，所以它的主要问题是碎片化。解决方法：Full GC进行内存整理，但是该整理会造成较长时间的停顿。</li>
</ul>
<p>优缺点：</p>
<p><strong>优势：</strong>低延迟，尤其对于大堆来说。大部分垃圾回收过程并发执行。<br><strong>劣势：</strong>内存碎片问题。Full GC 的整理阶段，会造成较长时间的停顿。需要预留空间，用来分配收集阶段产生的“浮动垃圾”。使用更多的 CPU 资源，在应用运行的同时进行堆扫描。</p>
<p>CMS 是一种高度可配置的复杂算法，因此给 JDK 中的 GC 代码库带来了很多复杂性。由于 G1 和 ZGC 的产生，CMS 已经在被废弃的路上。</p>
<h5 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h5><p>G1 的目标是用来干掉 CMS 的，它同样是一款软实时垃圾回收器。相比 CMS，G1 的使用更加人性化。</p>
<p>G1 的全称是 Garbage­First GC。其他的回收器，都是对某个年代的整体收集，收集时间上自然不好控制。<strong>G1 把堆切成了很多份，把每一份当作一个小目标，部分上目标很容易达成。</strong></p>
<p>所以 G1 只有<strong>逻辑上的 年轻代和老年代</strong>。</p>
<p>G1 将堆内存 分为 一小份一小份区域，<strong>这一小份区域的大小是固定的，名字叫作小堆区（Region）</strong>。小堆区可以是 Eden 区，也可以是 Survivor 区，还可以是 Old 区。所以 G1 的年轻代和老年代的概念都是逻辑上的。</p>
<p><strong>每一块 Region，大小都是一致的</strong>，它的数值是在 1M 到 32M 字节之间的一个 2 的幂值数。Region 的大小，可以通过参数进行设置：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="literal">-XX</span>:G1HeapRegionSize=&lt;N&gt;M</span><br></pre></td></tr></table></figure>

<p><strong>大小超过 Region 50% 的对象</strong>，将会在 <strong>Humongous Region</strong> 区分配。</p>
<p><strong>垃圾最多的小堆区，会被优先收集。</strong>这就是 G1 名字的由来。</p>
<p><strong>G1 采用分而治之，部分收集的思想</strong>，尽力达到我们给它设定的停顿目标。</p>
<h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><p>优先级：</p>
<ul>
<li>程序优化，效果通常非常大；</li>
<li>扩容，如果金钱的成本比较小，采用扩容服务器资源；</li>
<li>参数调优，在成本、吞吐量、延迟之间找一个平衡点。</li>
</ul>
<h4 id="OOM排查"><a href="#OOM排查" class="headerlink" title="OOM排查"></a>OOM排查</h4><ul>
<li>隔离：把你的这台机器从请求列表里摘除，比如把 nginx 相关的权重设成零。在微服务中，也有相应的隔离机制。目的保证生产问题解决，第二保留现场。</li>
<li>排查问题。</li>
</ul>
<blockquote>
<p>笔记来源 ： 网络 和 李国老师的《深入浅出 JVM虚拟机》课程</p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>并发与多线程（二）</title>
    <url>/2021/02/08/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="并发与多线程（二）"><a href="#并发与多线程（二）" class="headerlink" title="并发与多线程（二）"></a>并发与多线程（二）</h1><h2 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h2><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><p><strong>线程池</strong>通过<strong>复用线程，避免线程频繁地创建和销毁</strong>。Java 的 <strong>Executors</strong> 工具类中提供了 5 种类型的线程池创建方法：</p>
<ul>
<li><strong>newFixedThreadPool</strong>：固定线程数，无界队列，适用于任务数量不均匀的场景，对内存压力不敏感，但系统负载比较敏感的场景；<u>核心和最大线程数都设置成指定的线程数。队列使用无界队列 LinkedBlockingQueue。</u></li>
<li><strong>newCachedThreadPool</strong>：无限线程数，适用于要求低延迟的短期任务场景；<u>核心线程数设置为 0，最大线程数是 Integer.MAX_VALUE，主要是通过把缓冲队列设置成 SynchronousQueue，这样只要没有空闲线程就会新建。</u></li>
<li><strong>newSingleThreadExecutor：</strong>单个线程的固定线程池，适用于保证异步执行顺序的场景；<u>线程数设置为 1 的固定线程池。</u></li>
<li><strong>newScheduledThreadPool</strong>：支持固定频率和固定延迟，适用于定期执行任务的场景；<u>队列使用DelayedWorkQueue，这是一种按延迟时间获取任务的优先级队列。</u></li>
<li><strong>newWorkStealingPool</strong>：<u>使用ForkJoinPool</u>，多任务队列的固定并行度，适合任务执行时长不均匀的场景。</li>
</ul>
<p>以上除了 工作窃取线程池 (<strong>newWorkStealingPool</strong> )外,其他都是通过 <strong>ThreadPoolExecutor</strong> 的不同初始化参数来创建的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">参数说明：</span></span><br><span class="line"><span class="comment">1）核心线程数,默认情况下核心线程会一直存活。</span></span><br><span class="line"><span class="comment">2）最大线程数,决定线程池最多可以创建的多少线程。</span></span><br><span class="line"><span class="comment">3）线程空闲时间,当线程闲置超过空闲时间就会被销毁,可以通过 allowCoreThreadTimeOut 方法来允许核心线程被回收。</span></span><br><span class="line"><span class="comment">4）空闲时间单位：</span></span><br><span class="line"><span class="comment">TimeUnit.DAYS;               //天</span></span><br><span class="line"><span class="comment">    TimeUnit.HOURS;             //小时</span></span><br><span class="line"><span class="comment">    TimeUnit.MINUTES;           //分钟</span></span><br><span class="line"><span class="comment">    TimeUnit.SECONDS;           //秒</span></span><br><span class="line"><span class="comment">    TimeUnit.MILLISECONDS;      //毫秒</span></span><br><span class="line"><span class="comment">    TimeUnit.MICROSECONDS;      //微妙</span></span><br><span class="line"><span class="comment">    TimeUnit.NANOSECONDS;       //纳秒</span></span><br><span class="line"><span class="comment">5）设置缓冲队列：</span></span><br><span class="line"><span class="comment">	ArrayBlockingQueue(capacity) 是一个有界队列，就是指队列有最大容量限制。</span></span><br><span class="line"><span class="comment">	LinkedBlockingQueue 是无界队列，就是队列不限制容量。</span></span><br><span class="line"><span class="comment">	SynchronousQueue，是一个同步队列，内部没有缓冲区。</span></span><br><span class="line"><span class="comment">6）设置线程池工厂方法，线程工厂用来创建新线程，可以用来对线程的一些属性进行定制，例如线程的 group、线程名、优先级等。一般使用默认工厂类即可。</span></span><br><span class="line"><span class="comment">7）设置线程池满时的拒绝策略。有四种策略:</span></span><br><span class="line"><span class="comment">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </span></span><br><span class="line"><span class="comment">    ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span></span><br><span class="line"><span class="comment">    ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span></span><br><span class="line"><span class="comment">    ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 </span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h3 id="线程池任务执行流程"><a href="#线程池任务执行流程" class="headerlink" title="线程池任务执行流程"></a>线程池任务执行流程</h3><p><img src="/2021/02/08/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/concurrent_07.png" alt="线程池执行过程"></p>
<p>向线程提交任务时可以使用 <strong>execute</strong> 和 <strong>submit</strong></p>
<ul>
<li><strong>submit</strong> 可以返回一个 <strong>future</strong> 对象，通过 <strong>future</strong> 对象可以了解任务执行情况，可以取消任务的执行，还可获取执行结果或执行异常。</li>
<li><strong>submit</strong> 最终也是通过 <strong>execute</strong> 执行的。</li>
</ul>
<h3 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a><strong>ThreadPoolExecutor</strong>类</h3><p><strong><em>ThreadPoolExecutor</em></strong> 继承了<strong>AbstractExecutorService</strong>类，<strong><em>AbstractExecutorService</em></strong>是一个抽象类，它实现了<strong>ExecutorService</strong>接口。而<strong><em>ExecutorService</em></strong>又是继承了<strong>Executor</strong>接口，我们看一下<strong>Executor</strong>接口的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Executor</strong>是一个顶层接口，在它里面只声明了一个方法<strong>execute(Runnable)</strong>，返回值为<strong>void</strong>，参数为<strong>Runnable</strong>类型，从字面意思可以理解，就是用来执行传进去的任务的；</p>
<p>然后<strong><em>ExecutorService</em></strong>接口继承了<strong>Executor</strong>接口，并声明了一些方法：<strong>submit、invokeAll、invokeAny</strong>以及<strong>shutDown</strong>等；</p>
<p>抽象类<strong><em>AbstractExecutorService</em></strong>实现了<strong>ExecutorService</strong>接口，基本实现了<strong>ExecutorService</strong>中声明的所有方法；</p>
<p>然后<strong><em>ThreadPoolExecutor</em></strong>继承了类<strong>AbstractExecutorService</strong>。</p>
<p><strong>ThreadPoolExecutor</strong> 提供俩个方法用于线程池的关闭：</p>
<ul>
<li><strong>shutdown</strong>()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>
<li><strong>shutdownNow</strong>()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li>
</ul>
<p><strong>线程池大小设置多少合适？</strong></p>
<p><strong>最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</strong></p>
<p>这里 <strong>线程等待时间</strong> 可以理解为 <strong>线程IO时间</strong>，线程CPU时间 可以由  （<strong>请求时间 - 线程IO 时间</strong>）粗略算得。</p>
<h2 id="Java多线程处理工具类（JUC）"><a href="#Java多线程处理工具类（JUC）" class="headerlink" title="Java多线程处理工具类（JUC）"></a>Java多线程处理工具类（JUC）</h2><p><strong>Java</strong>并发工具类是指 <code>rt.jar</code> 里面的  <strong><em>java.util.concurrent</em></strong> 包下工具类：</p>
<p><img src="/2021/02/08/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/concurrent_06.png" alt="Java并发工具类"></p>
<p>由上图可以看到，我们之前所提到 的  <strong>Condition 、Lock、ReentranLock、Callable</strong>以及 <strong>ConcurrentXXXX</strong>相关类，包括<strong>ForkJoinXXX</strong>相关类，线程池<strong>ThreadPoolXXX</strong> 等都在 该包下。</p>
<h3 id="线程安全-并发容器"><a href="#线程安全-并发容器" class="headerlink" title="线程安全 - 并发容器"></a>线程安全 - 并发容器</h3><h3 id="ArrayList-gt-CopyOnWriteArrayList"><a href="#ArrayList-gt-CopyOnWriteArrayList" class="headerlink" title="ArrayList -&gt; CopyOnWriteArrayList"></a>ArrayList -&gt; CopyOnWriteArrayList</h3><p><strong>写入时复制（CopyOnWrite）思想</strong></p>
<p>　　<strong>写入时复制（CopyOnWrite，简称COW）思想</strong>是计算机程序设计领域中的一种优化策略。其核心思想是，如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。</p>
<p>此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者<strong>只是读取操作时</strong>可以共享同一份资源。</p>
<p><strong>CopyOnWriteArrayList源码解析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点关注其 <strong>add(E e)</strong> 方法，可以看到 其方法内部 使用了 锁，每次新增元素 都是 <strong>Arrays.copyOf</strong> 方法新建一个对象数组，长度为（<strong>len + 1</strong>）,然后 替换 原数组，所以新增元素开销大。</p>
<ul>
<li><strong><em>CopyOnWriteArrayList</em></strong> 实现了<strong>List</strong>接口。</li>
<li>内部持有 一个 <strong>ReentrantLock</strong> 锁对象，新增元素时 加锁。</li>
<li>底层是用<strong>volatile transient</strong>声明的数组 <strong>array</strong>。（volatile 保证可见性，强制主存刷新，防止指令重排，transient 防止序列化）</li>
<li>读写分离，写时复制出一个新的数组，完成插入、修改或者移除操作后将新数组赋值给<strong>array</strong>。</li>
<li>可以看到 每次 新增都需要复制新建 数组，开销大，所以尽量使用 批量添加，提升性能。</li>
<li>与<strong>Vector</strong> 比较，<strong>Vector</strong>是增删改查方法都加了<strong><em>synchronized</em></strong>，保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而<strong><em>CopyOnWriteArrayList</em></strong> 只是在<strong>增删改</strong>上加锁，但是<strong>读</strong>不加锁，在读方面的性能就好于<strong>Vector</strong>，<strong>CopyOnWriteArrayList</strong>支持读多写少的并发情况。</li>
<li><strong>CopyOnWrite</strong>容器只能保证数据的<strong>最终一致性</strong>，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用<strong>CopyOnWrite</strong>容器。</li>
</ul>
<p>同理 <strong>TreeSet -&gt; CopyOnWriteArraySet</strong> 不再赘述。也可自己实现 CopyOnWriteHashMap试试。</p>
<h3 id="HashMap-gt-ConcurrentHashMap"><a href="#HashMap-gt-ConcurrentHashMap" class="headerlink" title="HashMap -&gt; ConcurrentHashMap"></a>HashMap -&gt; ConcurrentHashMap</h3><p>与 <strong><em>HashMap</em></strong> 一样，<strong>ConcurrentHashMap</strong>  结构基本类似，是基于 <strong>数组 + 链表（红黑树）</strong> 的方式实现 ，如果链表过长会转换为<strong>红黑树</strong> ，只不过在 它要保证线程安全（<strong>synchronized + CAS</strong>）</p>
<p>这里所说的 都是 <strong>jdk 1.8</strong> 版本的实现方式，<strong>jdk1.7</strong> 的方式是 <strong>segments 分段锁的方式</strong> ,后面详解。</p>
<p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 得到 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 用于记录相应链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果数组"空"，进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组</span></span><br><span class="line">            tab = initTable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找该 hash 值对应的数组下标，得到第一个节点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果数组该位置为空，</span></span><br><span class="line">            <span class="comment">//    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span></span><br><span class="line">            <span class="comment">//          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断 hash == MOVED，进行数据迁移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮助数据迁移</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 到这里就是说，f 是该位置的头结点，而且不为空</span></span><br><span class="line"></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获取数组该位置的头结点的监视器锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 头结点的 hash 值大于 0，说明是链表</span></span><br><span class="line">                        <span class="comment">// 用于累加，记录链表的长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果发现了"相等"的 key，判断是否要进行值覆盖，然后也就可以 break 了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 到了链表的最末端，将这个新值放到链表的最后面</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// binCount != 0 说明上面在做链表操作</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span></span><br><span class="line">                    <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上述源码可知，我们需要重点关注 3个方法：</p>
<ul>
<li><p><strong>initTable</strong>() 初始化方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// 获取到锁，SIZECTL = -1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 传入大小或者默认 16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据迁移方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Helps transfer if a resize is in progress.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">     <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">         (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">         <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                 sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                 <span class="comment">// 开始数据迁移</span></span><br><span class="line">                 transfer(tab, nextTab);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> nextTab;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> table;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>数据迁移的方法为 <strong>transfer</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment">   * above for explanation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">      <span class="comment">// 如果 CPU 个数大于1 ，则 stride = (n &gt;&gt;&gt; 3) / NCPU  与 MIN_TRANSFER_STRIDE 的最小值</span></span><br><span class="line">      <span class="comment">// 如果 CPU 个数为1，则 strde 值为  16 </span></span><br><span class="line">      <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">          stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">      <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">              Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">              nextTab = nt;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">              sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          nextTable = nextTab;</span><br><span class="line">          transferIndex = n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">      ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">      <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">          Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">          <span class="comment">// 循环使用CAS不断尝试为当前线程分配任务</span></span><br><span class="line">          <span class="comment">// 直到分配成功或任务队列全部分配完毕</span></span><br><span class="line">          <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">              <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">              <span class="comment">// --i表示下一个待处理的bucket，&gt;=bound 表示当前线程已经被分配过</span></span><br><span class="line">              <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                  advance = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">// 代表所有的bucket都已分配</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  i = -<span class="number">1</span>;</span><br><span class="line">                  advance = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//通过CAS来修改TRANSFERINDEX,为当前线程分配任务，处理的节点区间为</span></span><br><span class="line">	(nextBound,nextIndex)-&gt;(<span class="number">0</span>,<span class="number">15</span>)</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                       (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                        nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                     nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                  bound = nextBound;</span><br><span class="line">                  i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                  advance = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">              <span class="keyword">int</span> sc;</span><br><span class="line">              <span class="comment">// 处理完数据迁移</span></span><br><span class="line">              <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                  <span class="comment">// 对象挥手</span></span><br><span class="line">                  nextTable = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">// table指向新table</span></span><br><span class="line">                  table = nextTab;</span><br><span class="line">                  <span class="comment">// 阈值为 新长度 *0.75 = 2n * 0.75 = 2n - 0.5n = 1.5n</span></span><br><span class="line">                  sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">              <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                  <span class="comment">// 这个地方是用来判断 是否全部任务完成</span></span><br><span class="line">                  <span class="comment">// 因为第一个线程扩容时会设置 sizeCtl = resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT + 2，参见  tryPresize 方法的最后面</span></span><br><span class="line">                  <span class="comment">// 后续帮其扩容的线程，执行transfer方法之前，会设置 sizeCtl = sizeCtl+1 </span></span><br><span class="line">			<span class="comment">// 每一个退出transfer的方法的线程，退出之前，会设置 sizeCtl = sizeCtl-1 </span></span><br><span class="line">                  <span class="comment">// 所以当所有线程完成任务，sc= resizeStamp(n)&lt;&lt; RESIZE_STAMP_SHIFT +2</span></span><br><span class="line">                  <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  <span class="comment">// 相等则扩容结束</span></span><br><span class="line">                  finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                  i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果位置i处是空的，则初始化为ForwardingNode节点</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">              advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">          <span class="comment">//表示该位置已经完成了迁移，也就是如果线程A已经处理过这个节点，那么线程B处理这个节点</span></span><br><span class="line">时，hash值一定为MOVED </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">              advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                      Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                      <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                          <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                          Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                          <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                              <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                              <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                  runBit = b;</span><br><span class="line">                                  lastRun = p;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                              ln = lastRun;</span><br><span class="line">                              hn = <span class="keyword">null</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              hn = lastRun;</span><br><span class="line">                              ln = <span class="keyword">null</span>;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                              <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                              <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                  ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                          &#125;</span><br><span class="line">                          setTabAt(nextTab, i, ln);</span><br><span class="line">                          setTabAt(nextTab, i + n, hn);</span><br><span class="line">                          setTabAt(tab, i, fwd);</span><br><span class="line">                          advance = <span class="keyword">true</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                          TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                          TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                          TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                          <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                          <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                              <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                              TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                  (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                              <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                  <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                      lo = p;</span><br><span class="line">                                  <span class="keyword">else</span></span><br><span class="line">                                      loTail.next = p;</span><br><span class="line">                                  loTail = p;</span><br><span class="line">                                  ++lc;</span><br><span class="line">                              &#125;</span><br><span class="line">                              <span class="keyword">else</span> &#123;</span><br><span class="line">                                  <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                      hi = p;</span><br><span class="line">                                  <span class="keyword">else</span></span><br><span class="line">                                      hiTail.next = p;</span><br><span class="line">                                  hiTail = p;</span><br><span class="line">                                  ++hc;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                          ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                              (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                          hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                              (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                          setTabAt(nextTab, i, ln);</span><br><span class="line">                          setTabAt(nextTab, i + n, hn);</span><br><span class="line">                          setTabAt(tab, i, fwd);</span><br><span class="line">                          advance = <span class="keyword">true</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/08/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/concurrent_08.png" alt="concurrentHashMap扩容"></p>
</li>
<li><p>链表转为红黑树的方法</p>
<p>这里有个判断，即当前链表<strong>达到阈值（8）后</strong>，并不是第一时间转为红黑树，二是<strong>先判断当前数组长度是否小于</strong> <strong>MIN_TREEIFY_CAPACITY</strong>（即64），如果小于则 数组扩容，然后重新hash，<strong>数据迁移</strong>。不小于则转为红黑树。</p>
</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><strong><em>ConcurrentHashMap</em></strong> <strong>1.8</strong>实现方式 类似于 <strong><em>HashMap</em></strong>,底层是由 <strong>数组 +链表（红黑树）</strong>方式，只是添加了 <strong>CAS + synchronized</strong> 保证线程安全。</li>
<li><strong><em>ConcurrentHashMap</em></strong> 链表数量达到<strong>阈值</strong>后，并未直接转换为 红黑树，而是先判断 数组长度是否 小于64 ，如果小于64，则优先 扩容数组。否则转换为红黑树。</li>
<li><strong><em>ConcurrentHashMap</em></strong> 扩容时，空过 <strong>sizeCtl</strong> 控制多线程一起扩容，即当<strong><em>ConcurrentHashMap</em></strong> 扩容时，其他线程并非空闲等待，而是帮助扩容线程共同完成扩容操作。<ul>
<li><strong><em>sizeCtl</em></strong> 为 <strong>-1</strong> 时，<strong><em>ConcurrentHashMap</em></strong>正在初始化</li>
<li><strong><em>sizeCtl</em></strong> 为 正数时，属于使用阶段，sizeCtl = size * 0.75 （阈值）</li>
<li><strong><em>sizeCtl</em></strong> 为 负数时，处于扩容阶段，-N ,其中 <strong>-N 的低16位二进制  = 正在参与扩容线程数 + 1</strong></li>
</ul>
</li>
</ul>
<p>与 <strong>jdk1.8</strong> 实现方式不同的是，<strong>jdk1.7</strong> 使用了<strong>锁分段技术</strong>，首先将数据分成一段一顿的存储,然后给每一段数据配一把锁,当一个线程占用锁访问其中一段数据的时候,其他段的数据也能被其他线程访问到.另外<strong><em>ConcurrentHashMap</em></strong>可以做到读取数据不加锁。</p>
<p><strong><em>ConcurrentHashMap</em></strong>是由<strong>Segment</strong>数组结构和<strong>HashEntry</strong>数组结构组成.<strong>Segment</strong>是一种可重用锁<strong>ReentrantLock</strong>, <strong>HashEntry</strong>用于存储键值对数据.一个<strong>ConcurrentHashMap</strong>中包含一个<strong>Segement</strong>数组,</p>
<p>每个 <strong>Segement</strong> 结构和 <strong>HashMap</strong> 类似,是一种数组和链表结构.一个 <strong>Segment</strong> 里包含一个 <strong>HashEntry</strong> 数组,每一个 <strong>HashEntry</strong> 是一个链表结构,每当对 <strong>HashEntry</strong> 数组的数据进行修改时,必须首先获得它对应的 <strong>Segment</strong> 锁.</p>
<p><img src="/2021/02/08/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/concurrent_09.png" alt="jdk1.7ConcurrentHashMap实现"></p>
<p><strong><em>ConcurrentHashMap</em></strong>查询 定位一个元素需要进行俩次<strong>Hash</strong>操作，第一次 <strong>Hash</strong> 定位到<strong>segment</strong>，第二次<strong>Hash</strong>定位到 链表头部，所以<strong>Hash</strong>过程比一般<strong>HashMap</strong>要久。</p>
<p><strong><em>ConcurrentHashMap</em></strong> 写操作只需要对 <strong>segment</strong> 加锁即可，不会影响其他<strong>segment</strong> 操作，所以理想情况下，并发数为 <strong>segment</strong> 数量。</p>
<p>还需要注意的一点是，1.7 中 <strong>size</strong> 是需要统计 所有<strong>segment</strong> 内元素数量相加，需要所有<strong>segment</strong> 加锁统计，但是 因为性能问题作者并未 一开始 就全部加锁，而是采用俩次统计的方式，如果俩次统计对比数量一致，则期间并未涉及元素增删，如果俩次统计数量不一致，则再全部<strong>segment</strong>加锁统计。</p>
<p>补充：<strong>HashTable</strong> 和 <strong>Collections.synchronizeMap()</strong> (内部实现为 SynchronizeMap) 都是使用<strong>synchronized</strong> 关键字，性能相比<strong><em>ConcurrentHashMap</em></strong> 较低一些。</p>
<h3 id="AQS（AbstractQueuedSynchronizer）"><a href="#AQS（AbstractQueuedSynchronizer）" class="headerlink" title="AQS（AbstractQueuedSynchronizer）"></a>AQS（AbstractQueuedSynchronizer）</h3><p><strong>抽象的队列式的同步器（AbstractQueuedSynchronizer），AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch等</strong>。</p>
<p><strong>特点：</strong></p>
<ol>
<li>使用<strong>Node实现FIFO队列</strong>，可以用于构建锁或则其他同步装置的基础框架</li>
<li>利用一个int类型（<strong>state</strong>）表示状态</li>
<li>使用方法是基础</li>
<li>子类通过继承并通过实现它的方法管理其状态 { acquire 和 release} 的方法操纵状态</li>
<li>可以同时实现<strong>排他锁</strong>和<strong>共享锁模式</strong>（独占、共享）</li>
</ol>
<p>AQS维护了一个 <strong><em>volatile int state</em></strong>（代表共享资源）和一个<strong>FIFO线程等待队列</strong>（多线程争用资源被阻塞时会进入此队列）。这里<strong>volatile</strong>是核心关键词。<strong>state</strong>的访问方式有三种:</p>
<ul>
<li><strong>getState</strong>()</li>
<li><strong>setState</strong>()</li>
<li><strong>compareAndSetState</strong>()</li>
</ul>
<p><strong>AQS定义两种资源共享方式：</strong></p>
<ul>
<li><strong>Exclusive</strong>（独占，只有一个线程能执行，如ReentrantLock）</li>
<li><strong>Share</strong>（共享，多个线程可同时执行，如Semaphore/CountDownLatch）</li>
</ul>
<p>不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<ul>
<li><strong>isHeldExclusively</strong>()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li><strong>tryAcquire</strong>(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li><strong>tryRelease</strong>(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li><strong>tryAcquireShared</strong>(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li><strong>tryReleaseShared</strong>(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<h4 id="简单应用-Mutex-互斥锁"><a href="#简单应用-Mutex-互斥锁" class="headerlink" title="简单应用-Mutex(互斥锁)"></a>简单应用-Mutex(互斥锁)</h4><p><strong>Mutex</strong>是一个不可重入的互斥锁实现。<strong>锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。</strong>下边是Mutex的核心源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否锁定状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取资源，立即返回。成功则返回true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)<span class="comment">//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正同步类的实现都依赖继承于AQS的自定义同步器！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unlock&lt;--&gt;release。两者语文一样：释放资源。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁是否占有状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。</strong>当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！<strong>而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了</strong>，我们不用关心。</p>
<p><strong>除了Mutex，ReentrantLock/CountDownLatch/Semphore这些同步类的实现方式都差不多</strong>，不同的地方就在获取-释放资源的方式<strong>tryAcquire-tryRelelase。</strong></p>
<h2 id="其他常用类"><a href="#其他常用类" class="headerlink" title="其他常用类"></a>其他常用类</h2><p>CountDownLatch<br>Semaphore<br>CyclicBarrier<br>ReentrantLock<br>Condition<br>FutureTask</p>
<blockquote>
<p>笔记来源：<a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">https://www.cnblogs.com/waterystone/p/4920797.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发与多线程（一）</title>
    <url>/2021/02/08/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Java并发与多线程（一）"><a href="#Java并发与多线程（一）" class="headerlink" title="Java并发与多线程（一）"></a>Java并发与多线程（一）</h1><p>在前面 <a href="http://blogsea.cn/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">《操作系统与计算机网络（一）》</a>中，我们已经复习了<strong>进程与线程</strong>的相关概念，包括进程的分时和调度，进程和线程的状态，进（线）程的切换，锁、信号量，包括 死锁（预防死锁）、互斥锁和乐观锁的概念 ，互斥和同步的定义。还有分布式锁。后面 还复习了 线程的调度，进程间通信等。</p>
<p>以上 我们所说的 内容大多为概念，硬件层面的知识点。复习它们有效的帮助我们更好的理解对进程、线程、以及锁的使用。</p>
<p>本节，我们将主要复习在 <strong>Java</strong> 语言中我们如何使用以及常见问题：</p>
<ul>
<li><p>线程的使用；线程生命周期：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED;</p>
</li>
<li><p>详解Java 线程的常用方法：sleep() 和 yield() 、wait()、notify() 和 notifyAll() 、Lock+Condition等。</p>
</li>
<li><p>详解同步与互斥：synchronized、Lock、CAS。</p>
</li>
<li><p>详解Java多线程机制：例如ThreadLocal线程独享，Fork/join 大任务拆分机制，Volatile 保证数据可见性原理，Interrupt 中断机制等。</p>
</li>
<li><p>Java线程池的使用。</p>
</li>
<li><p>Java多线程处理工具类（JUC）：ConcurrentXXX、AtomicXXX、CopyOnWriteArrayList、ConcurrentHashMap等。</p>
</li>
</ul>
<h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p>Java 中创建线程的三种方式：</p>
<ul>
<li>继承 <strong>Thread</strong> 类：重写 <strong>run()</strong> 方法，调用 <strong>start()</strong> 方法启动线程。</li>
<li>实现 <strong>Runnable</strong> 接口：重写 <strong>run()</strong> 方法，调用 <strong>start()</strong> 方法启动线程。</li>
<li>通过 <strong>Callable</strong> 和 <strong>Future</strong> 创建线程：实现 <strong>call()</strong> 方法（有返回值），使用 <strong>FutureTask</strong> 类来包装 <strong>Callable</strong>对象，调用 <strong>FutureTask</strong> 对象的 <strong>get()</strong> 方法来获得子线程执行结束后的返回值。</li>
</ul>
<p>优劣对比：接口实现的方式 可以 继承其他类，也可以实现其他接口，对线程类限制较少，Callable 的方式 可以获取返回值。而Thread 类方式创建较为简单。</p>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p><strong>线程</strong>是 JVM 执行任务的最小单元，理解线程的状态转换是理解后续多线程问题的基础。在 JVM 运行中，线程一共有 <strong>NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED</strong> 六种状态，这些状态对应 <strong>Thread.State</strong> 枚举类中的状态。</p>
<p><img src="/2021/02/08/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/concurrent_01.png" alt="线程的生命周期"></p>
<ul>
<li><p>当创建一个线程时，线程处在 <strong>NEW</strong> 状态，运行 <strong>Thread</strong> 的 <strong>start()</strong> 方法后，线程进入 <strong>RUNNABLE</strong> 可运行状态。</p>
</li>
<li><p>这时，所有<strong>可运行状态</strong>的线程并不能马上运行，而是需要先进入<strong>就绪状态</strong>等待<strong>线程调度</strong>，如图中间所示的 <strong>READY</strong> 状态。在<strong>获取 CPU 后</strong>才能进入<strong>运行状态</strong>，如图中所示的 <strong>RUNNING</strong>。运行状态可以随着不同条件转换成除 NEW 以外的其他状态。</p>
</li>
<li><p>在运行态中的线程进入 <strong>synchronized</strong> 同步块或者同步方法时，如果<strong>获取锁失败</strong>，则会进入到 <strong>BLOCKED</strong> 状态。当获取到锁后，会从 <strong>BLOCKED</strong> 状态恢复到<strong>就绪状态</strong>。</p>
</li>
<li><p>运行中的线程还会进入<strong>等待状态</strong>，这两个等待一个是有超时时间的等待，例如调用 <strong>Object.wait、Thread.join</strong> 等；另外一个是无超时的等待，例如调用 <strong>Thread.join</strong> 或者 <strong>Locksupport.park</strong> 等。这两种等待都可以通过 <strong>notify</strong> 或 <strong>unpark</strong> 结束等待状态并恢复到就绪状态。</p>
</li>
<li><p>最后是线程运行完成结束时，线程状态变成 <strong>TERMINATED</strong>。</p>
</li>
</ul>
<p><strong>阻塞分三种情况：</strong></p>
<ul>
<li><strong>等待阻塞</strong>：运行的线程执行<strong>wait()</strong>方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池中”。进入这个状态后是不能自动唤醒的，必须依靠其他线程调用<strong>notify</strong>()或者<strong>notifyAll</strong>()方法才能被唤醒。</li>
<li><strong>同步阻塞</strong>：运行的线程在获取对象的（<strong>synchronized</strong>）同步锁时，若该同步锁被其他线程占用，则JVM会吧该线程放入“锁池”中。</li>
<li><strong>其他阻塞</strong>：通过调用线程的<strong>sleep</strong>()或者<strong>join</strong>()或发出了I/O请求时，线程会进入到阻塞状态。当<strong>sleep</strong>()状态超时、<strong>join</strong>()等待线程终止或者超时、或者I/O处理完毕时，线程重新回到就绪状态。</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li><p>一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。主线程的名字总是<strong>main</strong>。</p>
</li>
<li><p>获取当前线程的对象的方法是：<strong>Thread.currentThread()</strong>；</p>
</li>
<li><p>一系列线程以某种顺序启动并不意味着将按该顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。</p>
</li>
<li><p>线程的调度是<strong>JVM</strong>的一部分，在一个<strong>CPU</strong>的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。</p>
</li>
<li><p>尽管我们没有无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。线程调度可以 参考<a href="http://blogsea.cn/2021/01/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">《操作系统与计算机网络（一）》</a>。</p>
</li>
</ul>
<h3 id="线程常见方法"><a href="#线程常见方法" class="headerlink" title="线程常见方法"></a>线程常见方法</h3><h4 id="sleep-和-yield"><a href="#sleep-和-yield" class="headerlink" title="sleep() 和 yield()"></a>sleep() 和 yield()</h4><p> <strong>Thread.sleep(long millis)</strong> 和 <strong>Thread.sleep(long millis, int nanos)</strong> 静态方法强制当前正在执行的线程休眠（暂停执行），以 “减慢线程”。当线程睡眠时，在苏醒之前不会返回到可运行状态。当睡眠时间到期，则返回到<strong>可运行状态</strong>（这里不是运行状态，sleep()方法不能保证该线程睡眠到期后就开始执行）。</p>
<p><strong>sleep()</strong>是静态方法，只能控制当前正在运行的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    Thread.sleep(<span class="number">100</span>);  </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">    e.printStackTrace();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <strong>wait()</strong> 方法对比：</p>
<ul>
<li><p><strong>sleep()</strong>方法是<strong>Thread</strong>类里面的，主要的意义就是让当前线程停止执行，让出cpu给其他的线程，但是<strong>不会释放对象锁资源以及监控的状态</strong>，当指定的时间到了之后又会自动恢复运行状态。sleep() 方法可以用在任何地方。</p>
</li>
<li><p><strong>wait()</strong>方法是<strong>Object</strong>类里面的，主要的意义就是让线程放弃当前的对象的锁，进入等待此对象的锁的阻塞队列（<strong>每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。</strong>就绪队列存储了已就绪（将要竞争锁）的线程，阻塞队列存储了被阻塞的线程。当一个阻塞线程被唤醒后，才会进入就绪队列，进而等待CPU的调度；反之，当一个线程被wait后，就会进入阻塞队列，等待被唤醒。）只有针对此对象调动<strong>notify</strong>方法后本线程才能够进入对象锁的就绪队列，准备获取对象锁进入运行状态。<strong>wait</strong>，<strong>notify</strong>和<strong>notifyAll</strong>只能在同步控制方法或者同步控制块里面使用。</p>
</li>
</ul>
<p><strong>线程优先级和线程让步</strong></p>
<p>线程的让步是通过<strong>Thread.yield()</strong>来实现的。</p>
<p><strong>yield()</strong>方法的作用是：暂停当前正在执行的线程对象，并执行其他线程。而实际上 <strong>yield()</strong>做的仅仅是让当前运行线程回到<strong>可运行状态</strong>， 以允许具有相同优先级的其他线程获得运行机会。其目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证<strong>yield()</strong>达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p>
<p>要理解<strong>yield()</strong>，必须了解线程的优先级的概念。线程总是存在优先级，优先级范围在1~10之间。JVM线程调度程序是基于优先级的抢先调度机制。默认优先级 是5。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>设置 线程的优先级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> MyThread();  </span><br><span class="line">t.setPriority(<span class="number">8</span>);  </span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p><strong>join() 方法</strong></p>
<p><strong>Thread</strong>的方法 <strong>join()</strong> 让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。</p>
<p>同时 还支持带超时参数的 方法 <strong>join(long millis)</strong>。</p>
<h4 id="wait-notify-和-notifyAll"><a href="#wait-notify-和-notifyAll" class="headerlink" title="wait(), notify() 和 notifyAll()"></a>wait(), notify() 和 notifyAll()</h4><p>这三个方法都是定义到<strong>Object</strong>类中，<strong>wait()</strong> 的作用是让当前线程释放它所持有的锁进入等待状态，而 <strong>notify()</strong> 和 <strong>notifyAll()</strong> 则是唤醒当前对象上的等待线程。</p>
<ul>
<li><p><strong>notify()</strong>： 唤醒在此对象监视器上等待的单个线程。</p>
</li>
<li><p><strong>notifyAll()</strong> ： 唤醒在此对象监视器上等待的所有线程。</p>
</li>
<li><p><strong>wait()</strong>： 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 <strong>notify()</strong> 方法或 <strong>notifyAll()</strong> 方法”，当前线程被唤醒(进入“就绪状态”)。</p>
</li>
<li><p><strong>wait(long timeout)</strong>：让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 <strong>notify()</strong> 方法或 <strong>notifyAll()</strong> 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</p>
</li>
<li><p><strong>wait(long timeout, int nanos)</strong>： 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 <strong>notify()</strong> 方法或 <strong>notifyAll()</strong> 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</p>
</li>
</ul>
<p><strong>wait()</strong> 会使“当前线程”等待，并且会释放到它所占用的“锁标志”，从而使线程所在对象中的其他<strong>synchronized</strong>数据可以被其他线程使用。</p>
<p>负责唤醒等待线程的那个线程(我们称为“<strong>唤醒线程</strong>”)，它只有在获取“该对象的同步锁”(<strong>这里的同步锁必须和等待线程的同步锁是同一个</strong>)，并且调用 <strong>notify()</strong> 或 <strong>notifyAll()</strong> 方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为<strong>唤醒线程</strong>还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/2/3 16:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitTestMain</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">"获取了锁对象。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">"调用了wait 方法阻塞并释放了锁。"</span>);</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">"执行完成。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">"获取了锁对象。"</span>);</span><br><span class="line">                lock.notify();</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">"调用了 notify 方法唤醒了阻塞的线程。"</span>);</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">"执行完成。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread1();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread2();</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">线程Thread-0获取了锁对象。</span></span><br><span class="line"><span class="comment">线程Thread-0调用了wait 方法阻塞并释放了锁。</span></span><br><span class="line"><span class="comment">线程Thread-1获取了锁对象。</span></span><br><span class="line"><span class="comment">线程Thread-1调用了 notify 方法唤醒了阻塞的线程。</span></span><br><span class="line"><span class="comment">线程Thread-1执行完成。</span></span><br><span class="line"><span class="comment">线程Thread-0执行完成。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>



<h4 id="Lock-Condition模式"><a href="#Lock-Condition模式" class="headerlink" title="Lock+Condition模式"></a>Lock+Condition模式</h4><p><strong>wait-notify</strong> 机制 的实现 不仅有 <strong>synchronized+wait-notify</strong>模式，还有一种 <strong>Lock+Condition</strong> 的模式实现。</p>
<p><strong>相比使用Object的wait()/notify()，使用 Condition 的 await()/signal() 这种方式能够更加安全和高效地实现线程间协作。Condition是个接口，基本的方法就是 await() 和 signal() 方法。Condition依赖于Lock接口，生成一个Condition的基本代码是 lock.newCondition() 。 必须要注意的是，Condition 的 await()/signal() 使用都必须在 lock 保护之内，也就是说，必须在 lock.lock() 和 lock.unlock 之间才可以使用。</strong></p>
<p>事实上，<strong>Conditon</strong> 的 <strong>await()/signal()</strong> 与 <strong>Object</strong> 的 <strong>wait()/notify()</strong> 有着天然的对应关系：</p>
<ul>
<li>Conditon中的 await() 对应 Object 的 wait()；</li>
<li>Condition中的 signal() 对应 Object 的 notify()；</li>
<li>Condition中的 signalAll() 对应 Object 的 notifyAll()。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: charleyZZZZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/2/3 16:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程A</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> MyService service;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(MyService service)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.service = service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            service.waitA();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程 B</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> MyService service;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(MyService service)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.service = service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            service.waitB();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">// 使用多个Condition实现通知部分线程</span></span><br><span class="line">        <span class="keyword">public</span> Condition conditionA = lock.newCondition();</span><br><span class="line">        <span class="keyword">public</span> Condition conditionB = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitA</span><span class="params">()</span></span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">"获取了锁对象。"</span>);</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">"调用了await 方法阻塞并释放了锁。"</span>);</span><br><span class="line">                conditionA.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">"执行结束。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitB</span><span class="params">()</span></span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">"获取了锁对象。"</span>);</span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">"调用了 await 方法阻塞并释放了锁。"</span>);</span><br><span class="line">                conditionB.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">"执行结束。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalAllA</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                conditionA.signalAll();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalAllB</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                conditionB.signalAll();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyService service = <span class="keyword">new</span> MyService();</span><br><span class="line">        ThreadA a = <span class="keyword">new</span> ThreadA(service);</span><br><span class="line">        ThreadB b = <span class="keyword">new</span> ThreadB(service);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        service.signalAllA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">线程Thread-0获取了锁对象。</span></span><br><span class="line"><span class="comment">线程Thread-0调用了await 方法阻塞并释放了锁。</span></span><br><span class="line"><span class="comment">线程Thread-1获取了锁对象。</span></span><br><span class="line"><span class="comment">线程Thread-1调用了 await 方法阻塞并释放了锁。</span></span><br><span class="line"><span class="comment">线程Thread-0执行结束。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<p>由上面的示例结果来看，A线程被唤醒，B线程仍然阻塞。</p>
<p><strong>Condition的优点在于 实现了一种分组机制，将所有对临界资源进行访问的线程进行分组，以便实现线程间更精细化的协作，例如通知部分线程。</strong></p>
<h4 id="suspend-和-resume"><a href="#suspend-和-resume" class="headerlink" title="suspend() 和 resume()"></a>suspend() 和 resume()</h4><p>两个方法配套使用，<strong>suspend()</strong> 使得线程进入阻塞状态，并且不会自动恢复，必须其对应的 <strong>resume()</strong> 被调用，才能使得线程重新进入可执行状态。典型地，<strong>suspend()和 resume() 被用在等待另一个线程产生的结果的情形：</strong>测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 <strong>resume()</strong> 使其恢复。</p>
<p><strong>与 wait()\notify()\notifyAll() 的区别：</strong></p>
<p><strong>suspend()</strong>及其它所有方法在线程阻塞时都不会释放占用的锁（如果占用了的话），而<strong>wait()</strong> 则会释放 占用的锁。</p>
<p>源码显示 suspend 已是一个 <strong>不推荐使用的方法</strong>，了解即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    suspend0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="同步和锁"><a href="#同步和锁" class="headerlink" title="同步和锁"></a>同步和锁</h3><h4 id="CAS-和-ABA"><a href="#CAS-和-ABA" class="headerlink" title="CAS 和 ABA"></a>CAS 和 ABA</h4><p><strong>CAS</strong> 是<strong>乐观锁</strong>的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。这是一种乐观策略，认为并发操作并不总会发生。</p>
<p>比较并写回的操作是通过操作系统原语实现的，保证执行过程中不会被中断。</p>
<p><strong>CAS</strong> 容易出现 <strong>ABA</strong> 问题，即如果线程 T1 读取值 A 之后，发生两次写入，先由线程 T2 写回了 B，又由 T3 又写回了 A，此时 T1 在写回比较时，值还是 A，就无法判断是否发生过修改。</p>
<p><strong>ABA</strong> 问题不一定会影响结果，但还是需要防范，解决的办法可以增加额外的<strong>标志位或者时间戳</strong>。JUC 工具包中提供了这样的类。</p>
<h4 id="详解-synchronized"><a href="#详解-synchronized" class="headerlink" title="详解 synchronized"></a>详解 synchronized</h4><p><strong>synchronized</strong> 是最常用的线程同步手段之一。</p>
<p><strong>synchronized</strong> 对对象进行加锁，在 JVM 中，对象在内存中分为三块区域：<strong>对象头</strong>、实例数据和对齐填充。在对象头中保存了锁标志位和指向 <strong>monitor</strong> 对象的起始地址。当 <strong>Monitor</strong> 被某个线程持有后，就会处于锁定状态，如图中的 <strong>Owner</strong> 部分，会指向持有 <strong>Monitor</strong> 对象的线程。另外 <strong>Monitor</strong> 中还有两个队列，用来存放进入及等待获取锁的线程。</p>
<p><img src="/2021/02/08/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/concurrent_02.png" alt="Monitor对象"></p>
<p><strong>synchronized</strong> 应用在方法上时，在字节码中是通过方法的 <strong>ACC_SYNCHRONIZED</strong> 标志来实现的，<strong>synchronized</strong> 应用在同步块上时，在字节码中是通过 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 实现的。</p>
<p>针对 <strong>synchronized</strong> 获取锁的方式，JVM 使用了<strong>锁升级的优化方式</strong>（1.6之后），就是先使用<strong>偏向锁</strong>优先同一线程再次获取锁，如果失败，就升级为 <strong>CAS 轻量级锁</strong>，如果失败就会短暂<strong>自旋</strong>，防止线程被系统挂起。最后如果以上都失败就升级为<strong>重量级锁</strong>。</p>
<p><strong>补充知识点：</strong></p>
<p><strong>Java 对象头</strong></p>
<ul>
<li><p>字宽（Word）: 内存大小的单位概念， 对于 32 位处理器 1 Word = 4 Bytes， 64 位处理器 1 Word = 8 Bytes。</p>
</li>
<li><p>每一个 Java 对象都至少占用 2 个字宽的内存(数组类型占用3个字宽)。</p>
<ul>
<li>第一个字宽也被称为对象头<strong>Mark Word</strong>。 对象头包含了多种不同的信息， 其中就包含对象锁相关的信息。 </li>
<li>第二个字宽是指向定义该对象类信息（class metadata）的指针。</li>
</ul>
</li>
<li><p>非数组类型的对象头的结构如下图</p>
<p><img src="/2021/02/08/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/concurrent_03.png" alt="对象头结构"></p>
</li>
<li><p>MarkWord 中包含对象 hashCode 的那种无锁状态是偏向机制被禁用时，JVM 提供了关闭偏向锁的机制， JVM 启动命令指定如下参数即可。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">-XX</span>:<span class="string">-UseBiasedLocking</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>偏向机制被启用时，分配出来的对象状态是 <strong>线程ID|Epoch|age|1|01</strong>, 线程ID 为空时标识对象尚未偏向于任何一个线程， 线程ID 不为空时， 对象既可能处于偏向特定线程的状态， 也有可能处于已经被特定线程占用完毕释放的状态， 需结合 Epoch 和其他信息判断对象是否允许再偏向（rebias）。</p>
</li>
</ul>
<p><strong>CAS指令</strong></p>
<ul>
<li><strong>CAS</strong> （Compare And Swap） 指令是一个CPU层级的原子性操作指令。 在 Intel 处理器中， 其汇编指令为 cmpxchg。</li>
<li><strong>CAS</strong> 指令遵循 CAS 模型，会引起ABA问题。</li>
</ul>
<h5 id="偏向锁加锁过程"><a href="#偏向锁加锁过程" class="headerlink" title="偏向锁加锁过程"></a><strong>偏向锁加锁过程</strong></h5><p>向锁的获取方式是将对象头的 <strong>MarkWord</strong> 部分中， 标记上<strong>线程ID</strong>， 以表示哪一个线程获得了偏向锁。具体步骤如下：</p>
<ol>
<li>首先读取目标对象的 <strong>MarkWord</strong>, 判断是否处于<strong>可偏向</strong>的状态。</li>
<li>如果为<strong>可偏向状态</strong>, 则尝试用 <strong>CAS</strong> 操作， 将自己的线程 ID 写入<strong>MarkWord</strong>。</li>
<li>如果<strong>CAS</strong>操作成功，则认为已经获取到该对象的<strong>偏向锁</strong>，执行同步块代码 。一个线程在执行完同步代码块以后， 并不会尝试将 MarkWord 中的 <strong>thread ID</strong> 赋回原值 。如果该线程需要<strong>再次</strong>对这个对象加锁，而这个对象之前一直没有被其他线程尝试获取过锁，依旧停留在可偏向的状态下， 即可在不修改对象头的情况下（即不需要再进行CAS操作，单线程优化，即偏向锁的作用） 直接认为偏向成功。</li>
<li>如果 是<strong>已偏向状态</strong>，则检测 MarkWord 中存储的 <strong>thread ID</strong> 是否等于当前 <strong>thread ID</strong> 。<ul>
<li>如果相等， 则证明本线程已经获取到偏向锁， 可以直接继续执行同步代码块</li>
<li>如果不等， 则证明该对象目前偏向于其他线程， 需要<strong>撤销</strong>偏向锁</li>
</ul>
</li>
</ol>
<p><strong>偏向锁的作用</strong></p>
<p>Java偏向锁(Biased Locking)是Java6引入的一项多线程优化。它通过<strong>消除资源无竞争情况下的同步原语</strong>，进一步提高了程序的运行性能。即<strong>在无竞争场景下完全消除同步，连CAS也不执行</strong>(CAS本身仍旧是一种操作系统同步原语，始终要在JVM与OS之间来回，有一定的开销)。</p>
<h5 id="轻量级锁的加锁过程"><a href="#轻量级锁的加锁过程" class="headerlink" title="轻量级锁的加锁过程"></a>轻量级锁的加锁过程</h5><p>在偏向锁加锁过程中，如果出现存在超过一个线程竞争某个对象时，会发生偏向锁的<strong>撤销</strong>操作。偏向锁撤销后，对象可能处于俩种状态：</p>
<ul>
<li>不可偏向的 无锁状态（检测到多线程竞争，升级到轻量级锁的机制）</li>
<li>不可偏向的 已锁状态（轻量级锁）</li>
</ul>
<p>出现上述俩种状态的原因是：</p>
<p>偏向锁<strong>不存在 解锁过程</strong>，只有<strong>撤销</strong>操作，触发<strong>撤销</strong>操作时：</p>
<ul>
<li>已经获取偏向锁的线程可能已经执行完了同步代码块，使得对象处于 “闲置状态”。原有偏向锁已经过期，此时该对象直接转换为 <strong>不可偏向的无锁状态</strong>。</li>
<li>已经获取偏向锁的线程未执行完同步代码块。偏向锁依旧有效，此时该对象直接转换为 <strong>不可偏向的已锁状态</strong>。</li>
</ul>
<p>偏向锁的加锁过程具体步骤如下：</p>
<ul>
<li><p>首先根据<strong>标志位</strong>判断出对象状态处于不可偏向的无锁状态。</p>
</li>
<li><p>在当前线程的<strong>栈桢</strong>（Stack Frame）中创建用于存储<strong>锁记录</strong>（lock record）的空间，并将对象头中的Mark Word复制到锁记录中，官方称为<strong>Displaced Mark Word</strong>。</p>
</li>
<li><p>拷贝成功后，虚拟机将使用<strong>CAS操作</strong>尝试将<strong>对象的Mark Word更新为指向Lock Record的指针</strong>，并将<strong>Lock record里的owner指针指向对象的 mark word</strong>（互相指向）。</p>
<img src="/2021/02/08/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/concurrent_04.png" alt="CAS操作" style="zoom:40%;">
</li>
<li><p>如果上述操作成功，则更新标志位 设置为“00”，代表该对象处于轻量级锁状态，如果失败，则膨胀为重量级锁。</p>
</li>
</ul>
<h5 id="重量级锁的加锁过程"><a href="#重量级锁的加锁过程" class="headerlink" title="重量级锁的加锁过程"></a>重量级锁的加锁过程</h5><p><strong>Synchronized</strong>是通过对象内部的一个叫做 <strong>监视器锁（Monitor）</strong>来实现的。但是监视器锁本质又是依赖于底层的操作系统的<strong>互斥量 Mutex Lock</strong>来实现的。而操作系统实现线程之间的切换这就需要从<strong>用户态转换到核心态</strong>，这个<strong>成本非常高</strong>，状态之间的转换需要相对比较长的时间，这就是为什么<strong>Synchronized</strong>效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为 “<strong>重量级锁</strong>”。</p>
<img src="/2021/02/08/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/concurrent_05.png" alt="多线程加锁过程" style="zoom:88%;">



<h5 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h5><p>当线程申请一个已经被其他线程占用的锁，就会出现两种情况。一种是没有获得锁的线程会阻塞自己，等到锁被释放后再被唤起，这就是互斥锁（开销大）；另一种是没有获得锁的线程一直循环在那里看是否该锁的保持者已经释放了锁，这就是自旋锁。</p>
<p><strong>重量级锁在相互竞争的时候，线程先会进入一个自旋</strong>。</p>
<p><strong>互斥同步进入阻塞状态的开销都很大，应该尽量避免。</strong>许多应用中，共享数据的锁定状态只会持续很短的一段时间。<strong>自旋锁的思想则是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果这段时间内能够获得锁，就可避免进入阻塞状态。</strong></p>
<p><strong>优点</strong>：自旋锁适合于共享数据的锁定状态很短的场景。</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>需要进行忙循环操作占用CPU时间，不适合锁定状态很长的场景。　　</li>
<li>递归死锁：试图递归地获得自旋锁必然会引起死锁：递归程序的持有实例在第二个实例循环，以试图获得相同自旋锁时，不会释放此自旋锁。</li>
</ol>
<h4 id="详解-volatile"><a href="#详解-volatile" class="headerlink" title="详解 volatile"></a>详解 volatile</h4><p>前面我们说到并发编程的三个特性：原子性、可见性、有序性：</p>
<ul>
<li>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li>
<li>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>
<li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li>
</ul>
<p><strong>Volatile</strong> 的作用：</p>
<ul>
<li><p>保证了不同线程对这个变量进行操作时的<strong>可见性</strong>，当一个线程修改了这个变量的值，<strong>volatile</strong> 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新（JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。）。</p>
</li>
<li><p>禁止进行指令重排序。</p>
<blockquote>
<p>观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。《深入理解Java虚拟机》</p>
</blockquote>
<p>lock前缀指令实际上相当于一个内存屏障（也称内存栅栏），内存屏障会提供3个功能：</p>
<ul>
<li><p>它确保指令重排序时<strong>不会把其后面的指令排到内存屏障之前的位置</strong>，<strong>也不会把前面的指令排到内存屏障的后面</strong>；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
</li>
<li><p>它会<strong>强制将对缓存的修改操作立即写入主存</strong>；</p>
</li>
<li><p>如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
</li>
</ul>
</li>
</ul>
<p>问题1：<strong>volatile</strong> 可以保证原子性吗？答：不能。</p>
<p>问题2：<strong>volatile</strong> 可以保证有序性吗？答：由于<strong>volatile</strong>，可以保证指令重排序，一定程度上可以，仅可保证 内存屏障 前面的指令不会排到其后面，内存屏障 后面的指令不会排到 其前面，至于其他的顺序不能保证。</p>
<h3 id="Java多线程机制"><a href="#Java多线程机制" class="headerlink" title="Java多线程机制"></a>Java多线程机制</h3><h4 id="ThreadLocal线程独享"><a href="#ThreadLocal线程独享" class="headerlink" title="ThreadLocal线程独享"></a>ThreadLocal线程独享</h4><p><strong>ThreadLocal</strong> 是一个将在多线程中为每一个线程创建单独的变量副本的类; 当使用<strong>ThreadLocal</strong>来维护变量时, <strong>ThreadLocal</strong> 会为每个线程创建单独的变量副本, <strong>避免因多线程操作共享变量而导致的数据不一致的情况</strong>;</p>
<p><strong>使用方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL = <span class="keyword">new</span> ThreadLocal&lt;String&gt;()&#123;</span><br><span class="line">        <span class="comment">// 这里可以直接初始化值，也可以在使用时用set方法赋值</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = THREAD_LOCAL.get();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Hello World！</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<p><strong>实现原理：</strong></p>
<p><strong>Thread</strong> 对象中存在一个 <strong>ThreadLocalMap</strong> 类型的变量 <strong>threadLocals</strong>  ,负责存储当前线程的私有变量。其结构类似于一个 <strong>Map</strong>（虽然并没有有实现Map接口），以上面代码为例，以当前静态变量 <strong>THREAD_LOCAL</strong> 为 <strong>key</strong>，</p>
<p>内容 <strong>String</strong> 对象为<strong>Value</strong>，线程第一次读取时如果不存在 则调用 <strong>ThreadLocal</strong> 的 <strong>initialValue</strong> 方法创建一个并返回。</p>
<p><strong>源码解析：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       <span class="comment">// 获取当前线程的 ThreadLocalMap对象</span></span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="comment">// 以当前 ThreadLocal 对象为key，T 为value 存储</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       T value = initialValue();</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>ThreadLocalMap</strong> 组成：</p>
<p><strong>ThreadLocalMap</strong> 是 <strong>ThreadLocal</strong> 的静态内部类，并没有实现 <strong>Map</strong> 接口，它由一个 <strong>Entry 数组</strong>来存储  Key，Value。<strong>Entry</strong>并不是链表形式, 而是每个<strong>bucket</strong>里面仅仅放一个<strong>Entry</strong>;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">//计算索引，上面已经有说过。</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/**根据获取到的索引进行循环，如果当前索引上的table[i]不为空，在没有return的情况下，</span></span><br><span class="line"><span class="comment">    * 就使用nextIndex()获取下一个（上面提到到线性探测法）。*/</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != <span class="keyword">null</span>;</span><br><span class="line">        e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">//table[i]上key不为空，并且和当前key相同，更新value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**table[i]上的key为空，说明被回收了</span></span><br><span class="line"><span class="comment">         * 说明改table[i]可以重新使用，用新的key-value将其替换,并删除其他无效的entry*/</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不存在也没有旧元素就创建一个</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();<span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面源码可知，<strong>ThreadLocalMap</strong> 在set 值时，如果遇到 hash冲突，解决方法是：这个时候将<strong>index</strong>加<strong>1</strong>，取<strong>table[index + 1]</strong>进行判断，这个时候如果还是冲突则会继续往下，直至最后一个还是冲突则会返回第一个比较，以此类推，直到可以插入。（开放定址法）</p>
<p>这里的 <strong>key.threadLocalHashCode &amp; (len-1)</strong>  ，实际相当于数组长度取模，数组长度 <strong>len</strong> 为 2^n，这在<strong>HashMap</strong>中 详解过原因。</p>
<p>综上所述，可以把<strong>table</strong>看成一个环形数组。</p>
<p>如果清理完无用条目(ThreadLocal被回收的条目)、并且<strong>数组中的数据大小 &gt; 阈值</strong>的时候对当前的<strong>Table</strong>进行重新哈希。</p>
<h4 id="Fork-join-大任务拆分"><a href="#Fork-join-大任务拆分" class="headerlink" title="Fork/join 大任务拆分"></a>Fork/join 大任务拆分</h4><p>现代的计算机已经向多CPU方向发展，即使是普通的PC，甚至现在的智能手机、多核处理器已被广泛应用。在未来，处理器的核心数将会发展的越来越多。</p>
<p>虽然硬件上的多核CPU已经十分成熟，但是很多应用程序并未这种多核CPU做好准备，因此并不能很好地利用多核CPU的性能优势。</p>
<p>为了<strong>充分利用多CPU、多核CPU的性能优势</strong>，软件系统应该可以充分“挖掘”每个CPU的计算能力，决不能让某个CPU处于“空闲”状态。为此，可以考虑把<strong>一个任务拆分成多个“小任务”,把多个”小任务”放到多个处理器核心上并行执行</strong>。当多个“小任务”执行完成之后，再将这些执行结果合并起来即可。</p>
<p><strong>Java</strong>提供了<strong>ForkJoinPool</strong>来支持将一个任务拆分成多个“小任务”并行计算，再把多个“小任务”的结果合成总的计算结果。</p>
<p><strong>ForkJoinPool</strong>是<strong>ExecutorService</strong>的实现类，因此是一种特殊的线程池。<strong>ForkJoinPool</strong>提供了如下两个常用的构造器。</p>
<ul>
<li><strong>public ForkJoinPool(int parallelism)</strong>：创建一个包含parallelism个并行线程的ForkJoinPool</li>
<li><strong>public ForkJoinPool()</strong> ：以Runtime.getRuntime().availableProcessors()的返回值作为parallelism来创建ForkJoinPool</li>
</ul>
<p>创建<strong>ForkJoinPool</strong>实例后，可以调用<strong>ForkJoinPool</strong>的<strong>submit(ForkJoinTask task)</strong>或者<strong>invoke(ForkJoinTask task)</strong>来执行指定任务。其中<strong>ForkJoinTask代表一个可以并行、合并的任务</strong>。</p>
<p><strong>ForkJoinTask</strong>是一个抽象类，它有两个抽象子类：<strong>RecursiveAction</strong>和<strong>RecursiveTask</strong></p>
<ul>
<li><strong>RecursiveTask</strong>代表有返回值的任务。</li>
<li><strong>RecursiveAction</strong>代表没有返回值的任务。</li>
</ul>
<p>这里以 <strong>RecursiveTask</strong> 为例，计算 100个 100以内的随机数的 加和；条件为 加数个数超过 最大个数 MAX（20）时，二分法 将任务 拆分，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 每个"小任务"最多只打印50个数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> arr[];</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        SumTask(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">            <span class="keyword">this</span>.arr = arr;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 当end-start的值小于MAX时候，开始打印</span></span><br><span class="line">            <span class="keyword">if</span> ((end - start) &lt; MAX) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                    sum += arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">"；计算范围是["</span> + start + <span class="string">" - "</span> + end + <span class="string">"]."</span>);</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将大任务分解成两个小任务</span></span><br><span class="line">                <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">                SumTask left = <span class="keyword">new</span> SumTask(arr, start, middle);</span><br><span class="line">                SumTask right = <span class="keyword">new</span> SumTask(arr, middle, end);</span><br><span class="line">                <span class="comment">// 并行执行两个小任务</span></span><br><span class="line">                left.fork();</span><br><span class="line">                right.fork();</span><br><span class="line">                <span class="comment">// 把两个小任务累加的结果合并起来</span></span><br><span class="line">                <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化100个数字元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = random.nextInt(<span class="number">100</span>);</span><br><span class="line">            <span class="comment">// 对数组元素赋值,并将数组元素的值添加到total总和中</span></span><br><span class="line">            total += (arr[i] = temp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"初始化时的总和="</span> + total);</span><br><span class="line">        <span class="comment">// 创建包含Runtime.getRuntime().availableProcessors()返回值作为个数的并行线程的ForkJoinPool</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">// 提交可分解的PrintTask任务</span></span><br><span class="line">        Future&lt;Integer&gt; future = forkJoinPool.submit(<span class="keyword">new</span> SumTask(arr, <span class="number">0</span>,</span><br><span class="line">                arr.length));</span><br><span class="line">        System.out.println(<span class="string">"计算出来的总和="</span> + future.get());</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">初始化时的总和=5363</span></span><br><span class="line"><span class="comment">当前线程：ForkJoinPool-1-worker-4；计算范围是[25 - 37].</span></span><br><span class="line"><span class="comment">当前线程：ForkJoinPool-1-worker-5；计算范围是[12 - 25].</span></span><br><span class="line"><span class="comment">当前线程：ForkJoinPool-1-worker-4；计算范围是[37 - 50].</span></span><br><span class="line"><span class="comment">当前线程：ForkJoinPool-1-worker-3；计算范围是[50 - 62].</span></span><br><span class="line"><span class="comment">当前线程：ForkJoinPool-1-worker-1；计算范围是[0 - 12].</span></span><br><span class="line"><span class="comment">当前线程：ForkJoinPool-1-worker-4；计算范围是[87 - 100].</span></span><br><span class="line"><span class="comment">当前线程：ForkJoinPool-1-worker-6；计算范围是[75 - 87].</span></span><br><span class="line"><span class="comment">当前线程：ForkJoinPool-1-worker-5；计算范围是[62 - 75].</span></span><br><span class="line"><span class="comment">计算出来的总和=5363</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<p>从输出结果可知，</p>
<ul>
<li>大任务被分成 8个 小任务，二分法 100 / 2^n , 此时 n = 4，此时每组 加数个数为 12个。</li>
<li>从输出可以看出 线程 被复用。</li>
</ul>
<h4 id="Interrupt-中断机制"><a href="#Interrupt-中断机制" class="headerlink" title="Interrupt 中断机制"></a>Interrupt 中断机制</h4><p>当我们点击某个按键来取消操作时，当我们在控制台敲入quit命令以结束某个后台服务时……都需要通过一个线程去取消另一个线程正在执行的任务。<strong>Java没有提供一种安全直接的方法来停止某个线程，但是Java提供了中断机制。</strong></p>
<p>如果对<strong>Java中断机制</strong>没有一个全面的了解，可能会误以为被中断的线程将立马退出运行，但事实并非如此。</p>
<p><strong>Java中断机制</strong>是一种协作机制，也就是说通过中断<strong>并不能直接终止另一个线程</strong>，而需要被中断的线程自己处理中断。每个线程对象里都有一个类似<strong>boolean</strong>类型的标识，代表着是否有中断请求（该请求可以来自所有线程，包括被中断的线程本身），当线程<strong>t1</strong>想中断线程<strong>t2</strong>，只需要在线程<strong>t1</strong>中将线程<strong>t2</strong>对象的中断标识置为<strong>true</strong>，然后线程<strong>t2</strong>可以选择在合适的时候处理该中断请求，甚至可以不理会该请求，就像这个线程没有被中断一样。</p>
<p><strong>java.lang.Thread</strong>类提供了几个方法来操作这个中断状态，这些方法包括：</p>
<ul>
<li>public static boolean <strong>interrupted()</strong><br>测试当前线程是否已经中断。线程的<em>中断状态</em> 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。</li>
<li>public boolean <strong>isInterrupted()</strong><br>测试线程是否已经中断。线程的<em>中断状态</em>不受该方法的影响。</li>
<li>public void <strong>interrupt()</strong><br>中断线程。改变状态位。</li>
</ul>
<p><strong>InterruptedException</strong> 异常：</p>
<p>抛<strong>InterruptedException</strong>的代表方法有：</p>
<ul>
<li><p><strong>java.lang.Object</strong> 类的 wait 方法</p>
</li>
<li><p><strong>java.lang.Thread</strong> 类的 sleep 方法</p>
</li>
<li><p><strong>java.lang.Thread</strong> 类的 join 方法</p>
</li>
</ul>
<p>因为上述方法是需要花时间的操作，会降低程序的响应性，所以可能会<strong>取消/中途放弃</strong>执行这个方法。</p>
<p>原理则是<strong>sleep</strong>、<strong>wait</strong>和<strong>join</strong>这些方法的内部会不断的检查中断状态的值，从而自己抛出<strong>InterruptEdException</strong>。</p>
<p>如果在线程进行其他处理时，调用了它的<strong>interrupt</strong>方法，线程也不会抛出<strong>InterruptedException</strong>的，只有当线程走到了<strong>sleep, wait, join</strong>这些方法的时候，才会抛出<strong>InterruptedException</strong>。若是没有调用<strong>sleep, wait, join</strong>这些方法，或者没有在线程里自己检查中断状态，自己抛出<strong>InterruptedException</strong>，那<strong>InterruptedException</strong>是不会抛出来的。</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2021/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>数据结构与算法</p>
<ul>
<li>数据结构：线性表、栈、队列</li>
<li>算法：基础概念（时间、空间复杂度）、常用算法优化思路</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>数据结构</strong>即数据的组织方式。</p>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p><strong>线性表</strong>是 <strong>n</strong> 个数据元素的有限序列，最常用的是链式表达，通常也叫作<strong>线性链表</strong>或者<strong>链表</strong>。链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现。在链表中存储的数据元素也叫作<strong>结点</strong>，一个结点存储的就是一条数据记录。</p>
<p>每个结点的结构包括两个部分：</p>
<ul>
<li><p>第一是具体的数据值；</p>
</li>
<li><p>第二是指向下一个结点的指针。</p>
</li>
</ul>
<p>在链表的最前面，通常会有个头指针用来指向第一个结点。</p>
<p>对于链表的最后一个结点，由于在它之后没有下一个结点，因此它的指针是个空指针。</p>
<ul>
<li><strong>单向链表</strong>：单向链表只能通过上一个结点的指针找到下一个结点，反过来则不行。</li>
<li><strong>循环链表</strong>：对于一个单向链表，让最后一个元素的指针指向第一个元素，就得到了循环链表。</li>
<li><strong>双向链表</strong>：对于一个单向链表，除了有指向下一个结点的指针以外，再增加一个指向上一个结点的指针。这样就得到了双向链表。</li>
<li><strong>双向循环链表</strong>：对双向链表和循环链表进行融合，就得到了双向循环链表。</li>
</ul>
<p><strong>线性表对于数据的增删查处理</strong></p>
<ul>
<li><strong>增</strong>：链表在执行数据新增的时候非常容易，只需要把待插入结点的指针指向原指针的目标，把原来的指针指向待插入的结点即可。</li>
<li><strong>删</strong>：如果待删除的结点为 b，那么只需要把指向 b 的指针 （p.next），指向 b 的指针指向的结点（p.next.next）即可。</li>
<li><strong>查找</strong>：<ul>
<li>第一种情况是按照<strong>位置序号</strong>查找：链表的查找功能是比较弱的，对于查找问题，唯一的办法就是一个一个地遍历去查找。</li>
<li>第二种情况是按照<strong>数据特性</strong>查找：遍历对比。</li>
</ul>
</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>链表的优点：链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，时间复杂度O(1)。所以添加，删除很快；</li>
<li>缺点：因为含有大量的指针域，占用空间较大；查找元素需要遍历链表来查找，非常耗时。</li>
<li>适用场景：数据量较小，需要频繁增加，删除操作的场景。</li>
</ul>
<p><strong>案例1：给定一个链表，输出翻转后的链表。例如，输入1 -&gt;2 -&gt; 3 -&gt; 4 -&gt;5，输出 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1。</strong></p>
<p>解法：构造三个指针 prev、curr 和 next，对当前结点、以及它之前和之后的结点进行缓存，再完成翻转动作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(curr)&#123;</span><br><span class="line">    next = curr.next;</span><br><span class="line">    curr.next = prev；</span><br><span class="line">    prev = curr;</span><br><span class="line">    curr = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例 2，给定一个奇数个元素的链表，查找出这个链表中间位置的结点的数值。</strong></p>
<p>解法1：暴力解法，先通过一次遍历去计算链表的长度，这样我们就知道了链表中间位置是第几个。接着再通过一次遍历去查找这个位置的数值。</p>
<p>解法2：利用快慢指针进行处理。其中快指针每次循环向后跳转两次，而慢指针每次向后跳转一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast &amp;&amp; fast.next &amp;&amp; fast.next.next)&#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例 3，判断链表是否有环。</strong></p>
<p>解法：利用快慢指针，假设链表有环，则快慢指针一定会相遇（即判断fast == slow即可）。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>栈</strong>是一种特殊的<strong>线性表</strong>。既然是线性表，那么它也包含了表头和表尾。不过在栈结构中，由于其操作的特殊性，会对表头和表尾的名字进行改造。</p>
<p>表尾用来输入数据，通常也叫作<strong>栈顶（top）</strong>；相应地，表头就是<strong>栈底（bottom）</strong>。栈顶和栈底是用来表示这个栈的两个指针。跟线性表一样，栈也有顺序表示和链式表示，分别称作<strong>顺序栈</strong>和<strong>链栈</strong>。栈顶允许操作，栈底不允许操作。</p>
<p>栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫<strong>入栈</strong>，取出元素叫<strong>出栈</strong>。</p>
<p><strong>顺序栈</strong></p>
<p>栈的顺序存储可以借助数组来实现。一般来说，会把数组的首元素存在栈底，最后一个元素放在栈顶。然后定义一个 top 指针来指示栈顶元素在数组中的位置。假设栈中只有一个数据元素，则 top = 0。一般以 top 是否为 -1 来判定是否为空栈。当定义了栈的最大容量为 <strong>StackSize</strong> 时，则栈顶 top 必须小于 <strong>StackSize</strong>。</p>
<p>当需要<strong>新增</strong>数据元素，即入栈操作时，就需要将新插入元素放在栈顶，并将栈顶指针增加 1。</p>
<p><strong>删除</strong>数据元素，即出栈操作，只需要 top - 1 就可以了。</p>
<p>对于<strong>查找</strong>操作，栈没有额外的改变，跟线性表一样，它也需要遍历整个栈来完成基于某些条件的数值查找。</p>
<p><strong>链栈</strong></p>
<p>关于链式栈，就是<strong>用链表的方式表示栈</strong>。通常，可以把栈顶放在单链表的头部，栈底是单链表的尾部。</p>
<p>链栈的后进先出，原来的头指针就显得毫无作用了。因此，对于链栈来说，是不需要头指针的。相反，它需要增加指向栈顶的 top 指针，这是压栈和出栈操作的重要支持。</p>
<p><strong>新增数据</strong>的压栈操作，需要让新的结点指向原栈顶，即 top 指针指向的对象，再让 top 指针指向新的结点。</p>
<p><strong>删除数据</strong>的出栈操作，需将栈顶的 top 指针指向栈顶元素的 next 指针即可完成删除。对于链式栈来说，新增删除数据元素没有任何循环操作，其时间复杂度均为 O(1)。</p>
<p><strong>查找操作</strong>，相对链表而言，链栈没有额外的改变，它也需要遍历整个栈来完成基于某些条件的数值查找。</p>
<p><strong>案例1：例 1，给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须与相同类型的右括号匹配，左括号必须以正确的顺序匹配。例如，{ [ ( ) ( ) ] } 是合法的，而 { ( [ ) ] } 是非法的。</strong></p>
<p>解法：匹配括号是否合法时，左括号是从左到右依次出现，而右括号则需要按照“后进先出”的顺序依次与左括号匹配。因此，实现方案就是通过栈的进出来完成。</p>
<p><strong>案例2：浏览器的页面访问都包含了后退和前进功能，利用栈如何实现？</strong></p>
<p>解法：为了支持前进、后退的功能，利用栈来记录用户历史访问网页的顺序信息是一个不错的选择。此时需要维护两个栈，分别用来支持后退和前进。当用户访问了一个新的页面，则对后退栈进行压栈操作。当用户后退了一个页面，则后退栈进行出栈，同时前进栈执行压栈。当用户前进了一个页面，则前进栈出栈，同时后退栈压栈。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>与栈相似，队列也是一种特殊的<strong>线性表</strong>，与线性表的不同之处也是体现在对数据的增和删的操作上。栈的特点是先进后出，而队列的特点是<strong>先进先出</strong>。</p>
<p>与栈一样，队列也存在这两种存储方式，即<strong>顺序队列</strong>和<strong>链式队列</strong>。</p>
<p><strong>顺序队列</strong>，依赖数组来实现，其中的数据在内存中也是顺序存储。</p>
<p>而<strong>链式队列</strong>，则依赖链表来实现，其中的数据依赖每个结点的指针互联，在内存中并不是顺序存储。链式队列，实际上就是只能<strong>尾进头出的线性表的单链表</strong>。</p>
<p><strong>顺序队列</strong></p>
<p>队列从队头（front）删除元素，从队尾（rear）插入元素。对于一个<strong>顺序队列的数组</strong>来说，会设置一个 front 指针来指向队头，并设置另一个 rear 指针指向队尾。当我们不断进行<strong>插入删除操作</strong>时，头尾两个指针都会不断向后移动。因为数组长度限制，不断插入数据后队尾指针会出现<strong>数组越界</strong>的问题。</p>
<p>两个简单粗暴的解决方法就是：</p>
<ul>
<li>删除元素时，不惜消耗 O(n) 的时间复杂度去移动数据；</li>
<li>开辟足够大的内存空间确保数组不会越界。</li>
</ul>
<p><strong>循环队列</strong></p>
<p>数组越界问题可以通过队列的一个特殊变种来解决，叫作循环队列。</p>
<p>循环队列进行<strong>新增数据元素操作时</strong>，首先判断队列是否为满。如果不满，则可以将新元素赋值给队尾，然后让 rear 指针向后移动一个位置。如果已经排到队列最后的位置，则 rear指针<strong>重新指向头部</strong>。</p>
<p>同样的<strong>删除数据元素操作时</strong>，需要判断队列是否为空，然后将队头元素赋值给返回值，front 指针向后移一个位置。如果已经排到队列最后的位置，就把 front 指针<strong>重新指向到头部</strong>。</p>
<p>这样就能在不开辟大量存储空间的前提下，不采用 O(n) 的操作，也能通过移动数据来完成频繁的新增和删除数据。</p>
<p>当队列为空时，有 front 指针和 rear 指针相等，当队列是满的时候，同样有 front 指针和 rear 指针相等，这时就需要，设置一个标志变量 flag 来区别队列是空还是满。</p>
<p><strong>链式队列</strong></p>
<p>链式队列就是一个单链表，同时增加了 front 指针和 rear 指针。链式队列和单链表一样，通常会增加一个<strong>头结点</strong>，并另 front 指针指向头结点。<strong>头结点不存储数据，只是用来辅助标识</strong>。</p>
<p>链式队列进行<strong>新增数据操作时</strong>，将拥有数值 X 的新结点 s 赋值给原队尾结点的后继，即 rear.next。然后把当前的 s 设置为队尾结点，指针 rear 指向 s。</p>
<p>当链式队列进行<strong>删除数据操作时</strong>，实际删除的是头结点的后继结点。这是因为头结点仅仅用来标识队列，并不存储数据。因此，出队列的操作，就需要找到头结点的后继，这就是要删除的结点。接着，让头结点指向要删除结点的后继。</p>
<p>对于队列的<strong>查找操作</strong>，不管是顺序还是链式，队列都没有额外的改变。跟线性表一样，它也需要遍历整个队列来完成基于某些条件的数值查找。因此时间复杂度也是 <strong>O(n)</strong>。</p>
<p><strong>案例1：约瑟夫环问题：已知 n 个人（以编号 1，2，3…n 分别表示）围坐在一张圆桌周围。从编号为 k 的人开始报数，数到 m 的那个人出列；他的下一个人又从 1 开始报数，数到 m 的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。输出 n 个人出列的顺序。</strong></p>
<p>解法：先把所有人都放入循环队列中。注意这个循环队列的长度要大于或者等于 n。从第一个人开始依次出队列，出队列一次则计数变量 i 自增。如果 i 比 m 小，则<strong>还需要再入队列</strong>。直到i等于 m 的人出队列时，就不用再让这个人进队列了。而是<strong>放入一个用来记录出队列顺序的数组中</strong>。直到数完 n 个人为止。当队列为空时，则表示队列中的 n 个人都出队列了。这时结束队列循环，输出数组内记录的元素。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h3><p><strong>数组</strong>是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问。</p>
<p><strong>优点</strong>：</p>
<ul>
<li><p>按照索引查询元素速度快</p>
</li>
<li><p>按照索引遍历数组方便</p>
</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><p>数组的大小固定后就无法扩容了</p>
</li>
<li><p>数组只能存储一种类型的数据3、添加，删除的操作慢，因为要移动其他的元素。</p>
</li>
</ul>
<p><strong>增加</strong>：若插入数据在最后，则时间复杂度为 O(1)；如果中间某处插入数据，则时间复杂度为 O(n)。</p>
<p><strong>删除</strong>：对应位置的删除，扫描全数组，时间复杂度为 O(n)。</p>
<p><strong>查找</strong>：如果只需根据索引值进行一次查找，时间复杂度是 O(1)。但是要在数组中查找一个数值满足指定条件的数据，则时间复杂度是 O(n)。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>字符串（string）</strong> 是由 n 个字符组成的一个有序整体（ n &gt;= 0 ）。</p>
<p>字符串的逻辑结构和线性表很相似，不同之处在于字符串针对的是字符集，也就是字符串中的元素都是字符，线性表则没有这些限制。</p>
<p><strong>空串</strong>，指含有零个字符的串。例如，s = “”，书面中也可以直接用 Ø 表示。</p>
<p><strong>空格串</strong>，只包含空格的串。它和空串是不一样的，空格串中是有内容的，只不过包含的是空格，且空格串中可以包含多个空格。例如，s = “  “，就是包含了 3 个空格的字符串。</p>
<p><strong>子串</strong>，串中任意连续字符组成的字符串叫作该串的子串。</p>
<p><strong>原串</strong>通常也称为<strong>主串</strong>。例如：a = “BEI”，b = “BEIJING”，c = “BJINGEI” 。对于字符串 a 和 b 来说，由于 b 中含有字符串 a ，所以可以称 a 是 b 的子串，b 是 a 的主串；</p>
<p><strong>子串查找（字符串匹配）</strong></p>
<p>我们把主串的长度记为 n，子串长度记为 m。</p>
<p>在主串中查找子串，因此，主串的长度肯定比子串长，n&gt;m。因此，字符串匹配算法的时间复杂度就是 n 和 m 的函数。</p>
<p>假设要从主串 s = “goodgoogle” 中找到 t = “google” 子串。思考逻辑为：</p>
<ul>
<li>需要从主串中找到跟子串的第 1 个字符相等的位置</li>
<li>然后再去匹配后续字符是否与子串相等</li>
</ul>
<p>从实现的角度来看，需要两层的循环，这种匹配算法的时间复杂度为 O(nm)。</p>
<p><strong>案例：查找出两个字符串的最大公共字串</strong></p>
<p>解法：假设字符串 a 的长度为 n，字符串 b 的长度为 m，可见时间复杂度是 n 和 m 的函数。首先，你需要对于字符串 a 和 b 找到第一个共同出现的字符，这就是 O(nm)。旦找到了共同出现的字符之后，还需要再继续查找共同出现的字符串，这也就是又嵌套了一层循环。可见最终的时间复杂度是 O(nmm)，即 O(nm²)。</p>
<h3 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h3><p><strong>树</strong>是由结点和边组成的，不存在环的一种数据结构。</p>
<p><img src="/2021/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/algorithm_01.png" alt="树结构"></p>
<p>树满足<strong>递归</strong>定义的特性。也就是说，如果一个数据结构是树结构，那么剔除掉根结点后，得到的若干个子结构也是树，通常称作<strong>子树</strong>。</p>
<p>在一棵树中，根据结点之间层次关系的不同，对结点的称呼也有所不同。</p>
<img src="/2021/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/algorithm_02.png" alt="树节点层次关系" style="zoom:45%;">



<p>例如：A 结点是 B 结点和 C 结点的上级，则 A 就是 B 和 C 的<strong>父结点</strong>，B 和 C 是 A 的<strong>子结点</strong>。B 和 C 同时是 A 的“孩子”，则可以称 B 和 C 互为<strong>兄弟结点</strong>。A 没有父结点，则可以称 A 为<strong>根结点</strong>。G、H、I、F 结点都没有子结点，则称 G、H、I、F 为<strong>叶子结点</strong>。</p>
<p>当有了一棵树之后，还需要用<strong>深度、层</strong>来描述这棵树中结点的位置。结点的层次从根结点算起，根为第一层，根的“孩子”为第二层，根的“孩子”的“孩子”为第三层，依此类推。<strong>树中结点的最大层次数，就是这棵树的树深</strong>（称为深度，也称为高度）。</p>
<p><strong>二叉树</strong></p>
<p>在树的大家族中，有一种被高频使用的特殊树，它就是<strong>二叉树</strong>。在二叉树中，<strong>每个结点最多有两个分支</strong>，即每个结点最多有两个子结点，分别称作<strong>左子结点和右子结点</strong>。</p>
<p>在二叉树中，有下面两个特殊的类型：</p>
<ul>
<li><p><strong>满二叉树</strong>：定义为除了叶子结点外，所有结点都有 2 个子结点。</p>
<img src="/2021/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/algorithm_03.png" alt="满二叉树" style="zoom:43%;">
</li>
<li><p><strong>完全二叉树</strong>：定义为<strong>除了最后一层</strong>以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列。</p>
<img src="/2021/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/algorithm_04.png" alt="完全二叉树" style="zoom:34%;">

</li>
</ul>
<p>完全二叉树看上去并不完全，为什么叫完全二叉树？</p>
<p>这其实和二叉树的<strong>存储</strong>有关系。存储二叉树有两种办法，一种是基于指针的<strong>链式存储法</strong>，另一种是<strong>基于数组的顺序存储法</strong>。</p>
<p><strong>链式存储法</strong>，也就是像链表一样，每个结点有三个字段，一个存储数据，另外两个分别存放指向左右子结点的指针。</p>
<img src="/2021/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/algorithm_05.png" alt="链式存储法" style="zoom:40%;">

<p><strong>顺序存储法</strong>，就是按照规律把结点存放在数组里。</p>
<img src="/2021/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/algorithm_06.png" alt="顺序存储法" style="zoom:35%;">

<p>之所以称为完全二叉树，是从<strong>存储空间利用效率</strong>的视角来看的。对于一棵完全二叉树而言，仅仅浪费了下标为 0 的存储位置。而如果是一棵非完全二叉树，则会浪费大量的存储空间。</p>
<p><strong>树的遍历</strong></p>
<ul>
<li><strong>前序遍历</strong>，对树中的任意结点来说，先打印这个结点，然后前序遍历它的左子树，最后前序遍历它的右子树</li>
<li><strong>中序遍历</strong>，对树中的任意结点来说，先中序遍历它的左子树，然后打印这个结点，最后中序遍历它的右子树</li>
<li><strong>后序遍历</strong>，对树中的任意结点来说，先后序遍历它的左子树，然后后序遍历它的右子树，最后打印它本身。</li>
</ul>
<p><img src="/2021/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/algorithm_07.png" alt="树的遍历"></p>
<p>对于没有任何特殊性质的二叉树而言，抛开遍历的时间复杂度以外，真正执行<strong>增加和删除操作的时间复杂度是 O(1)</strong>。树数据的<strong>查找</strong>操作和链表一样，都需要遍历每一个数据去判断，所以<strong>时间复杂度是 O(n)</strong>。</p>
<p>但当二叉树具备一些特性的时候，则可以利用这些特性实现时间复杂度的降低。</p>
<p><strong>特性</strong></p>
<p>在二叉查找树中的任意一个结点，其左子树中的每个结点的值，都要小于这个结点的值。</p>
<p>在二叉查找树中的任意一个结点，其右子树中每个结点的值，都要大于这个结点的值。</p>
<p>在二叉查找树中，会尽可能规避两个结点数值相等的情况。</p>
<p>对二叉查找树进行<strong>中序遍历</strong>，就可以<strong>输出一个从小到大的有序数据队列</strong>。</p>
<p><strong>二叉查找树的查找操作</strong></p>
<p>在利用二叉查找树执行查找操作时，我们可以进行以下判断：</p>
<ul>
<li>首先判断根结点是否等于要查找的数据，如果是就返回。</li>
<li>如果根结点大于要查找的数据，就在左子树中递归执行查找动作，直到叶子结点。</li>
<li>如果根结点小于要查找的数据，就在右子树中递归执行查找动作，直到叶子结点。这样的“二分查找”所消耗的时间复杂度就可以降低为 O(logn)。</li>
</ul>
<p><strong>二叉查找树的插入操作</strong></p>
<p>从根结点开始，如果要插入的数据比根结点的数据大，且根结点的右子结点不为空，则在根结点的右子树中继续尝试执行插入操作。直到找到为空的子结点执行插入动作。</p>
<p>二叉查找树插入数据的时间复杂度是 O(logn)。这里的时间复杂度更多是消耗在了遍历数据去找到查找位置上，真正执行插入动作的时间复杂度仍然是 O(1)。</p>
<p><strong>二叉查找树的删除操作</strong></p>
<p>二叉查找树的删除操作会比较复杂，这是因为删除完某个结点后的树，仍然要满足二叉查找树的性质。我们分为下面三种情况：</p>
<ul>
<li>如果要删除的结点是某个叶子结点，则直接删除，将其父结点指针指向 null 即可。</li>
<li>如果要删除的结点只有一个子结点，只需要将其父结点指向的子结点的指针换成其子结点的指针即可。</li>
<li>如果要删除的结点有两个子结点，则有两种可行的操作方式。<ul>
<li>找到这个结点的左子树中最大的结点，替换要删除的结点。</li>
<li>找到这个结点的右子树中最小的结点，替换要删除的结点。</li>
</ul>
</li>
</ul>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表也叫作<strong>散列表</strong>。</p>
<p>之前学过的数据结构里，数据的存储位置和数据的具体数值之间不存在任何关系。因此，在面对查找问题时，这些数据结构必须采取逐一比较的方法去实现。</p>
<p>而哈希表的设计采用了函数映射的思想，将记录的存储位置与记录的关键字关联起来。这样的设计方式，能够快速定位到想要查找的记录，而且不需要与表中存在的记录的关键字比较后再来进行查找。（即不需要遍历）</p>
<p><strong>如果有一种方法，可以实现“地址 = f (关键字)”的映射关系，那么就可以快速完成基于数据的数值的查找了。这就是哈希表的核心思想。</strong></p>
<p><strong>哈希函数常用设计方式：</strong></p>
<ul>
<li>线性函数：H (key) = a*x + b。</li>
<li>数字分析法：关键字 key 都是由 s 位数字组成，从中提取分布均匀的若干位组成哈希地址。</li>
<li>平方取中法：关键字的每一位都有某些数字重复出现，并且频率很高，我们就可以先求关键字的平方值，通过平方扩大差异，然后取中间几位作为最终存储地址。</li>
<li>折叠法：关键字的位数很多，可以将关键字分割为几个等长的部分，取它们的叠加和的值（舍去进位）作为哈希地址。</li>
<li>取模法。</li>
</ul>
<p><strong>哈希冲突常用解决方法：</strong></p>
<ul>
<li>开放定址法：当一个关键字和另一个关键字发生冲突时，使用某种探测技术在哈希表中形成一个探测序列（常用<strong>线性探测</strong>），然后沿着这个探测序列依次查找下去。当碰到一个空的单元时，则插入其中。</li>
<li>链地址法：将哈希地址相同的记录存储在一张线性链表中。</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a><strong>复杂度</strong></h4><p><strong>复杂度</strong>是衡量代码运行效率的重要的度量因素。</p>
<ul>
<li><strong>复杂度是一个关于输入数据量 n 的函数</strong>：例如 O(n) 和 O(2n) 表示的是同样的复杂度</li>
<li><strong>多项式级的复杂度相加的时候，选择高者作为结果</strong>：例如 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度。</li>
<li><strong>O(1) 也是表示一个特殊复杂度</strong></li>
</ul>
<p>假设你的代码复杂度是 <strong>f(n)</strong>，那么就用个大写字母 <strong>O</strong> 和括号，把 <strong>f(n)</strong> 括起来就可以了，即 <strong>O(f(n))</strong>。</p>
<p><strong>分类</strong></p>
<ul>
<li><strong>时间复杂度</strong>：代码执行过程中消耗的计算时间；常用的降低时间复杂度的方法有<strong>递归、二分法、排序算法、动态规划</strong>等</li>
<li><strong>空间复杂度</strong>：代码执行过程中消耗的计算空间；而降低空间复杂度的核心思路就是，<strong>用低复杂度的数据结代替高复杂度的数据结构</strong></li>
</ul>
<h4 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h4><p>降低复杂度的方法的三个步骤：</p>
<ul>
<li>第一步，<strong>暴力解法</strong>。在没有任何时间、空间约束下，完成代码任务的开发。</li>
<li>第二步，<strong>无效操作处理</strong>。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。</li>
<li>第三步，<strong>时空转换</strong>。设计合理数据结构，完成时间复杂度向空间复杂度的转移。</li>
</ul>
<p>掌握数据处理基本操作：<strong>增、删、查</strong></p>
<p>常用的分析方法的三个步骤：</p>
<ul>
<li>首先，这段代码对数据进行了哪些操作？（转换为<strong>增、删、查</strong>）</li>
<li>其次，这些操作中，哪个操作最影响效率，对时间复杂度的损耗最大？</li>
<li>最后，哪种数据结构最能帮助你提高数据操作的使用效率？</li>
</ul>
<p><strong>查找：</strong></p>
<ul>
<li>根据元素的<strong>位置或索引</strong>来查找。</li>
<li>根据元素的<strong>数值特征</strong>来查找。</li>
</ul>
<p><strong>增、删</strong>：</p>
<ul>
<li>在数据结构<strong>最后</strong>的增、删。</li>
<li>在数据结构<strong>中间</strong>的增、删。</li>
</ul>
<h3 id="算法思维"><a href="#算法思维" class="headerlink" title="算法思维"></a>算法思维</h3><p>不管是数据结构还是算法思维，它们的目标都是<strong>降低时间复杂度</strong>。<strong>数据结构是从数据组织形式的角度达成这个目标，而算法思维则是从数据处理的思路上去达成这个目标。</strong></p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>在数学与计算机科学中，递归 （Recursion)）是指在函数的定义中使用函数自身的方法，直观上来看，就是某个函数自己调用自己。</p>
<ul>
<li>递归<strong>问题必须可以分解为若干个规模较小、与原问题形式相同的子问题</strong>。并且这些子问题可以用完全相同的解题思路来解决；</li>
<li>递归问题的演化过程是一个对原问题<strong>从大到小进行拆解的过程，并且会有一个明确的终点（临界点）</strong>。一旦原问题到达了这个临界点，就不用再往更小的问题上拆解了。</li>
</ul>
<p>总结起来，<strong>递归的实现包含了两个部分，一个是递归主体，另一个是终止条件</strong>。</p>
<p><strong>算法思想</strong></p>
<p>递归的数学模型其实就是<strong>数学归纳法</strong>（证明当 n = 1 时命题成立；假设 n = m 时命题成立，那么尝试推导出在 n = m + 1 时命题也成立）。</p>
<p><strong>递归分析的俩个步骤：</strong></p>
<ul>
<li>当你面对一个大规模问题时，如何把它分解为几个小规模的同样的问题；</li>
<li>当你把问题通过多轮分解后，最终的结果，也就是终止条件如何定义。</li>
</ul>
<p>所以<strong>当一个问题同时满足以下 2 个条件时，就可以使用递归的方法求解</strong>。</p>
<p><strong>例1</strong>：树结构的中序遍历。</p>
<ol>
<li>对树中的任意结点来说，先中序遍历它的左子树，然后打印这个结点，最后中序遍历它的右子树。（<strong>递归主体</strong>）</li>
<li>当某个结点没有左子树和右子树时，则直接打印结点，完成终止。（<strong>终止条件</strong>）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrderTraverse(node.left);</span><br><span class="line">    System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">    inOrderTraverse(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例2：</strong>汉诺塔问题。从左到右有 x、y、z 三根柱子，其中 x 柱子上面有从小叠到大的 n 个圆盘。现要求将 x 柱子上的圆盘移到 z 柱子上去。要求是，每次只能移动一个盘子，且大盘子不能被放在小盘子上面。求移动步骤。</p>
<p>步骤拆解：</p>
<ol>
<li>把从小到大的 n-1 个盘子，从 x 移动到 y；</li>
<li>接着把最大的一个盘子，从 x 移动到 z；（移动步骤）</li>
<li>再把从小到大的 n-1 个盘子，从 y 移动到 z。</li>
</ol>
<p>终止条件为 n = 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String x = <span class="string">"x"</span>;</span><br><span class="line">    String y = <span class="string">"y"</span>;</span><br><span class="line">    String z = <span class="string">"z"</span>;</span><br><span class="line">    hanio(<span class="number">4</span>,x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanio</span><span class="params">(<span class="keyword">int</span> n,String x,String y,String z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"汉诺塔的层数不能小于1"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"移动: "</span> + x + <span class="string">" -&gt; "</span> + z);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hanio(n - <span class="number">1</span>, x, z, y);</span><br><span class="line">        System.out.println(<span class="string">"移动: "</span> + x + <span class="string">" -&gt; "</span> + z);</span><br><span class="line">        hanio(n - <span class="number">1</span>, y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">移动: x -&gt; z</span><br><span class="line">移动: x -&gt; y</span><br><span class="line">移动: z -&gt; y</span><br><span class="line">移动: x -&gt; z</span><br><span class="line">移动: y -&gt; x</span><br><span class="line">移动: y -&gt; z</span><br><span class="line">移动: x -&gt; z</span><br></pre></td></tr></table></figure>

<p><strong>例3：</strong>斐波那契数列是：0，1，1，2，3，5，8，13，21，34，55，89，144……。你会发现，这个数列中元素的性质是，某个数等于它前面两个数的和；也就是 a[n+2] = a[n+1] + a[n]。至于起始两个元素，则分别为 0 和 1。在这个数列中的数字，就被称为斐波那契数。</p>
<p>现在的问题是，写一个函数，输入 x，输出斐波那契数列中第 x 位的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 斐波那契数列是：0，1，1，2，3，5，8，13，21，34，55，89，144……。</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"斐波那契第"</span> + x + <span class="string">"个数是:"</span> + fbonq(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fbonq</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fbonq(x - <span class="number">1</span>) + fbonq(x - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><p>从定性的角度来看，分治法的<strong>核心思想就是“分而治之”</strong>。利用分而治之的思想，<strong>就可以把一个大规模、高难度的问题，分解为若干个小规模、低难度的小问题。随后，开发者将面对多个简单的问题，并很快地找到答案各个击破。在把这些简单问题解决好之后，我们通过把这些小问题的答案合并，就得到了原问题的答案。</strong></p>
<p>分治法的前提条件：</p>
<ul>
<li><strong>难度在降低</strong>，即原问题的解决难度，随着数据的规模的缩小而降低。这个特征绝大多数问题都是满足的。</li>
<li><strong>问题可分</strong>，原问题可以分解为若干个规模较小的同类型问题。这是应用分治法的前提。</li>
<li><strong>解可合并</strong>，利用所有子问题的解，可合并出原问题的解。这个特征很关键，能否利用分治法完全取决于这个特征。</li>
<li><strong>相互独立</strong>，各个子问题之间相互独立，某个子问题的求解不会影响到另一个子问题。</li>
</ul>
<p>与递归的区别：</p>
<p>分治法需要递归地分解问题，再去解决问题。因此，<strong>分治法在每轮递归上，都包含了分解问题、解决问题和合并结果这 3 个步骤。</strong></p>
<p>典型就是 <strong>二分查找</strong></p>
<p>例如：<strong>有序数组{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } 中，查找 8 是否出现过。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要查找的数字</span></span><br><span class="line">    <span class="keyword">int</span> targetNumb = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 目标有序数组</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> isfind = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        middle = (high + low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[middle] == targetNumb) &#123;</span><br><span class="line">            System.out.println(targetNumb + <span class="string">" 在数组中,下标值为: "</span> + middle);</span><br><span class="line">			isfind = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[middle] &gt; targetNumb) &#123;</span><br><span class="line">            <span class="comment">// 说明该数在low~middle之间</span></span><br><span class="line">            high = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 说明该数在middle~high之间</span></span><br><span class="line">            low = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (isfind == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"数组不含 "</span> + targetNumb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>二分查找的时间复杂度是 O(logn)，这也是分治法普遍具备的特性。</strong>当你面对某个代码题，而且约束了时间复杂度是 <strong>O(logn) 或者是 O(nlogn)</strong> 时，可以想一下分治法是否可行。</li>
<li><strong>二分查找的循环次数并不确定。一般是达到某个条件就跳出循环。</strong>因此，编码的时候，多数会采用 <strong>while 循环加 break</strong> 跳出的代码结构。</li>
<li><strong>二分查找处理的原问题必须是有序的。</strong>因此，当你在一个<strong>有序数据环境中</strong>处理问题时，可以考虑分治法。相反，如果原问题中的数据并不是有序的，则使用分治法的可能性就会很低了。</li>
</ul>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p><strong>排序，就是让一组无序数据变成有序的过程。</strong> 一般默认这里的有序都是从小到大的排列顺序。</p>
<p><strong>冒泡排序</strong></p>
<p><strong>从第一个数据开始，依次比较相邻元素的大小。如果前者大于后者，则进行交换操作，把大的元素往后交换。通过多轮迭代，直到没有交换操作为止。</strong></p>
<ul>
<li><p>时间复杂度：O(n) ~ O(n*n)</p>
</li>
<li><p>空间复杂度：O(1) </p>
</li>
<li><p>冒泡排序过程中，当元素相同时不做交换，所以冒泡排序是稳定的排序算法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, -<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    System.out.println(<span class="string">"原始数据: "</span> + Arrays.toString(arr));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"冒泡排序: "</span> + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>插入排序</strong></p>
<p><strong>选取未排序的元素，插入到已排序区间的合适位置，直到未排序区间为空</strong>。</p>
<ul>
<li>时间复杂度：O(n) ~ O(n*n)</li>
<li>空间复杂度：O(1)</li>
<li>插入排序是稳定的排序算法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">6</span>, <span class="number">78</span>, <span class="number">34</span> &#125;;</span><br><span class="line">    System.out.println(<span class="string">"原始数据: "</span> + Arrays.toString(arr));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; temp) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"插入排序: "</span> + Arrays.toString(arr));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>归并排序</strong></p>
<p><strong>归并排序的原理其实就是我们上一课时讲的分治法</strong>。它首先将数组不断地二分，直到最后每个部分只包含 1 个数据。然后再对每个部分分别进行排序，最后将排序好的相邻的两部分合并在一起，这样整个数组就有序了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    System.out.println(<span class="string">"原始数据: "</span> + Arrays.toString(arr));</span><br><span class="line">    customMergeSort(arr, tmp, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"归并排序: "</span> + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">customMergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] tmp, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 对左侧子序列进行递归排序</span></span><br><span class="line">        customMergeSort(a, tmp, start, mid);</span><br><span class="line">        <span class="comment">// 对右侧子序列进行递归排序</span></span><br><span class="line">        customMergeSort(a, tmp, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        customDoubleMerge(a, tmp, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">customDoubleMerge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] tmp, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1 = left, p2 = mid + <span class="number">1</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[p1] &lt;= a[p2])</span><br><span class="line">            tmp[k++] = a[p1++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[k++] = a[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid)</span><br><span class="line">        tmp[k++] = a[p1++];</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= right)</span><br><span class="line">        tmp[k++] = a[p2++];</span><br><span class="line">    <span class="comment">// 复制回原素组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">        a[i] = tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(n)  需要开辟临时空间</li>
<li>相同元素前后顺序不变，是稳定的排序算法</li>
</ul>
<p><strong>快速排序</strong></p>
<p><strong>快速排序法的原理也是分治法</strong>。它的每轮迭代，会选取数组中任意一个数据作为分区点，将小于它的元素放在它的左侧，大于它的放在它的右侧。再利用分治思想，继续分别对左右两侧进行同样的操作，直至每个区间缩小为 1，则完成排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"原始数据: "</span> + Arrays.toString(arr));</span><br><span class="line">        customQuickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"快速排序: "</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">customQuickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, temp, t;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = low;</span><br><span class="line">        j = high;</span><br><span class="line">        temp = arr[low];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// 先看右边，依次往左递减</span></span><br><span class="line">            <span class="keyword">while</span> (temp &lt;= arr[j] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再看左边，依次往右递增</span></span><br><span class="line">            <span class="keyword">while</span> (temp &gt;= arr[i] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            t = arr[j];</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">            arr[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        <span class="comment">// 递归调用左半数组</span></span><br><span class="line">        customQuickSort(arr, low, j - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归调用右半数组</span></span><br><span class="line">        customQuickSort(arr, j + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlogn) ~ O(n*n)</li>
<li>空间复杂度：O(1)</li>
<li>快速排序的分区过程涉及交换操作，所以<strong>快排是不稳定的排序算法</strong>。</li>
</ul>
<p><strong>总结：</strong></p>
<p>于 n 个元素的数组，只要重复执行 n 次最大值的查找就能完成排序。</p>
<p>因此<strong>排序最暴力的方法，时间复杂度是 O(n*n)。这恰如冒泡排序和插入排序</strong>。</p>
<p><strong>当我们利用算法思维去解决问题时，就会想到尝试分治法。此时，利用归并排序就能让时间复杂度降低到 O(nlogn)</strong>。然而，<strong>归并排序需要额外开辟临时空间。一方面是为了保证稳定性，另一方面则是在归并时，由于在数组中插入元素导致了数据挪移的问题。</strong></p>
<p><strong>为了规避因此而带来的时间损耗，此时我们采用快速排序</strong>。通过交换操作，可以解决插入元素导致的数据挪移问题，而且降低了不必要的空间开销。但是由于其动态二分的交换数据，导致了由此得出的<strong>排序结果并不稳定</strong>。</p>
<ul>
<li><strong>如果对数据规模比较小的数据进行排序，可以选择时间复杂度为 O(n*n) 的排序算法</strong>。因为当数据规模小的时候，时间复杂度 O(nlogn) 和 O(n*n) 的区别很小。</li>
<li><strong>但对数据规模比较大的数据进行排序，就需要选择时间复杂度为 O(nlogn) 的排序算法了</strong>。</li>
</ul>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p><strong>分治法的使用必须满足 4 个条件：</strong></p>
<ul>
<li>问题的解决难度与数据规模有关；</li>
<li>原问题可被分解；</li>
<li>子问题的解可以合并为原问题的解；</li>
<li>所有的子问题相互独立。</li>
</ul>
<p>动态规划满足前三个，不满足第四个。</p>
<p><strong>动态规划是一种运筹学方法，是在多轮决策过程中的最优方法</strong>。多轮决策的每一轮都可以看作是一个子问题。<strong>从分治法的视角来看，每个子问题必须相互独立。但在多轮决策中，这个假设显然不成立。这也是动态规划方法产生的原因之一</strong>。</p>
<p>特点：每一轮都需要做不同的决策，而每次的决策又依赖上一轮决策的结果。</p>
<p><strong>动态规划问题没有标准化的解题方法，但它有一些宏观层面通用的方法论</strong></p>
<p>（有点复杂，暂时不能理解，后续弄懂后再补充）</p>
<h4 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h4><p>回溯法非常<strong>适合解决由多个步骤组成，并且每个步骤都有多个选项的问题</strong>。 当我们在某一步选择了其中一个选项后，就进入下一步，然后又面临新的选项。就这样重复选择，直至最终的状态。</p>
<p>可以用树结构（解空间树）来表示用回溯法解决的问题的所有选项。在某一步有 n  个可能的选项，那么该步骤就可以看成是树结构中的一个节点，每个选项看成树中节点的连接线，经过这些连接线到达该节点的 n 个子节点。<strong>叶节点则对应着最终的状态</strong>：</p>
<ul>
<li><p>如果在叶节点的状态满足题目的约束条件，那我们就找到了一个问题的解；</p>
</li>
<li><p>如果在叶节点的状态不满足约束条件，那就回溯到它的上一个节点尝试其它的选项；</p>
</li>
<li><p>如果上一个节点所有可能的选项都已经试过，则再回溯到它的上一个节点，直至所有节点的所有选项都尝试过；</p>
</li>
<li><p>如果所有节点的所有选项都已经尝试过却没有找到满足约束条件的最终状态，说明该问题无解。</p>
</li>
</ul>
<p>所以，用回溯法求解问题的过程，就是搜索整个解空间树的过程。当搜索至任一节点时，先判断该节点是否包含问题的解，如果不包含，则跳过该节点的子节点的搜索，避免无效搜索，这个过程叫作 “<strong>剪枝</strong>”。</p>
<p><strong>示例</strong>：数组 [1, 2, 3] 排列组合情况，输出并打印。</p>
<img src="/2021/03/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/algorithm_08.png" alt="回溯法" style="zoom:80%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        backTrack(list, new ArrayList&lt;Integer&gt;(), nums);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void backTrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums)&#123;</span><br><span class="line">        if(tempList.size() &#x3D;&#x3D; nums.length)&#123;</span><br><span class="line">            list.add(new ArrayList&lt;&gt;(tempList));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(int i &#x3D; 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            	&#x2F;&#x2F; 已经使用过的数字就不能再用了，continue跳出本次循环，进行下一次循环</span><br><span class="line">                if(tempList.contains(nums[i]))</span><br><span class="line">                    continue;</span><br><span class="line">                tempList.add(nums[i]);</span><br><span class="line">                backTrack(list, tempList, nums);</span><br><span class="line">                &#x2F;&#x2F; 回溯</span><br><span class="line">                tempList.remove(tempList.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似题目：数字的全排列（有重复数字）、矩阵中的路径、子集问题、电话号码的字母组合</p>
<h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ul>
<li>明确目标</li>
<li>定位问题</li>
</ul>
<p>分析：</p>
<ul>
<li>这个问题是什么类型（排序、查找、最优化）</li>
<li>这个问题的复杂度下限是什么（暴力解法）</li>
<li>哪些数据结构和算法思维适用</li>
</ul>
<p>通用解题思路：</p>
<ul>
<li><strong>面对一个未知问题时，你可以从复杂度入手</strong>。尝试去分析这个问题的时间复杂度上限是多少，也就是复杂度再高能高到哪里。这就是不计任何时间、空间损耗，采用暴力求解的方法去解题。然后分析这个问题的时间复杂度下限是多少，也就是时间复杂度再低能低到哪里。这就是你写代码的目标。</li>
<li><strong>接着，尝试去定位问题</strong>。在分析出这两个问题之后，就需要去设计合理的数据结构和运用合适的算法思维，从暴力求解的方法去逼近写代码的目标了。在这里需要先定位问题，这个问题的类型就决定了采用哪种算法思维。</li>
<li><strong>最后，需要对数据操作进行分析</strong>。例如：在这个问题中，需要对数据进行哪些操作（增删查），数据之间是否需要保证顺序或逆序？当分析出这些操作的步骤、频次之后，就可以根据不同数据结构的特性，去合理选择你所应该使用的那几种数据结构了。</li>
</ul>
<p>经过以上分析，我们对方法论进行提练，宏观上的步骤总结为以下 4 步：</p>
<ul>
<li><strong>复杂度分析</strong>。估算问题中复杂度的上限和下限。</li>
<li><strong>定位问题</strong>。根据问题类型，确定采用何种算法思维。</li>
<li><strong>数据操作分析</strong>。根据增、删、查和数据顺序关系去选择合适的数据结构，利用空间换取时间。</li>
<li><strong>编码实现</strong>。</li>
</ul>
<blockquote>
<p>笔记来源：公瑾 老师的《重学数据结构与算法》课程</p>
<p>回溯法：<a href="https://blog.csdn.net/weixin_45594025/article/details/105005464" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45594025/article/details/105005464</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常用工具集</title>
    <url>/2021/03/15/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
    <content><![CDATA[<h1 id="常用工具集"><a href="#常用工具集" class="headerlink" title="常用工具集"></a>常用工具集</h1><ul>
<li>团队协作：Ant、<strong>Maven</strong>、Gradle、<strong>Git</strong>、<strong>SVN</strong></li>
<li>质量保证：CheckStyle、<strong>FindBugs</strong>、<strong>SonarQube</strong></li>
<li>压测：<strong>JMeter</strong>、JMH、AB、LoadRunner</li>
<li>容器与代理：<strong>Tomcat</strong>、<strong>Jetty、Nginx</strong>、Envoy、</li>
<li>CI/CD: <strong>Gitlab-CI</strong>、<strong>Jenkins</strong>、Travls、CircleCI</li>
<li>JVM工具：JMC、jstack、jmap、jstat、jinfo、jcmd、btrace、MAT</li>
<li>系统分析：vmstat、lostat &amp; lotop、ifstat &amp; iftop 、netstat、dstat、strace、GDB、losf、tcpdump、traceroute</li>
<li>文档管理：<strong>javaDoc</strong>、<strong>Swagger</strong></li>
<li>网络工具：<strong>PostMan</strong>、WireShark、Fiddler、Charles</li>
</ul>
<p><strong>Ant+ivy</strong>、<strong>Maven</strong>、<strong>Gradle</strong> 都是用来构建项目、管理依赖的工具。</p>
<p>其中 <strong>Ant</strong> 通过直接引用 <strong>jar</strong> 文件来进行依赖管理，通过脚本来描述，执行不同的构建目标。</p>
<p>目前 <strong>Ant</strong> 使用得已经比较少，<strong>Maven</strong> 是比较主流的项目管理工具。<br><strong>Gradle</strong>是一个自动化的构建工具，<strong>Gradle</strong>属于结合以上两个的优点，它继承了<strong>Ant</strong>的灵活和<strong>Maven</strong>的生命周期管理，它最后被google作为了Android御用管理工具。</p>
<p>它最大的区别是不用 <code>XML</code> 作为配置文件格式，采用了 <code>DSL</code> 格式，使得脚本更加简洁。<strong>Gradle</strong>引入了基于<strong>Groovy</strong>语言的 <code>DSL</code> 语法来代替 <code>XML</code> 配置，因此它的配置文件是一个<strong>Groovy</strong>文件。</p>
<p><strong>Ant</strong> 由于出现较早，可结合项目复习，不再赘述。</p>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><h5 id="构建的各个环节"><a href="#构建的各个环节" class="headerlink" title="构建的各个环节"></a>构建的各个环节</h5><p>　　[1] 清理clean：将以前编译得到的旧文件class字节码文件删除</p>
<p>　　[2] 编译compile：将java源程序编译成class字节码文件</p>
<p>　　[3] 测试test：自动测试，自动调用junit程序</p>
<p>　　[4] 报告report：测试程序执行的结果</p>
<p>　　[5] 打包package：动态Web工程打War包，java工程打jar包</p>
<p>　　[6] 安装install：Maven特定的概念—–将打包得到的文件复制到“仓库”中的指定位置</p>
<p>　　[7] 部署deploy：将动态Web工程生成的war包复制到Servlet容器下，使其可以运行</p>
<h5 id="常用maven命令"><a href="#常用maven命令" class="headerlink" title="常用maven命令"></a>常用maven命令</h5><p>　　[1] mvn clean：清理 </p>
<p>　　[2] mvn compile：编译主程序</p>
<p>　　[3] mvn test-compile：编译测试程序</p>
<p>　　[4] mvn test：执行测试 </p>
<p>　　[5] mvn package：打包</p>
<p>　　[6] mvn install：安装</p>
<p>　　执行maven命令必须进入到pom.xml的目录中进行执行</p>
<h5 id="scope（依赖的范围）"><a href="#scope（依赖的范围）" class="headerlink" title="scope（依赖的范围）"></a>scope（依赖的范围）</h5><p>　　1、compile，默认值，适用于所有阶段（开发、测试、部署、运行），本jar会一直存在所有阶段。 </p>
<p>　　2、provided，只在开发、测试阶段使用，目的是不让Servlet容器和你本地仓库的jar包冲突 。如servlet.jar。 </p>
<p>　　3、runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。 </p>
<p>　　4、test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。 </p>
<p>　　5、system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。</p>
<h5 id="maven-聚合管理"><a href="#maven-聚合管理" class="headerlink" title="maven 聚合管理"></a>maven 聚合管理</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../mvc-core<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../mvc-dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../mvc-service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../mvc-log<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Maven-配置依赖管理"><a href="#Maven-配置依赖管理" class="headerlink" title="Maven 配置依赖管理"></a>Maven 配置依赖管理</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="maven-配置继承关系"><a href="#maven-配置继承关系" class="headerlink" title="maven 配置继承关系"></a>maven 配置继承关系</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../demo-parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h5 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h5><ul>
<li>设置用户名：git config –global user.name 【git用户名】</li>
<li>设置邮箱：git config –global user.email 【邮箱地址】</li>
<li>查看当前用户信息：git config –list </li>
<li>初始化git仓库：git init</li>
<li>将工作目录中的文件全部添加到暂存区：git add .</li>
<li>查看文件状态：git status</li>
<li>向本地仓库中提交代码：git commit -m  【提交时的描述】</li>
<li>用暂存区中的文件覆盖工作目录中的文件：git checkout  【文件名】</li>
<li>将文件从暂存区中删除：git rm –cached 【文件名】</li>
<li>将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：git rest –hard commitID</li>
<li>查看提交记录：git log</li>
<li>克隆远程仓库文件到本地仓库：git clone 【 仓库地址】</li>
<li>把本地仓库的文件提交到远程仓库：git push 【仓库地址】【分支名称】 </li>
<li>git push  -u【仓库地址】【分支名称】<br>-u 记住推送地址及分支，下次推送只需要输入git push即可</li>
<li>设置仓库别名：git remote add 【自定义仓库别名】【远程仓库地址】</li>
<li>拉取远程仓库中最新的版本到本地仓库：git pull 【仓库地址】【分支名称】</li>
<li>查看分支：git branch</li>
<li>创建分支：git branch 【分支名称】</li>
<li>切换分支：git checkout 【分支名称】</li>
<li>合并某分支到当前分支：git merge 【分支名称】</li>
<li>删除分支：git branch -d 【分支名称】（分支被合并后才允许删除）（-D 强制删除）</li>
</ul>
<h5 id="Git撤销-amp-回滚操作-git-reset-和-get-revert"><a href="#Git撤销-amp-回滚操作-git-reset-和-get-revert" class="headerlink" title="Git撤销&amp;回滚操作 (git reset 和 get revert)"></a>Git撤销&amp;回滚操作 (git reset 和 get revert)</h5><p>概念：</p>
<ul>
<li><p><strong>工作区</strong>：即自己当前分支所修改的代码，<strong>git add xx 之前的代码</strong>；</p>
</li>
<li><p><strong>暂存区</strong>：git add xxx 之后，git commit xxx 之前的。</p>
</li>
<li><p><strong>本地分支</strong>：已经git commit -m xxx 提交到本地分支的。</p>
</li>
</ul>
<p><strong>工作区（未add）</strong></p>
<ul>
<li><strong>git checkout – a.txt</strong>  # 丢弃某个文件，或者</li>
<li><strong>git checkout – .</strong>    # 丢弃全部，包含新增的会删除，删除的会还原</li>
</ul>
<p><strong>暂存区（已add,未commit）</strong></p>
<ul>
<li><strong>git reset HEAD .</strong>   # 将所有暂存区文件丢弃到工作区</li>
<li><strong>git reset HEAD a.txt</strong>   #将制定文件丢弃到工作区</li>
</ul>
<p><strong>本地分支（已commit，未push）</strong></p>
<p><strong>git log</strong> # 得到你需要回退一次提交的commit id</p>
<ul>
<li><strong>git reset –hard <commit_id></commit_id></strong>  # 回到其中你想要的某个版本</li>
<li><strong>git reset –hard HEAD^</strong>  # 回到最新的一次提交</li>
<li><strong>git reset HEAD^</strong>  # 此时代码保留，回到 git add 之前</li>
</ul>
<p>– soft ：回到暂存区</p>
<p>– mixd：回到工作区</p>
<p>– hard：彻底回滚，找不回</p>
<p><strong>远程分支（已push）</strong></p>
<ul>
<li><p>通过git reset是直接删除指定的commit</p>
<p>git log # 得到你需要回退一次提交的commit id<br>git reset –hard <commit_id><br>git push origin HEAD –force # 强制提交一次，之前错误的提交就从远程仓库删除</commit_id></p>
</li>
<li><p>通过git revert是用一次新的commit来回滚之前的commit</p>
<p>git log # 得到你需要回退一次提交的commit id<br>git revert <commit_id>  # 撤销指定的版本，撤销也会作为一次提交进行保存</commit_id></p>
</li>
<li><p>git revert 和 git reset的区别</p>
<ul>
<li>git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；</li>
<li>git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除</li>
</ul>
</li>
</ul>
<h5 id="Git-工作流"><a href="#Git-工作流" class="headerlink" title="Git 工作流"></a>Git 工作流</h5><p>目前常用工作流分别是以下三种：</p>
<ul>
<li><strong>Git Flow</strong></li>
<li><strong>GitHub Flow</strong></li>
<li><strong>GitLab Flow</strong></li>
</ul>
<p><strong>Git Flow</strong></p>
<table>
<thead>
<tr>
<th>分支</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>主分支，最新的稳定版本的已部署到生产环境的代码分支，用于发布官方的大版本</td>
</tr>
<tr>
<td>develop</td>
<td>开发分支，最新的处于开发测试阶段的稳定版本，用来记录新功能开发的代码节点</td>
</tr>
<tr>
<td>feature</td>
<td>功能分支，基于develop分支的新功能分支。feature分支不能和master分支有直接的交互</td>
</tr>
<tr>
<td>release</td>
<td>预发分支，基于develop分支的满足发布条件的分支，最终会合并到master分支</td>
</tr>
<tr>
<td>hotfix</td>
<td>补丁分支，基于master分支的紧急修复分支，最终会被并入develop和master分支</td>
</tr>
</tbody></table>
<p>首先，项目存在两个长期分支。<strong>主分支master 和开发分支 develop；</strong></p>
<p>前者用于存放对外发布的版本，任何时候在这个分支拿到的，都是稳定的分布版；后者用于日常开发，存放的开发版。</p>
<p>其次，项目存在三种短期分支。<strong>功能分支（feature branch）、补丁分支（hotfix branch）、预发分支（release branch）。</strong></p>
<p>一旦完成开发，它们就会被合并进develop或master，然后被删除。</p>
<p><strong>优缺点</strong>：</p>
<ul>
<li>优点：清晰可控</li>
<li>缺点：复杂，分支多，切换出错</li>
</ul>
<p><strong>GitHub Flow</strong></p>
<p>Github flow 是Git flow的简化版，专门配合”持续发布”。它是 Github.com 使用的工作流程。</p>
<p>它<strong>只有一个长期分支，就是master</strong>，因此用起来非常简单。</p>
<p>每次新版本 一个 feature 分支，开发完成向 master 合并，适合 持续交付类项目。</p>
<p><strong>Gitlab Flow</strong></p>
<p><strong>Gitlab flow 是 Git flow 与 Github flow 的综合。</strong>它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。</p>
<p>Gitlab flow 的较大原则叫做”<strong>上游优先</strong>”（upsteam first），即只存在一个主分支master，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支。</p>
<p>对于”持续发布”的项目，它建议在master分支以外，再<strong>建立不同的环境分支</strong>。比如，”开发环境”的分支是master，”预发环境”的分支是pre-production，”生产环境”的分支是production。</p>
<p>开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。<strong>代码的变化，必须由”上游”向”下游”发展</strong>。比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到master，确认没有问题，再cherry-pick到pre-production，这一步也没有问题，才进入production。</p>
<p><strong>只有紧急情况，才允许跳过上游，直接合并到下游分支。</strong></p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/cvvface/article/details/81216462" target="_blank" rel="noopener">https://blog.csdn.net/cvvface/article/details/81216462</a></p>
<p><a href="http://www.duozhishidai.com/article-113700-1.html" target="_blank" rel="noopener">http://www.duozhishidai.com/article-113700-1.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>必会框架（二）- Netty</title>
    <url>/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89-Netty/</url>
    <content><![CDATA[<h1 id="必会框架（二）-Netty"><a href="#必会框架（二）-Netty" class="headerlink" title="必会框架（二）-  Netty"></a>必会框架（二）-  Netty</h1><ul>
<li>NIO框架 Netty 、以及基于Netty实现的 主流RPC 框架Motan、Dubbo和gRPC</li>
</ul>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>Netty</strong> 是一款用于高效开发网络应用的 <strong>NIO 网络框架</strong>，它大大简化了网络应用的开发过程。被广泛使用在中间件、直播、社交、游戏等领域。目前，许多知名的开源软件也都将 Netty 用作网络通信的底层框架，如 Dubbo、gRPC、ActiveMQ、RocketMQ、Elasticsearch、HBase 、Spark等。</p>
<ul>
<li><strong>I/O 模型、线程模型和事件处理机制</strong>；</li>
<li><strong>易用性 API 接口；</strong></li>
<li><strong>对数据协议、序列化的支持。</strong></li>
</ul>
<h4 id="Java-NIO-的演变"><a href="#Java-NIO-的演变" class="headerlink" title="Java NIO 的演变"></a>Java NIO 的演变</h4><p>在 JDK 1.4 投入使用之前，只有 <strong>BIO</strong> 一种模式。开发过程相对简单。新来一个连接就会创建一个新的线程处理。随着请求并发度的提升，<strong>BIO</strong> 很快遇到了性能瓶颈。</p>
<p>JDK 1.4 以后开始引入了 <strong>NIO</strong> 技术，支持 <strong>select</strong> 和 <strong>poll</strong>；</p>
<p>JDK 1.5 支持了 <strong>epoll</strong>；</p>
<p>JDK 1.7 发布了 <strong>NIO2</strong>，支持 <strong>AIO</strong> 模型。</p>
<p>虽然 <strong>Java NIO</strong> 已经升级的足够成熟，但是 <strong>Netty</strong> 相比其还是有很多优点。</p>
<h4 id="Netty-相比-Java-NIO-的优点"><a href="#Netty-相比-Java-NIO-的优点" class="headerlink" title="Netty 相比  Java NIO 的优点"></a><strong>Netty</strong> 相比  Java NIO 的优点</h4><ul>
<li><p><strong>易用性。</strong> 我们使用 <strong>JDK NIO</strong> 编程需要了解很多复杂的概念，比如 <strong>Channels</strong>、<strong>Selectors、Sockets、Buffers</strong> 等。<strong>Netty</strong> 在 <strong>NIO</strong> 基础上进行了更高层次的封装，屏蔽了 <strong>NIO</strong> 的复杂性；</p>
<p><strong>Netty</strong> 封装了更加人性化的 API，统一的 API（阻塞/非阻塞） 大大降低了开发者的上手难度；与此同时，<strong>Netty</strong> 提供了很多开箱即用的工具，例如常用的行解码器、长度域解码器等，而这些在 <strong>JDK NIO</strong> 中都需要你自己实现。</p>
</li>
<li><p><strong>稳定性。</strong> <strong>Netty</strong> 更加可靠稳定，修复和完善了 <strong>JDK NIO</strong> 较多已知问题，例如臭名昭著的 <strong>select</strong> 空转导致 CPU 消耗 100%，TCP 断线重连，<strong>keep-alive</strong> 检测等问题。</p>
</li>
<li><p><strong>可扩展性。</strong> <strong>Netty</strong> 的可扩展性在很多地方都有体现，这里我主要列举其中的两点：一个是可定制化的线程模型，用户可以通过启动的配置参数选择 <strong>Reactor</strong> 线程模型；另一个是可扩展的事件驱动模型，将框架层和业务层的关注点分离。大部分情况下，开发者只需要关注 <strong>ChannelHandler</strong> 的业务逻辑实现。</p>
</li>
<li><p><strong>更低的资源消耗</strong>作为网络通信框架，需要处理海量的网络数据，那么必然面临有大量的网络对象需要创建和销毁的问题，对于 JVM GC 并不友好。</p>
<p>为了降低 JVM 垃圾回收的压力，Netty 主要采用了两种优化手段：</p>
<p><strong>对象池复用技术。</strong> <strong>Netty</strong> 通过复用对象，避免频繁创建和销毁带来的开销。</p>
<p><strong>零拷贝技术。</strong> 除了操作系统级别的零拷贝技术外，<strong>Netty</strong> 提供了更多面向用户态的零拷贝技术，例如 Netty 在 I/O 读写时直接使用 <strong>DirectBuffer</strong>，从而避免了数据在堆内存和堆外内存之间的拷贝。</p>
</li>
</ul>
<h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89-Netty/framework_11.png" alt="Netty模块结构"></p>
<img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89-Netty/framework_15.png" alt="对应代码分层" style="zoom:33%;">

<p>由结构图可以看出，<strong>Netty</strong> 整体结构主要分为三个部分：</p>
<h5 id="Core-核心层"><a href="#Core-核心层" class="headerlink" title="Core 核心层"></a><strong>Core 核心层</strong></h5><p>提供了底层网络通信的通用抽象和实现，包括可扩展的事件模型、通用的通信 API、支持零拷贝的 <strong>ByteBuf</strong> 等。</p>
<h5 id="Protocol-Support-协议支持层"><a href="#Protocol-Support-协议支持层" class="headerlink" title="Protocol Support 协议支持层"></a><strong>Protocol Support 协议支持层</strong></h5><p>协议支持层基本上覆盖了主流协议的编解码实现，如 <strong>HTTP、SSL、Protobuf</strong>、压缩、大文件传输、<strong>WebSocket</strong>、文本、二进制等主流协议，此外 <strong>Netty</strong> 还支持自定义应用层协议。<strong>Netty</strong> 丰富的协议支持降低了用户的开发成本，基于 <strong>Netty</strong> 我们可以快速开发 <strong>HTTP</strong>、<strong>WebSocket</strong> 等服务。</p>
<h5 id="Transport-Service-传输服务层"><a href="#Transport-Service-传输服务层" class="headerlink" title="Transport Service 传输服务层"></a><strong>Transport Service 传输服务层</strong></h5><p>传输服务层提供了网络传输能力的定义和实现方法。它支持 <strong>Socket</strong>、<strong>HTTP</strong> 隧道、虚拟机管道等传输方式。<strong>Netty</strong> 对 <strong>TCP、UDP</strong> 等数据传输做了抽象和封装，用户可以更聚焦在业务逻辑实现上，而不必关系底层数据传输的细节。</p>
<p><strong>Netty</strong> 的模块设计具备较高的<strong>通用性和可扩展性</strong>，它不仅是一个优秀的网络框架，还可以作为网络编程的工具箱。<strong>Netty</strong> 的设计理念非常优雅，值得我们学习借鉴。</p>
<h4 id="逻辑分层"><a href="#逻辑分层" class="headerlink" title="逻辑分层"></a>逻辑分层</h4><p><strong>Netty</strong> 的逻辑处理架构为典型<strong>网络分层架构设计</strong>，共分为<strong>网络通信层、事件调度层、服务编排层</strong>，每一层各司其职：</p>
<img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89-Netty/framework_12.png" alt="Netty逻辑处理架构" style="zoom:70%;">

<h5 id="网络通信层"><a href="#网络通信层" class="headerlink" title="网络通信层"></a>网络通信层</h5><p>网络通信层的职责是<strong>执行网络 I/O 的操作</strong>。它支持多种网络协议和 I/O 模型的连接操作。当网络数据读取到内核缓冲区后，会触发各种网络事件，这些网络事件会分发给事件调度层进行处理。</p>
<p><strong>核心组件</strong>：</p>
<ul>
<li><p><strong>BootStrap</strong>：主要负责整个 <strong>Netty</strong> 程序的启动、初始化、服务器连接等过程，它相当于一条主线，串联了 <strong>Netty</strong> 的其他核心组件；<strong>Netty</strong> 中的引导器共分为两种类型：一个为<strong>用于客户端引导的 Bootstrap</strong>，另一个为<strong>用于服务端引导的 ServerBootStrap</strong>，它们都继承自抽象类 <strong>AbstractBootstrap</strong>。<strong>Bootstrap</strong> 可用于连接远端服务器，只绑定一个 <strong>EventLoopGroup</strong>。</p>
</li>
<li><p><strong>ServerBootStrap</strong>：<strong>用于服务端引导的 ServerBootStrap</strong>，绑定两个 <strong>EventLoopGroup</strong>： <strong>Boss</strong> 和 <strong>Worker</strong>。每个服务器中都会有一个 <strong>Boss</strong>，也会有一群做事情的 <strong>Worker</strong>。<strong>Boss</strong> 会不停地接收新的连接，然后将连接分配给一个个 <strong>Worker</strong> 处理连接。</p>
</li>
<li><p><strong>Channel：Channel</strong> 即是“通道”，它是网络通信的载体。<strong>Channel</strong>提供了基本的 API 用于网络 I/O 操作，如 <strong>register、bind、connect、read、write、flush</strong> 等。<strong>Netty</strong> 自己实现的 <strong>Channel</strong> 是以 <strong>JDK NIO Channel</strong> 为基础的，相比较于 JDK NIO，Netty 的 Channel 提供了更高层次的抽象，同时屏蔽了底层 Socket 的复杂性，赋予了 Channel 更加强大的功能。</p>
<p>常用的 <strong>Channel 实现类</strong>有：</p>
<ul>
<li><strong>NioServerSocketChannel</strong> 异步 TCP 服务端。</li>
<li><strong>NioSocketChannel</strong> 异步 TCP 客户端。</li>
<li><strong>OioServerSocketChannel</strong> 同步 TCP 服务端。</li>
<li><strong>OioSocketChannel</strong> 同步 TCP 客户端。</li>
<li><strong>NioDatagramChannel</strong> 异步 UDP 连接。</li>
<li><strong>OioDatagramChannel</strong> 同步 UDP 连接。</li>
</ul>
<p><strong>Channel</strong> 会有多种状态，如<strong>连接建立、连接注册、数据读写、连接销毁</strong>等。随着状态的变化，Channel 处于不同的生命周期，每一种状态都会绑定相应的<strong>事件回调</strong>，例如：</p>
<ul>
<li><strong>channelRegistered</strong>  Channel 创建后被注册到 EventLoop 上</li>
<li><strong>channelUnregistered</strong>  Channel 创建后未注册或者从 EventLoop 取消注册</li>
<li><strong>channelActive</strong>  Channel 处于就绪状态，可以被读写</li>
<li><strong>channelInactive</strong>  Channel 处于非就绪状态</li>
<li><strong>channelRead</strong>  Channel 可以从远端读取到数据</li>
<li><strong>channelReadComplete</strong>  Channel 读取数据完成</li>
</ul>
</li>
</ul>
<h5 id="事件调度层"><a href="#事件调度层" class="headerlink" title="事件调度层"></a>事件调度层</h5><p>事件调度层的职责是<strong>通过 Reactor 线程模型对各类事件进行聚合处理</strong>，通过 <strong>Selector</strong> 主循环线程集成多种事件（ I/O 事件、信号事件、定时事件等），实际的业务处理逻辑是交由服务编排层中</p>
<p>相关的 <strong>Handler</strong> 完成。</p>
<p><strong>核心组件</strong>：</p>
<ul>
<li><p><strong>EventLoop</strong>：用于处理 <strong>Channel</strong> 生命周期内的所有 <strong>I/O 事件</strong>，如 accept、connect、read、write 等 I/O 事件。每个 <strong>EventLoop</strong> 负责处理多个 <strong>Channel</strong>，每新建一个 <strong>Channel</strong>，<strong>EventLoopGroup</strong> 会选择一个 <strong>EventLoop</strong> 与其绑定。该 <strong>Channel</strong> 在生命周期内都可以对 <strong>EventLoop</strong> 进行多次绑定和解绑。</p>
</li>
<li><p><strong>EventLoopGroup</strong>：一个 <strong>EventLoopGroup</strong> 往往包含一个或者多个 <strong>EventLoop</strong>，<strong>EventLoopGroup</strong> 本质是一个线程池，主要负责接收 I/O 请求，并分配线程执行处理请求。</p>
</li>
</ul>
<img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89-Netty/framework_13.png" alt="EventLoopGroup继承图谱" style="zoom:35%;">

<p><strong>EventLoopGroup</strong> 的实现类是 <strong>NioEventLoopGroup</strong>，<strong>NioEventLoopGroup</strong> 也是 <strong>Netty</strong> 中最被推荐使用的线程模型。<strong>NioEventLoopGroup</strong> 继承于 <strong>MultithreadEventLoopGroup</strong>，是基于 <strong>NIO 模型</strong>开发的，可以把 <strong>NioEventLoopGroup</strong> 理解为一个线程池，每个线程负责处理多个 <strong>Channel</strong>，而同一个 <strong>Channel</strong> 只会对应一个线程。</p>
<p><strong>Netty</strong> 通过创建不同的 <strong>EventLoopGroup</strong> 参数配置，支持 <strong>Reactor</strong> 的三种线程模型：</p>
<ul>
<li><strong>单线程模型</strong>：EventLoopGroup 只包含一个 EventLoop，Boss 和 Worker 使用同一个EventLoopGroup；</li>
<li><strong>多线程模型</strong>：EventLoopGroup 包含多个 EventLoop，Boss 和 Worker 使用同一个EventLoopGroup；</li>
<li><strong>主从多线程模型</strong>：EventLoopGroup 包含多个 EventLoop，Boss 是主 Reactor，Worker 是从 Reactor，它们分别使用不同的 EventLoopGroup，主 Reactor 负责新的网络连接 Channel 创建，然后把 Channel 注册到从 Reactor。</li>
</ul>
<h5 id="服务编排层"><a href="#服务编排层" class="headerlink" title="服务编排层"></a>服务编排层</h5><p>服务编排层的职责是<strong>负责组装各类服务</strong>，它是 <strong>Netty</strong> 的核心处理链，用以实现网络事件的动态编排和有序传播。</p>
<p><strong>核心组件</strong></p>
<ul>
<li><strong>ChannelPipeline</strong></li>
<li><strong>ChannelHandler</strong></li>
<li><strong>ChannelHandlerContext</strong></li>
</ul>
<p><strong>ChannelPipeline</strong></p>
<p><strong>ChannelPipeline</strong> 是 <strong>Netty</strong> 的<strong>核心编排组</strong>件，<strong>负责组装各种 ChannelHandler</strong>，实际数据的编解码以及加工处理操作都是由 <strong>ChannelHandler</strong> 完成的；</p>
<p><strong>ChannelPipeline</strong> 可以理解为<strong>ChannelHandler 的实例列表</strong>，内部通过双向链表将不同的 <strong>ChannelHandler</strong> 链接在一起。当 I/O 读写事件触发时，<strong>ChannelPipeline</strong> 会依次调用 <strong>ChannelHandler</strong> 列表对 <strong>Channel</strong> 的数据进行拦截和处理。</p>
<p><strong>ChannelPipeline</strong> 是线程安全的，因为每一个新的 <strong>Channel</strong> 都会对应绑定一个新的 <strong>ChannelPipeline</strong>。一个 <strong>ChannelPipeline</strong> 关联一个 <strong>EventLoop</strong>，一个 <strong>EventLoop</strong> 仅会绑定一个线程。</p>
<p><strong>ChannelPipeline</strong> 处理器：</p>
<ul>
<li>入站 <strong>ChannelInboundHandler</strong> </li>
<li>出站 <strong>ChannelOutboundHandler</strong> </li>
</ul>
<p>客户端和服务端都有各自的 <strong>ChannelPipeline</strong>。</p>
<p>我们经常使用的编码 <strong>Encoder</strong> 是出站操作，解码 <strong>Decoder</strong> 是入站操作。服务端接收到客户端数据后，需要先经过 <strong>Decoder</strong> 入站处理后，再通过 <strong>Encoder</strong> 出站通知客户端。</p>
<p><strong>ChannelHandler</strong></p>
<p>数据的编解码工作以及其他转换工作实际都是通过 <strong>ChannelHandler</strong> 处理的。站在开发者的角度，最需要关注的就是 <strong>ChannelHandler</strong>，我们很少会直接操作 <strong>Channel</strong>，都是通过 <strong>ChannelHandler</strong> 间接完成。</p>
<p><img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89-Netty/framework_14.png" alt="ChannelHandler关系"></p>
<p>每创建一个 <strong>Channel</strong> 都会绑定一个新的 <strong>ChannelPipeline</strong>，<strong>ChannelPipeline</strong> 中每加入一个 <strong>ChannelHandler</strong> 都会绑定一个 <strong>ChannelHandlerContext</strong>。</p>
<p><strong>ChannelHandlerContext</strong></p>
<p><strong>ChannelHandlerContext</strong> 用于保存 <strong>ChannelHandler 上下文</strong>，通过 <strong>ChannelHandlerContext</strong> 我们可以知道 <strong>ChannelPipeline</strong> 和 <strong>ChannelHandler</strong> 的关联关系。<strong>ChannelHandlerContext</strong> 可以实现 <strong>ChannelHandler</strong> 之间的交互，<strong>ChannelHandlerContext</strong> 包含了 <strong>ChannelHandler</strong> 生命周期的所有事件，如 connect、bind、read、flush、write、close 等。</p>
<p><strong>工作流程</strong>：</p>
<ul>
<li>服务端启动初始化时有 <strong>Boss EventLoopGroup</strong> 和 <strong>Worker EventLoopGroup</strong> 两个组件，其中 <strong>Boss</strong> 负责监听网络连接事件。</li>
<li>当有新的网络连接事件到达时，则将 <strong>Channel</strong> 注册到 <strong>Worker EventLoopGroup</strong>。</li>
<li><strong>Worker EventLoopGroup</strong> 会被分配一个 <strong>EventLoop</strong> 负责处理该 <strong>Channel</strong> 的读写事件。每个 <strong>EventLoop</strong> 都是单线程的，通过 <strong>Selector</strong> 进行事件循环。</li>
<li>当客户端发起 <strong>I/O</strong> 读写事件时，服务端 <strong>EventLoop</strong> 会进行数据的读取，然后通过 <strong>Pipeline</strong> 触发各种监听器进行数据的加工处理。</li>
<li>客户端数据会被传递到 <strong>ChannelPipeline</strong> 的第一个 <strong>ChannelInboundHandler</strong> 中，数据处理完成后，将加工完成的数据传递给下一个 <strong>ChannelInboundHandler</strong>。</li>
<li>当数据写回客户端时，会将处理结果在 <strong>ChannelPipeline</strong> 的 <strong>ChannelOutboundHandler</strong> 中传播，最后到达客户端。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="Netty实现简单Http服务器"><a href="#Netty实现简单Http服务器" class="headerlink" title="Netty实现简单Http服务器"></a>Netty实现简单Http服务器</h4><p>Netty 官方提供 3.x、4.x 的稳定版本，之前一直处于测试阶段的 5.x 版本已被作者放弃维护。目前主流推荐 Netty 4.x 的稳定版本，Netty 3.x 到 4.x 版本发生了较大变化，属于不兼容升级。</p>
<ul>
<li><p><strong>maven 引入Netty 依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.6.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建服务器代码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建引导器</span></span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup) <span class="comment">// 配置线程模型</span></span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>) // 绑定<span class="title">Channel</span>实现类</span></span><br><span class="line"><span class="class">                    .<span class="title">localAddress</span>(<span class="title">new</span> <span class="title">InetSocketAddress</span>(<span class="title">port</span>))// 绑定端口</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;<span class="comment">// 注册ChannelHandler</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                            ch.pipeline()</span><br><span class="line">                                <span class="comment">// HTTP 编解码</span></span><br><span class="line">                                .addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpServerCodec())                  								  <span class="comment">// HttpContent 压缩</span></span><br><span class="line">                                .addLast(<span class="string">"compressor"</span>, <span class="keyword">new</span> HttpContentCompressor())  </span><br><span class="line">                                <span class="comment">// HTTP 消息聚合</span></span><br><span class="line">                                .addLast(<span class="string">"aggregator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>))</span><br><span class="line">                                <span class="comment">// 自定义业务逻辑处理器</span></span><br><span class="line">                                .addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HttpServerHandler());             </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// 设置Channel参数</span></span><br><span class="line">            ChannelFuture f = b.bind().sync(); <span class="comment">// 绑定启动</span></span><br><span class="line">            System.out.println(<span class="string">"Http Server started， Listening on "</span> + port);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NettyServer().start(<span class="number">8088</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>服务端业务逻辑处理类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">FullHttpRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, FullHttpRequest msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 响应内容</span></span><br><span class="line">        String content = String.format(<span class="string">"Receive http request, uri: %s, method: %s, content: %s%n"</span>, msg.uri(),</span><br><span class="line">                msg.method(), msg.content().toString(CharsetUtil.UTF_8));</span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(</span><br><span class="line">                HttpVersion.HTTP_1_1,</span><br><span class="line">                HttpResponseStatus.OK,</span><br><span class="line">                Unpooled.wrappedBuffer(content.getBytes()));</span><br><span class="line">        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>浏览器测试</strong></p>
<img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89-Netty/framework_20.png" alt="浏览器测试" style="zoom:80%;">
</li>
<li><p><strong>补充客户端代码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Http客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String host, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(group);</span><br><span class="line">            b.channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">            b.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> HttpResponseDecoder());</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> HttpRequestEncoder());</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> HttpClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(<span class="string">"http://127.0.0.1:8088"</span>);</span><br><span class="line">            String content = <span class="string">"hello world"</span>;</span><br><span class="line">            DefaultFullHttpRequest request = <span class="keyword">new</span> DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET,</span><br><span class="line">                    uri.toASCIIString(), Unpooled.wrappedBuffer(content.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">            request.headers().set(HttpHeaderNames.HOST, host);</span><br><span class="line">            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);</span><br><span class="line">            request.headers().set(HttpHeaderNames.CONTENT_LENGTH, request.content().readableBytes());</span><br><span class="line">            f.channel().write(request);</span><br><span class="line">            f.channel().flush();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpClient client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        client.connect(<span class="string">"127.0.0.1"</span>, <span class="number">8088</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端处理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpContent) &#123;</span><br><span class="line">            HttpContent content = (HttpContent) msg;</span><br><span class="line">            ByteBuf buf = content.content();</span><br><span class="line">            System.out.println(buf.toString(io.netty.util.CharsetUtil.UTF_8));</span><br><span class="line">            buf.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此，一个简单的基于Netty 的Http 服务器就完成了，我们发现服务器启动大致分为三个步骤：</p>
<ul>
<li><strong>配置线程池</strong></li>
<li><strong>Channel初始化</strong></li>
<li><strong>端口绑定</strong></li>
</ul>
<h4 id="配置线程池"><a href="#配置线程池" class="headerlink" title="配置线程池"></a>配置线程池</h4><p><strong>Netty</strong> 是采用 <strong>Reactor 模型</strong>进行开发的，可以非常容易切换三种 <strong>Reactor</strong> 模式：<strong>单线程模式</strong>、<strong>多线程模式</strong>、<strong>主从多线程模式</strong>。</p>
<h5 id="单线程模式"><a href="#单线程模式" class="headerlink" title="单线程模式"></a>单线程模式</h5><p><strong>Reactor</strong> 单线程模型所有 I/O 操作都由一个线程完成，所以只需要启动一个 <strong>EventLoopGroup</strong> 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定1个线程</span></span><br><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">b.group(group)</span><br></pre></td></tr></table></figure>

<h5 id="多线程模式"><a href="#多线程模式" class="headerlink" title="多线程模式"></a><strong>多线程模式</strong></h5><p><strong>Reactor</strong> 单线程模型有非常严重的性能瓶颈，因此 <strong>Reactor</strong> 多线程模型出现了。在 <strong>Netty</strong> 中使用 <strong>Reactor</strong> 多线程模型与单线程模型非常相似，区别是 <strong>NioEventLoopGroup</strong> 可以不需要任何参数，它默认会启动 2 倍 CPU 核数的线程。当然，你也可以自己手动设置固定的线程数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不指定线程数，默认2倍CPU核心数的线程数</span></span><br><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">b.group(group)</span><br></pre></td></tr></table></figure>

<h5 id="主从多线程模式"><a href="#主从多线程模式" class="headerlink" title="主从多线程模式"></a><strong>主从多线程模式</strong></h5><p>在大多数场景下，我们采用的都是<strong>主从多线程 Reactor 模型</strong>。Boss 是主 Reactor，Worker 是从 Reactor。它们分别使用不同的 NioEventLoopGroup，主 Reactor 负责处理 Accept，然后把 Channel 注册到从 Reactor 上，从 Reactor 主要负责 Channel 生命周期内的所有 I/O 事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup)</span><br></pre></td></tr></table></figure>



<h4 id="Channel初始化"><a href="#Channel初始化" class="headerlink" title="Channel初始化"></a>Channel初始化</h4><h5 id="设置Channel类型"><a href="#设置Channel类型" class="headerlink" title="设置Channel类型"></a>设置Channel类型</h5><p>NIO 模型是 Netty 中最成熟且被广泛使用的模型。因此，推荐 Netty 服务端采用 NioServerSocketChannel 作为 Channel 的类型，客户端采用 NioSocketChannel。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b.channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>常用的 <strong>Channel 实现类</strong>有：</p>
<ul>
<li><strong>NioServerSocketChannel</strong> 异步 TCP 服务端。</li>
<li><strong>NioSocketChannel</strong> 异步 TCP 客户端。</li>
<li><strong>OioServerSocketChannel</strong> 同步 TCP 服务端。</li>
<li><strong>OioSocketChannel</strong> 同步 TCP 客户端。</li>
<li><strong>NioDatagramChannel</strong> 异步 UDP 连接。</li>
<li><strong>OioDatagramChannel</strong> 同步 UDP 连接。</li>
</ul>
<h5 id="注册ChannelHandler"><a href="#注册ChannelHandler" class="headerlink" title="注册ChannelHandler"></a>注册ChannelHandler</h5><p>在 Netty 中可以通过 ChannelPipeline 去注册多个 ChannelHandler，每个 ChannelHandler 各司其职。</p>
<p>引导器可以添加多个 ChannelHandler：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ChannelInitializer是实现了 ChannelHandler接口的匿名类，通过实例化 ChannelInitializer 作为 ServerBootstrap 的参数。</span></span><br><span class="line"><span class="comment">// Channel 初始化时都会绑定一个 Pipeline，它主要用于服务编排。Pipeline 管理了多个 ChannelHandler。I/O 事件依次在 ChannelHandler 中传播，ChannelHandler 负责业务逻辑处理。</span></span><br><span class="line">b.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">        ch.pipeline()</span><br><span class="line">                .addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpServerCodec()) <span class="comment">// Http编码器处理器</span></span><br><span class="line">                .addLast(<span class="string">"compressor"</span>, <span class="keyword">new</span> HttpContentCompressor())<span class="comment">// HTTPContent压缩处理器</span></span><br><span class="line">                .addLast(<span class="string">"aggregator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>)) <span class="comment">// 消息聚合处理器</span></span><br><span class="line">                .addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> HttpServerHandler());<span class="comment">// 自定义处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当服务端收到 HTTP 请求后，会<strong>依次</strong>经过 <strong>HTTP 编解码处理器</strong>、<strong>HTTPContent 压缩处理器</strong>、<strong>HTTP 消息聚合处理器、自定义业务逻辑处理器</strong>分别处理后，再将最终结果通过 HTTPContent 压缩处理器、HTTP 编解码处理器<strong>写回客户端</strong>。</p>
<h5 id="设置Channel参数"><a href="#设置Channel参数" class="headerlink" title="设置Channel参数"></a>设置Channel参数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>Netty 提供了十分便捷的方法，用于设置 Channel 参数，Netty 也提供了默认参数设置，实际场景下默认参数已经满足我们的需求，我们仅需要修改自己关系的参数即可。</p>
<ul>
<li><p><strong>ChannelOption.SO_KEEPALIVE</strong>：设置为 true 代表启用了 TCP SO_KEEPALIVE 属性，TCP 会主动探测连接状态，即连接保活</p>
</li>
<li><p><strong>ChannelOption.SO_BACKLOG</strong>：已完成三次握手的请求队列最大长度，同一时刻服务端可能会处理多个连接，在高并发海量连接的场景下，该参数应适当调大</p>
</li>
<li><p><strong>ChannelOption.TCP_NODELAY</strong>：Netty 默认是 true，表示立即发送数据。如果设置为 false 表示启用 Nagle 算法，该算法会将 TCP 网络数据包累积到一定量才会发送，虽然可以减少报文发送的数量，但是会造成一定的数据延迟。Netty 为了最小化数据传输的延迟，默认禁用了 Nagle 算法</p>
</li>
<li><p><strong>ChannelOption.SO_SNDBUF</strong>：TCP 数据发送缓冲区大小</p>
</li>
<li><p><strong>ChannelOption.SO_RCVBUF</strong>：TCP数据接收缓冲区大小，TCP数据接收缓冲区大小</p>
</li>
<li><p><strong>ChannelOption.SO_LINGER</strong>：设置延迟关闭的时间，等待缓冲区中的数据发送完成</p>
</li>
<li><p><strong>ChannelOption.CONNECT_TIMEOUT_MILLIS</strong>：建立连接的超时时间</p>
</li>
</ul>
<h5 id="端口绑定"><a href="#端口绑定" class="headerlink" title="端口绑定"></a>端口绑定</h5><p>完成上述 Netty 的配置之后，bind() 方法会真正触发启动，sync() 方法则会阻塞，直至整个启动过程完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture f = b.bind().sync();</span><br></pre></td></tr></table></figure>



<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>未完待续…</p>
<blockquote>
<p>笔记来源：若地 老师的《Netty核心原理剖析与RPC实践课程》</p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>Netty</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存（一）- 基础概念</title>
    <url>/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="缓存（一）-基础概念"><a href="#缓存（一）-基础概念" class="headerlink" title="缓存（一）- 基础概念"></a>缓存（一）- 基础概念</h1><ul>
<li><p>概念：缓存思想、优缺点、读写模式、缓存分类</p>
</li>
<li><p>缓存设计：组件选择、数据结构设计、数据分布设计、缓存架构部署及运维管理、设计考量点</p>
</li>
<li><p>缓存问题：缓存失效、缓存穿透、缓存雪崩、数据不一致、数据并发竞争、Hot key 、Big key 问题</p>
</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>缓存</strong>最初的含义，是指用于加速 <strong>CPU</strong> 数据交换的 <strong>RAM</strong>，即随机存取存储器，通常这种存储器使用更昂贵但快速的静态 <strong>RAM</strong>（<strong>SRAM</strong>）技术，用以对 <strong>DRAM</strong>进行加速。这是一个狭义缓存的定义。</p>
<p>而广义缓存的定义则更宽泛，<strong>任何可以用于数据高速交换的存储介质都是缓存</strong>，可以是硬件也可以是软件。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p><strong>缓存构建的基本思想</strong>是利用时间局限性原理，通过空间换时间来达到加速数据获取的目的，同时由于缓存空间的成本较高，在实际设计架构中还要考虑访问延迟和成本的权衡问题。</p>
<ul>
<li>时间局限性原理：即被获取过一次的数据在未来会被多次引用；</li>
<li>空间换时间：因为原始数据获取太慢，所以我们开辟一块高速独立空间，提供高效访问，来达到数据获取加速的目的；</li>
<li>性能成本：性能越高延迟越小，成本也会越高，所以在系统架构设计时，你需要在系统性能和开发运行成本之间做取舍。</li>
</ul>
<h4 id="优势与代价"><a href="#优势与代价" class="headerlink" title="优势与代价"></a>优势与代价</h4><p><strong>优点：</strong></p>
<ul>
<li><strong>提升访问性能</strong>：高速独立空间，提升访问效率。</li>
<li><strong>降低网络拥堵</strong>：在实际业务场景中，缓存中存储的往往是需要频繁访问的中间数据甚至最终结果，这些数据相比 DB 中的原始数据小很多，这样就可以减少网络流量，降低网络拥堵。</li>
<li><strong>减轻服务器负载</strong>：由于中间数据复用，减少了解析和计算，调用方和存储服务的负载也可以大幅降低。</li>
<li><strong>增强可扩展性</strong>：缓存的读写性能很高，预热快，在数据访问存在性能瓶颈或遇到突发流量，系统读写压力大增时，可以快速部署上线，同时在流量稳定后，也可以随时下线，从而使系统的可扩展性大大增强。</li>
</ul>
<p>任何事情都有两面性，缓存也不例外，我们在享受缓存带来一系列好处的同时，也注定需要付出一定的代价。</p>
<p><strong>代价</strong>：</p>
<ul>
<li><strong>增加系统复杂度</strong>：毫无疑问，引入缓存会增加系统复杂度，同时还面临许多新的问题，例如缓存不一致、缓存更新、缓存击穿、缓存雪崩等问题；</li>
<li><strong>费用成本高</strong>：缓存相比原始 <strong>DB</strong> 存储的成本更高，所以系统部署及运行的费用也会更高。</li>
<li><strong>学习投入</strong>：除了上面说的缓存一致性问题外，缓存体系本身也会存在可用性问题和分区的问题。这就需要我们加强对缓存原理、缓存组件以及优秀缓存体系实践的理解，从系统架构之初就对缓存进行良好设计，降低缓存引入的副作用。</li>
</ul>
<h4 id="缓存读写模式"><a href="#缓存读写模式" class="headerlink" title="缓存读写模式"></a>缓存读写模式</h4><p>业务系统读写缓存有 <strong>3 种</strong>模式：</p>
<ul>
<li><strong>Cache Aside</strong>（旁路缓存）</li>
<li><strong>Read/Write Through</strong>（读写穿透）</li>
<li><strong>Write Behind Caching</strong>（异步缓存写入）</li>
</ul>
<p><strong>Cache Aside</strong>（旁路缓存）</p>
<p><strong>Cache Aside</strong> 模式中，业务应用方对于写，是更新 <strong>DB</strong> 后，直接将 <strong>key</strong> 从 <strong>cache</strong> 中删除，然后由 <strong>DB</strong> 驱动缓存数据的更新（例如Trigger组件）；而对于读，是先读 <strong>cache</strong>，如果 <strong>cache</strong> 没有，则读 <strong>DB</strong>，同时将从 <strong>DB</strong> 中读取的数据回写到 <strong>cache</strong>。</p>
<p><img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/cache_02.png" alt="Cache Aside"></p>
<p><strong>特点：</strong></p>
<ul>
<li>适用于数据一致性要求比较高的业务；</li>
<li>适用于缓存更新比较复杂的业务；</li>
</ul>
<p><strong>Read/Write Through</strong>（读写穿透）</p>
<p>相对于 <strong>Cache Aside</strong> 模式，业务应用需要同时维护 <strong>cache</strong> 和 <strong>DB</strong> 两个数据存储方，过于繁琐，于是就有了 <strong>Read/Write Through</strong> 模式。</p>
<p>在这种模式下，业务应用<strong>只关注一个存储服务</strong>即可，业务方的读写 <strong>cache</strong> 和 <strong>DB</strong> 的操作，都由存储服务代理。存储服务收到业务应用的写请求时，会首先查 <strong>cache</strong>，如果数据在 <strong>cache</strong> 中不存在，则只更新 <strong>DB</strong>，如果数据在 <strong>cache</strong> 中存在，则先更新 <strong>cache</strong>，然后更新 <strong>DB</strong>。而存储服务收到读请求时，如果命中 <strong>cache</strong> 直接返回，否则先从 <strong>DB</strong> 加载，回种到 <strong>cache</strong> 后返回响应。</p>
<p><img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/cache_03.png" alt="Read/Write Throuth"></p>
<p><strong>特点：</strong></p>
<ul>
<li><p>存储服务封装了所有的数据处理细节，业务应用端代码只用关注业务逻辑本身，系统的隔离性更佳。</p>
</li>
<li><p>进行写操作时，如果 cache 中没有数据则不更新，有缓存数据才更新，内存效率更高。</p>
</li>
</ul>
<p><strong>Write Behind Caching</strong>（异步缓存写入）</p>
<p><strong>Write Behind Caching</strong> 模式与 <strong>Read/Write Through</strong> 模式类似，也由数据存储服务来管理 <strong>cache</strong> 和 <strong>DB</strong> 的读写。不同点是，数据更新时，<strong>Read/write Through</strong> 是<strong>同步更新</strong> <strong>cache</strong> 和 <strong>DB</strong>，而 <strong>Write Behind Caching</strong> 则是<strong>只更新缓存，不直接更新 DB</strong>，而是改为<strong>异步</strong>批量的方式来更新 <strong>DB</strong>。</p>
<p><img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/cache_04.png" alt="Write Behind Caching"></p>
<p><strong>特点：</strong></p>
<ul>
<li><p>数据存储的写性能最高，非常适合一些变更特别频繁的业务；</p>
</li>
<li><p>非常适合<strong>合并写</strong>请求的业务，比如对一些计数业务，一条 Feed 被点赞 1万 次，如果更新 1万 次 DB 代价很大，而合并成一次请求直接加 1万，则是一个非常轻量的操作；</p>
</li>
<li><p>缺点是数据一致性变差，<strong>DB</strong>如果更新不成功可能会有数据丢失。</p>
</li>
</ul>
<h3 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h3><h4 id="宿主层次分类"><a href="#宿主层次分类" class="headerlink" title="宿主层次分类"></a>宿主层次分类</h4><ul>
<li><strong>本地缓存：</strong>是指业务进程内的缓存，这类缓存由于在业务系统进程内，所以读写性能超高且无任何网络开销，但不足是会随着业务系统重启而丢失</li>
<li><strong>进程间缓存</strong>：是本机独立运行的缓存，这类缓存读写性能较高，不会随着业务系统重启丢数据，并且可以大幅减少网络开销，但不足是业务系统和缓存都在相同宿主机，运维复杂，且存在资源竞争，受宿主机资源限制。</li>
<li><strong>远程缓存</strong>：指跨机器部署的缓存，这类缓存因为独立设备部署，容量大且易扩展，在互联网企业使用最广泛。不过远程缓存需要跨机访问，在高读写压力下，带宽容易成为瓶颈。例如分布式缓存。</li>
</ul>
<h4 id="存储介质分类"><a href="#存储介质分类" class="headerlink" title="存储介质分类"></a>存储介质分类</h4><ul>
<li><strong>内存型缓存</strong>：将数据存储在内存，读写性能很高，但缓存系统重启或 <strong>Crash</strong> 后，内存数据会丢失；</li>
<li><strong>持久化型缓存</strong>：将数据存储到 <strong>SSD/Fusion-IO</strong> 硬盘中，相同成本下，这种缓存的容量会比内存型缓存大 1 个数量级以上，而且数据会持久化落地，重启不丢失，但读写性能相对低 1～2 个数量级。<strong>Memcached</strong> 是典型的内存型缓存。</li>
</ul>
<h3 id="缓存设计考虑因素"><a href="#缓存设计考虑因素" class="headerlink" title="缓存设计考虑因素"></a>缓存设计考虑因素</h3><h4 id="缓存组件选择"><a href="#缓存组件选择" class="headerlink" title="缓存组件选择"></a><strong>缓存组件选择</strong></h4><p>在设计架构缓存时，你首先要选定缓存组件，比如要用 <strong>Local-Cache</strong>，还是 <strong>Redis</strong>、<strong>Memcached</strong>、<strong>Pika</strong> 等开源缓存组件，需要根据业务需求做出相应选择。</p>
<h4 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a><strong>数据结构设计</strong></h4><p>对于直接简单 <strong>KV</strong> 读写的业务，你可以将这些业务数据封装为 <strong>String</strong>、<strong>Json</strong>、<strong>Protocol Buffer</strong> 等格式，序列化成字节序列，然后直接写入缓存中。读取时，先从缓存组件获取到数据的字节序列，再进行反序列化操作即可。</p>
<p>对于只需要存取部分字段或需要在缓存端进行计算的业务，你可以把数据设计为 <strong>Hash</strong>、<strong>Set</strong>、<strong>List</strong>、<strong>Geo</strong> 等结构，存储到支持复杂集合数据类型的缓存中，如 <strong>Redis</strong>、<strong>Pika</strong> 等。</p>
<h4 id="数据分布设计"><a href="#数据分布设计" class="headerlink" title="数据分布设计"></a><strong>数据分布设计</strong></h4><ul>
<li><strong>确认数据分布算法</strong>，例如<strong>取模</strong>或者<strong>一致性hash</strong>分布。取模分布的方案简单，每个 key 只会存在确定的缓存节点，一致性 Hash 分布的方案相对复杂，一个 key 对应的缓存节点不确定。但一致性 Hash 分布，可以在部分缓存节点异常时，将失效节点的数据访问均衡分散到其他正常存活的节点，从而更好地保证了缓存系统的稳定性。</li>
<li><strong>分布读写访问方式</strong>，一种是由缓存 <strong>Client</strong> 直接进行 <strong>Hash</strong> 分布定位读写，另一种是通过 Proxy 代理来进行读写路由。前者是Client 直接读写，读写性能最佳，但需要 Client 感知分布策略。在缓存部署发生在线变化时，也需要及时通知所有缓存 Client，对业务系统侵入较强；后者通过 Proxy 路由，Client 只需直接访问 Proxy，分布逻辑及部署变更都由 Proxy 来处理，对业务应用开发最友好，但业务访问多一跳，访问性能会有一定的损失。</li>
<li><strong>缓存节点动态拆分</strong>，缓存系统运行过程中，如果待缓存的数据量增长过快，会导致大量缓存数据被剔除，缓存命中率会下降，数据访问性能会随之降低，这样就需要将数据从缓存节点进行动态拆分，把部分数据水平迁移到其他缓存节点。这个迁移过程需要考虑，是由 Proxy 进行迁移还是缓存 Server 自身进行迁移，甚至根本就不支持迁移。</li>
</ul>
<h4 id="缓存架构部署及运维管理"><a href="#缓存架构部署及运维管理" class="headerlink" title="缓存架构部署及运维管理"></a><strong>缓存架构部署及运维管理</strong></h4><ul>
<li><strong>分池：</strong>核心的、高并发访问的不同数据，需要分别分拆到独立的缓存池中，进行分别访问，避免相互影响；访问量较小、非核心的业务数据，则可以混存；</li>
<li><strong>分层：</strong>对海量数据、访问超过 10～100万 级的业务数据，要考虑分层访问，并且要分摊访问量，避免缓存过载。</li>
<li><strong>跨IDC部署</strong>：由于实际场景下，业务系统可能需要多IDC（互联网数据中心）部署，则需要对缓存体系也进行多 IDC 部署，跨 IDC 缓存数据更新，可以采用直接跨 IDC 读写，也可以采用 DataBus 配合队列机进行不同 IDC 的消息同步，然后由消息处理机进行缓存更新，还可以由各个 IDC 的 DB Trigger 进行缓存更新。</li>
</ul>
<h4 id="常见考量点"><a href="#常见考量点" class="headerlink" title="常见考量点"></a><strong>常见考量点</strong></h4><ul>
<li><p><strong>读写方式</strong>：全部读写，还是部分读写，或者缓存服务器负责部分计算等；</p>
</li>
<li><p><strong>KV size</strong>：单个业务的 <strong>KV size</strong> 过大，需要分拆成多个 <strong>KV</strong> 来缓存；不同缓存数据的 <strong>KV size</strong> 如果差异过大，也不能缓存在一起，避免缓存效率的低下和相互影响。</p>
</li>
<li><p><strong>key 数量</strong>：<strong>key</strong>数量不大，则缓存全量数据，不存在也不需要再查数据库；<strong>key</strong> 数量较大，则冷热数据分离，缓存中尽可能只保留频繁访问的热数据，对于冷数据直接访问 <strong>DB</strong>。</p>
</li>
<li><p><strong>读写峰值</strong>：峰值过大，如果小于 10万 级别，简单分拆到独立 Cache 池即可；超过 10万 甚至到达 100万 级的QPS，则需要对 Cache 进行分层处理，可以同时使用 Local-Cache 配合远程 cache，甚至远程缓存内部继续分层叠加分池进行处理。</p>
</li>
<li><p><strong>命中率</strong>：缓存的命中率对整个服务体系的性能影响甚大。对于核心高并发访问的业务，需要预留足够的容量，确保核心业务缓存维持较高的命中率。为了持续保持缓存的命中率，缓存体系需要持续监控，及时进行故障处理或故障转移。同时在部分缓存节点异常、命中率下降时，故障转移方案，需要考虑是采用一致性 <strong>Hash</strong> 分布的访问漂移策略，还是采用数据多层备份策略。</p>
</li>
<li><p><strong>淘汰策略：</strong></p>
<ul>
<li><strong>FIFO</strong>: 先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用FIFO,使最先进入的数据(最晚的数据)被淘汰。</li>
<li><strong>LFU</strong>: 最少使用策略：<br>无论是否过期，根据元素被使用次数判断，清除使用次数较少的元素释放空间。算法主要比较元素的hitcount(命中次数)，在保证高频数据有效性的场景下，可是使用这类策略。</li>
<li><strong>LRU</strong>(Least Recently Used): 最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次访问时间举例现在最远的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</li>
<li>根据过期时间判断，清理过期时间最长的元素；（可以使用较短过期时间或者key 带时间戳的方式）</li>
<li>根据过期时间判断，清理最近要过期的元素；</li>
<li>随机清理；</li>
</ul>
</li>
<li><p><strong>缓存可以运维性</strong>：对于缓存的可运维性考虑，则需要考虑缓存体系的集群管理，如何进行一键扩缩容，如何进行缓存组件的升级和变更，如何快速发现并定位问题，如何持续监控报警，最好有一个完善的运维平台，将各种运维工具进行集成。</p>
</li>
<li><p><strong>缓存安全性</strong>：对于缓存的安全性考虑，一方面可以限制来源 IP，只允许内网访问，同时对于一些关键性指令，需要增加访问权限，避免被攻击或误操作时，导致重大后果。</p>
</li>
</ul>
<h3 id="缓存常见问题"><a href="#缓存常见问题" class="headerlink" title="缓存常见问题"></a>缓存常见问题</h3><p>缓存常见七大问题：</p>
<ul>
<li>缓存失效</li>
<li>缓存穿透</li>
<li>缓存雪崩</li>
<li>数据一致性</li>
<li>数据并发竞争</li>
<li>Hot Key</li>
<li>Big Key</li>
</ul>
<h4 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h4><p><strong>问题描述：</strong>大量缓存同时失效（DB批量更新缓存，设置相同过期时间），查询穿透到DB，DB短时间内查询量过大，导致性能问题。</p>
<p><strong>解决方案：</strong>将过期时间设置为：<strong>过期时间 = baes 时间 + 随机时间</strong>，即相同业务数据写缓存时，在基础过期时间之上，再加一个随机的过期时间，让数据在未来一段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过大压力。</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p><strong>问题描述</strong>：批量查询一个不存在的<strong>key</strong>，导致每次查询都会穿透到 <strong>DB</strong>，<strong>DB</strong>压力过大，影响正常服务。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>缓存非法key</strong>：查询这些不存在的数据时，第一次查 DB，虽然没查到结果返回 NULL，仍然记录这个 key 到缓存，只是这个 key 对应的 value 是一个特殊设置的值。但是如果不存在的 key 数量过多，会占用大量缓存空间，可以设置较短的过期时间，防止非法 key 占用过多缓存空间；也可以设立独立缓存空间存储非法key，从缓存查找时，先查正常的缓存组件，如果 miss，则查一下公共的非法 key 的缓存，如果后者命中，直接返回，否则穿透 DB，如果查出来是空，则回种到非法 key 缓存，否则回种到正常缓存。</li>
<li><strong>布隆过滤器（BloomFilter）</strong>：构建一个 BloomFilter 缓存过滤器，访问数据时，可以直接通过 BloomFilter 判断这个 key 是否存在，如果不存在直接返回即可，根本无需查缓存和 DB。BloomFilter 可以缓存全量数据key，但是数量不宜过多，也可以用来缓存非法key集合，但是累计非法 key 数量会持续增长，可以用过设置过期时间定期清理。</li>
</ul>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h4><p><strong>问题描述</strong>： 缓存雪崩是指部分缓存节点不可用，导致整个缓存体系甚至甚至服务系统不可用的情况。</p>
<ul>
<li><strong>缓存节点不支持 rehash</strong>，较多缓存节点不可用时，大量 Cache 访问会失败，根据缓存读写模型，这些请求会进一步访问 DB，造成 DB 过载，大量慢查询，最终阻塞甚至 Crash，从而导致服务异常。</li>
<li><strong>缓存节点支持 rehash</strong>，一致性 Hash 分布方式中，在部分节点异常时，采用 rehash 策略，即把异常节点请求平均分散到其他缓存节点。但在较大的流量洪峰到临之时，如果大流量 key 比较集中，正好在某 1～2 个缓存节点，很容易将这些缓存节点的内存、网卡过载，缓存节点异常 Crash，然后这些异常节点下线，这些大流量 key 请求又被 rehash 到其他缓存节点，进而导致其他缓存节点也被过载 Crash，缓存异常持续扩散，最终导致整个缓存体系异常，无法对外提供服务。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>针对 DB 增加读写开关，当发现 DB 请求变慢、阻塞，慢请求超过阀值时，就会关闭读开关，部分或所有读 DB 的请求进行 failfast 立即返回，待 DB 恢复后再打开读开关；</li>
<li>增加缓存副本，缓存异常或请求 miss 后，再读取其他缓存副本，而且多个缓存副本尽量部署在不同机架，从而确保在任何情况下，缓存系统都会正常对外提供服务；</li>
<li>对缓存体系进行实时监控，当请求访问的慢速比超过阀值时，及时报警，通过机器替换、服务替换进行及时恢复；也可以通过各种自动故障转移策略，自动关闭异常接口、停止边缘服务、停止部分非核心功能措施，确保在极端场景下，核心功能的正常运行。</li>
</ul>
<h4 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h4><p><strong>问题描述</strong>：DB 和 缓存数据不一致（缓存更新异常，缓存多次rehash 也可能导致节点脏数据）。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>cache 更新失败后，可以进行重试，如果重试失败，则将失败的 key 写入队列机服务，待缓存访问恢复后，将这些 key 从缓存删除。这些 key 在再次被查询时，重新从 DB 加载，从而保证数据的一致性。</li>
<li>缓存时间适当调短，让缓存数据及早过期后，然后从 DB 重新加载，确保数据的最终一致性。</li>
<li>不采用 rehash 漂移策略，而采用缓存分层策略，尽量避免脏数据产生。</li>
</ul>
<h4 id="数据并发竞争"><a href="#数据并发竞争" class="headerlink" title="数据并发竞争"></a>数据并发竞争</h4><p><strong>问题描述</strong>：是指在高并发访问场景，一旦缓存访问没有找到数据，大量请求就会并发查询 DB，导致 DB 压力大增的现象。主要是由于多个进程/线程中，有大量并发请求获取相同的数据，而这个数据 key 因为正好过期、被剔除等各种原因在缓存中不存在，这些进程/线程之间没有任何协调，然后一起并发查询 DB，请求那个相同的 key，最终导致 DB 压力大增。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>加全局锁</strong>：当缓存请求 miss 后，先尝试加全局锁，只有加全局锁成功的线程，才可以到 DB 去加载数据。其他进程/线程在读取缓存数据 miss 时，如果发现这个 key 有全局锁，就进行等待，待之前的线程将数据从 DB 回种到缓存后，再从缓存获取。</li>
<li><strong>增加缓存备份</strong>：对缓存数据保持多个备份，即便其中一个备份中的数据过期或被剔除了，还可以访问其他备份。</li>
</ul>
<h4 id="Hot-key"><a href="#Hot-key" class="headerlink" title="Hot key"></a>Hot key</h4><p><strong>问题描述</strong>：大多数互联网系统，数据是分冷热的，当超大量的请求同时访问热点数据对应的缓存节点（比如微博热点新闻），缓存机器很容易被打到物理网卡、带宽、CPU 的极限，从而导致缓存访问变慢、卡顿。</p>
<p><strong>解决方案</strong>：</p>
<p><strong>Hot key</strong> 问题的关键是先找到 <strong>Hot key</strong> ，然后对 <strong>Hot key</strong> 进行分散处理，可以被分散为 hotkey#1、hotkey#2、hotkey#3，……hotkey#n，这 n 个 key 分散存在多个缓存节点，然后 client 端请求时，随机访问其中某个后缀的 hotkey，这样就可以把热 key 的请求打散，避免一个缓存节点过载。</p>
<p>根据现实场景，<strong>Hot key</strong> 可以分为 <strong>可以预知的Hot key</strong>（例如重要节假日、线上促销活动等） ，和 <strong>突发的Hot key</strong> （例如突发事件）</p>
<ul>
<li>对于可预知的 Hot key ，可以提前部署，对 Hot key 缓存分散处理。</li>
<li>对于不可预知的Hot key，可以通过 Spark，对应流任务进行实时分析，及时发现新发布的热点 key。</li>
</ul>
<h4 id="Big-key"><a href="#Big-key" class="headerlink" title="Big key"></a>Big key</h4><p><strong>问题描述</strong>：大 key，是指在缓存访问时，部分 Key 的 Value 过大，读写、加载易超时的现象。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>压缩，阈值预警，当 value 的长度超过阀值，则对内容启用压缩。</li>
<li>大 key 拆分，尽量减少大 key 的存在。</li>
<li>尽量不淘汰：由于大 key 一旦穿透到 DB，加载耗时很大，所以可以对这些大 key 进行特殊照顾，比如设置较长的过期时间，比如缓存内部在淘汰 key 时，同等条件下，尽量不淘汰这些大 key。</li>
</ul>
<blockquote>
<p>笔记来源：陈波 老师的 《300分钟吃透分布式缓存》课程</p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存（二）- Memcached</title>
    <url>/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%BA%8C%EF%BC%89-Memcached/</url>
    <content><![CDATA[<h1 id="缓存（二）-Memcached"><a href="#缓存（二）-Memcached" class="headerlink" title="缓存（二）- Memcached"></a>缓存（二）- Memcached</h1><ul>
<li>特点：高性能、多线程、异步IO、KV存储、没有持久化</li>
<li>系统架构：多线程网络模型、哈希表、LRU、slab内存管理</li>
<li>基于libevent的多线程网络模型：主线程与工作线程分工</li>
<li>哈希表：原理，哈希扩容、哈希冲突</li>
<li>LRU淘汰策略：失效、删除</li>
<li>Slab内存管理机制：结构、内存分配流程</li>
<li>Mc协议指令：常见指令</li>
<li>Mc 常见问题及解决方案：Mc常用架构</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Memcached 是一个高性能、分布式内存对象缓存系统，本质上是通用的，但目的是为了通过减轻数据库负载来加快动态网络应用的速度。</p>
<p>Memcached 是一个内存键值存储，用于存储来自数据库调用、API调用或页面渲染结果的小块任意数据（字符串、对象）。</p>
<p>Memcached 简单而强大。它简单的设计促进了快速部署，易于开发，并解决了大型数据缓存所面临的许多问题。其API可用于大多数流行的语言。</p>
<p>– 引自网络</p>
</blockquote>
<p><strong>Memcached</strong> 简称 <strong>Mc</strong>，特性有：</p>
<ul>
<li>是一个典型的<strong>内存型缓存组件</strong>，这就意味着：<ul>
<li>Mc 一旦重启就会丢失所有的数据。</li>
<li><strong>高性能</strong>，单节点压测性能能达到<strong>百万级的 QPS</strong>。</li>
</ul>
</li>
<li>Mc 采用<strong>多线程处理请求，由一个主线程和任意多个工作线程协作，从而充分利用多核，提升 IO 效率</strong>。</li>
<li>Mc 的<strong>访问协议很简单</strong>，只 有 get/set/cas/touch/gat/stats 等有限的几个命令。这跟它的存储结构也有关系。</li>
<li>Mc 的<strong>存储结构也很简单</strong>，只存储简单的 key/value 键值对，而且对 value 直接以<strong>二进制方式存储</strong>，不识别内部存储结构。</li>
<li>Mc的<strong>服务节点运行简单</strong>，不同 Mc 节点之间互不通信，由 client 自行负责管理数据分布（由 client 对 key 进行 Hash 后分布和协同）。</li>
</ul>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%BA%8C%EF%BC%89-Memcached/cache_05.png" alt="Memcached系统架构" style="zoom:80%;">

<p>Mc 的系统架构主要包括：</p>
<ul>
<li><strong>网络处理模块</strong>；</li>
<li><strong>多线程处理模块</strong>；</li>
<li><strong>哈希表</strong>；</li>
<li><strong>淘汰策略：LRU</strong>；</li>
<li><strong>slab 内存分配模块</strong> 。</li>
</ul>
<p>接下来我们分别了解各个模块。</p>
<h3 id="基于libevent的多线程网络IO模型"><a href="#基于libevent的多线程网络IO模型" class="headerlink" title="基于libevent的多线程网络IO模型"></a>基于libevent的多线程网络IO模型</h3><p>Mc 基于 <strong>Libevent</strong> 实现<strong>多线程网络 IO 模型</strong>。Mc 的 <strong>IO 处理线程分主线程和工作线程</strong>，每个线程各有一个 event_base，来监听网络事件。</p>
<ul>
<li><strong>主线程</strong>：负责监听及建立连接。</li>
<li><strong>工作线程</strong>：负责对建立的连接进行网络 IO 读取、命令解析、处理及响应。</li>
</ul>
<p><strong>作业流程：</strong></p>
<p>Mc 主线程在监听端口时，当有连接到来，<strong>主线程 accept 该连接</strong>，并将连接调度给工作线程。调度处理逻辑：主线程先<strong>将 fd 封装成一个 CQ_ITEM 结构，并存入新连接队列中，然后轮询一个工作线程，并通过管道向该工作线程发送通知。</strong>主线程的这个处理逻辑主要在<strong>状态机</strong>中执行，对应的连接状态为 <strong>conn_listening</strong>。</p>
<p>工作线程监听到主线程的管道通知后，会从连接队列弹出一个新连接，然后就会创建一个 <strong>conn</strong> 结构体，注册该 <strong>conn</strong> 读事件，然后继续监听该连接上的 IO 事件。后续这个连接有命令进来时，工作线程会读取 <strong>client</strong> 发来的命令，进行解析并处理，最后返回响应。工作线程的主要处理逻辑也是在<strong>状态机</strong>中。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%BA%8C%EF%BC%89-Memcached/cache_06.png" alt="IO工作流程" style="zoom:67%;">

<p><strong>状态机</strong></p>
<p>上面说到的<strong>状态机</strong>是由<strong>主线程和工作线程共享</strong>，实际是采用 <strong>switch-case</strong> 来实现的。switch 连接的 state，然后<strong>根据连接的不同状态，执行不同的逻辑操作</strong>，并进行状态转换。</p>
<p><img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%BA%8C%EF%BC%89-Memcached/cache_07.png" alt="状态机"></p>
<p><strong>主线程在状态机中只处理 conn_listening 状态，负责 accept 新连接和调度新连接给工作线程。状态机中其他状态处理基本都在工作线程中进行。</strong></p>
<p><strong>工作线程的状态机处理逻辑</strong>，包括刚建立 conn 连接结构体时进行的一些<strong>重置操作</strong>，然后<strong>注册读事件</strong>，在有数据进来时，<strong>读取网络数据</strong>，并进行<strong>解析并处理</strong>。如果是读取指令或统计指令，至此就基本处理完毕，接下来将响应写入连接缓冲。如果是更新指令，在进行初步处理后，还会继续<strong>读取 value 部分</strong>，再进行<strong>存储或变更</strong>，待变更完毕后<strong>将响应写入连接缓冲</strong>。最后<strong>再将响应写给 client</strong>。响应 client 后，连接会再次<strong>重置连接状态</strong>，等待<strong>进入下一次的命令处理循环</strong>中。</p>
<p><strong>工作线程状态事件及处理逻辑详解</strong>：</p>
<ul>
<li><p><strong>conn_new_cmd</strong>：主线程通过调用 <strong>dispatch_conn_new</strong>，把新连接调度给工作线程后，<strong>worker</strong> 线程创建 <strong>conn</strong> 对象，这个连接初始状态就是 <strong>conn_new_cmd</strong>。除了通过新建连接进入 <strong>conn_new_cmd</strong> 状态之外，如果连接命令处理完毕，准备接受新指令时，也会将连接的状态设置为 <strong>conn_new_cmd</strong> 状态。 </p>
</li>
<li><p><strong>conn_parse_cmd</strong>：工作线程处理完 <strong>conn_new_cmd</strong> 状态的主要逻辑后，如果读缓冲区有数据可以读取，则进入 <strong>conn_parse_cmd</strong> 状态，否则就会进入到 <strong>conn_waiting</strong> 状态，等待网络数据进来。</p>
</li>
<li><p><strong>conn_waiting</strong>：连接进入 conn_waiting 状态后，处理逻辑很简单，直接通过 update_event 函数注册读事件即可，之后会将连接状态更新为 conn_read。</p>
</li>
<li><p><strong>conn_read</strong>：当工作线程监听到网络数据进来，连接就进入 conn_read 状态。对 conn_read 的处理，是通过 try_read_network 从 socket 中读取网络数据。如果读取失败，则进入 conn_closing 状态，关闭连接。如果没有读取到任何数据，则会返回 conn_waiting，继续等待 client 端的数据到来。如果读取数据成功，则会将读取的数据存入 conn 的 rbuf 缓冲，并进入 conn_parse_cmd 状态，准备解析 cmd。</p>
</li>
<li><p><strong>conn_parse_cmd</strong>：conn_parse_cmd 状态的处理逻辑就是解析命令。工作线程首先通过 try_read_command 读取连接的读缓冲，并通过 \n 来分隔数据报文的命令。如果命令首行长度大于 1024，关闭连接，这就意味着 key 长度加上其他各项命令字段的总长度要小于 1024字节。当然对于 key，Mc 有个默认的最大长度，key_max_length，默认设置为 250字节。校验完毕首行报文的长度，接下来会在 process_command 函数中对首行指令进行处理。 process_command 用来处理 Mc 的所有协议指令，所以这个函数非常重要。process_command 会首先按照空格分拆报文，确定命令协议类型，分派给 process_XX_command 函数处理。 Mc 的命令协议从直观逻辑上可以分为获取类型、变更类型、其他类型。但从实际处理层面区分，则可以细分为 get 类型、update 类型、delete 类型、算术类型、touch 类型、stats 类型，以及其他类型。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%BA%8C%EF%BC%89-Memcached/cache_08.png" alt="命令协议" style="zoom:50%;">

<p>注意 conn_parse_cmd 的状态处理，只有读取到 \n，有了完整的命令首行协议，才会进入 process_command，否则会跳转到 conn_waiting，继续等待客户端的命令数据报文。在 process_command 处理中，如果是获取类命令，在获取到 key 对应的 value 后，则跳转到 conn_mwrite，准备写响应给连接缓冲。而对于 update 变更类型的指令，则需要继续读取 value 数据，此时连接会跳转到 conn_nread 状态。在 conn_parse_cmd 处理过程中，如果遇到任何失败，都会跳转到 conn_closing 关闭连接。</p>
</li>
<li><p><strong>complete_nread</strong>：对于 update 类型的协议指令，从 conn 继续读取 value 数据。读取到 value 数据后，会调用 complete_nread，进行数据存储处理；数据处理完毕后，向 conn 的 wbuf 写响应结果。然后 update 类型处理的连接进入到 conn_write 状态。</p>
</li>
<li><p><strong>conn_write</strong>：连接 conn_write 状态处理逻辑很简单，直接进入 conn_mwrite 状态。或者当 conn 的 iovused 为 0 或对于 udp 协议，将响应写入 conn 消息缓冲后，再进入 conn_mwrite 状态。</p>
</li>
<li><p><strong>conn_mwrite</strong>：进入 conn_mwrite 状态后，工作线程将通过 transmit 来向客户端写数据。如果写数据失败，跳转到 conn_closing，关闭连接退出状态机。如果写数据成功，则跳转到 conn_new_cmd，准备下一次新指令的获取。</p>
</li>
<li><p><strong>conn_closing</strong>：最后一个 conn_closing 状态，前面提到过很多次，在任何状态的处理过程中，如果出现异常，就会进入到这个状态，关闭连接，这个连接也就 Game Over了。</p>
</li>
</ul>
<p>总结Mc 对<strong>命令的处理全过程</strong>：</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%BA%8C%EF%BC%89-Memcached/cache_09.png" alt="Mc命令处理全流程" style="zoom:67%;">



<h3 id="LRU淘汰策略"><a href="#LRU淘汰策略" class="headerlink" title="LRU淘汰策略"></a>LRU淘汰策略</h3><p>Mc 作为缓存组件，意味着 Mc 中只能存储访问最频繁的热数据，一旦存入数据超过内存限制，就需要对 Mc 中的冷 key 进行淘汰工作。</p>
<p>Mc 中的 key 基本都会有过期时间，在 key 过期后，出于性能考虑，<strong>Mc 并不会立即删除过期的 key，而是由维护线程逐步清理，只有这个失效的 key 被访问时，才会进行删除，从而回收存储空间</strong>。</p>
<p>所以Mc的内存回收工作分为俩阶段：<strong>失效 和 删除</strong></p>
<h4 id="失效"><a href="#失效" class="headerlink" title="失效"></a><strong>失效</strong></h4><p><strong>失效方式分为俩种</strong>：</p>
<ul>
<li><p><strong>过期失效</strong>：指 key 在 expire 时间之后的过期</p>
</li>
<li><p><strong>flush_all 失效</strong>：如果缓存数据写入异常，出现大量脏数据，而又没有简单的办法快速找出所有的脏数据，可以用 flush_all <strong>立即让所有数据失效</strong>，通过 key 重新从 DB 加载的方式来保证数据的正确性。</p>
<p>该指令也可以通过 flush_all 指令后面加一个 expiretime 参数，可以让多个 Mc 在<strong>某个时间同时失效</strong>所有的 key。也可以将全局 setting 中的 oldest_live 设为指定 N 秒后的时间戳，即 N 秒后失效（<strong>延迟失效</strong>）；</p>
</li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><strong>删除分为三种</strong>：</p>
<ul>
<li><p><strong>惰性删除</strong>：失效的 key 被访问时，才会进行删除，从而回收存储空间。</p>
</li>
<li><p><strong>内存分配失败，LRU 同步淘汰</strong>：当需要对 Item 进行<strong>内存分配申请时，如果内存已全部用完</strong>，且该 Item 对应的slabclass 没有空闲的 chunk 可用，申请失败，则会对 LRU 队尾进行同步扫描，回收过期失效的 key，如果没有失效的 key，则会强制删除一个 key。</p>
</li>
<li><p>LRU 维护线程<strong>异步删除</strong>：不定期扫描 4 个 LRU 队列，对过期 key/value 进行异步淘汰。</p>
<p>在 key 进行读取、插入或变更时，<strong>同步进行 key 淘汰回收</strong>，并不是一种高效的办法，因为淘汰回收操作相比请求处理，也是一个重量级操作，<strong>会导致 Mc 性能大幅下降</strong>。因此 Mc 额外增加了一个 LRU 维护线程，对过期失效 key 进行回收。</p>
</li>
</ul>
<p>前面讲到，Mc 有 64 个 slabclass，其中 1-63 号 slabclass 用于存取 Item 数据。实际上，为了管理过期失效数据，<strong>1-63 号 slabclass 还分别对应了 4 个 LRU（双向链表），分布是 TEMP、HOT、WARM、COLD LRU。所以这就总共有 63*4 = 252 个 LRU。LRU 维护线程，会按策略间断 sleep，待 sleep 结束，就开始对 4 个 LRU 进行队尾清理工作。</strong></p>
<p><strong>四种 LRU 回收和迁移的要点如下：</strong></p>
<ul>
<li>Mc 在新写入 key 时，如果 key 的过期时间小于 61s，就会直接插入到 TEMP LRU 中，大于61s，就会直接插入到 HOT LRU。</li>
<li>LRU 维护线程处理时，TEMP LRU 是在独立循环中进行，其他三个 LRU 在另外一个循环中进行，如果 HOT、WARM、COLD LRU 清理或移动的 keys 数为 0，则那个 500 次的大循环就立即停止。</li>
<li>TEMP LRU 没有长度限制，且不进行队列内部的搬运和队列间的迁移，确保处理性能。</li>
<li><strong>TEMP LRU 回收</strong>：首先会对 TEMP LRU 队尾进行 500 次轮询，然后在每次轮询时，会进行 5 次小循环。小循环时，首先检查 key是否过期失效，如果失效则进行回收淘汰，然后继续小循环；如果遇到一个没失效的 key，则回收该 key 并退出 TEMP LRU 的清理工作。如果 TEMP LRU 队尾 key 全部失效，维护线程一次可以回收 500*5 共 2500 个失效的 key。</li>
<li><strong>HOT LRU 回收</strong>：同样500次大循环，5次小循环，遇到<ul>
<li>失效key则回收</li>
<li>非失效key,如果key状态是<ul>
<li>ACTIVE，则迁移至<strong>WARM LRU</strong></li>
<li>非 ACTIVE，如果 HOT LRU <strong>内存占用超过限制</strong>，则迁移到 <strong>COLD LRU</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>WARN LRU 回收</strong>：前提是 HOT LRU 中回收和迁移的 keys 数为 0才会进行， 同样500次大循环，5次小循环，遇到<ul>
<li>失效key则回收</li>
<li>非失效key,如果key状态是<ul>
<li>ACTIVE，则迁移至 <strong>LRU 头部</strong></li>
<li>非 ACTIVE，如果 WARN LRU <strong>内存占用超过限制</strong>，则迁移到 <strong>COLD LRU</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>COLD LRU 回收</strong>：前提是 WARN LRU 中回收和迁移的 keys 数为 0才会进行， 同样500次大循环，5次小循环，遇到<ul>
<li>失效key则回收</li>
<li>非失效key,如果key状态是<ul>
<li>ACTIVE，则迁移至 <strong>WARN LRU 头部</strong></li>
<li>非 ACTIVE，不处理，直接返回</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="slab内存管理机制"><a href="#slab内存管理机制" class="headerlink" title="slab内存管理机制"></a>slab内存管理机制</h3><p>Mc 内存分配采用 slab 机制，slab 机制可以规避内存碎片，是 Mc 能持续高性能进行数据读写的关键。</p>
<p>Mc 在启动时，会构建长度为 64 的 slabclass 数组，其中 0 号 slabclass 用于 slab 的重新分配，1~63 号 slabclass 存储数据 Item。</p>
<ul>
<li><p>Mc 在分配内存时，<strong>先将内存按固定大小划分成 slab，然后再将不同 slab 分拆出固定 size 的 chunk。</strong>虽然 slab 内的 chunk 大小相同，但不同 slab 的 chunk size 并不同，Mc 会按照一个固定比例，使划分的 chunk size 逐步增大，从而满足不同大小 key/value 存储的需要。</p>
</li>
<li><p><strong>一组具有相同 chunk size 的所有 slab，就组成一个 slabclass</strong>。不同 slabclass 的 chunk size 按递增因子一次增加。Mc 就通过 slabclass 来管理一组 slab 内的存储空间的。最后一个 slabclass（即 63 号 slabclass）的 chunk size 会直接设为最大的 chunk size，默认是 0.5MB。</p>
</li>
<li><p><strong>每个 slabclass 内部有一个 freelist</strong> ，包含这组 slab 里所有空闲的 chunk，当需要存储数据时，从这个 freelist 里面快速分配一个 chunk 做存储空间。当 Item 数据淘汰剔除时，这个 Item 所在的 chunk 又被回收至这个 freelist。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%BA%8C%EF%BC%89-Memcached/cache_11.png" alt="slabclass结构" style="zoom:67%;">
</li>
<li><p>当需要空间分配时，<strong>如果 Mc 有空闲空间，则从 slabclass 的 freelist 分配；如果没有空闲空间，则从对应 slabclass id 对应的 LRU 中剔除一个 Item，来复用这个 Item 的空间</strong>。</p>
</li>
<li><p>在查找或变更一个 key 时，首先要定位这个 key 所在的存储位置。<strong>Mc 是通过哈希表 Hashtable 来定位 key 的</strong>。</p>
</li>
<li><p>Mc 内部是<strong>通过 LRU 来管理存储 Item 数据</strong>的，当内存不足时，会从 LRU 队尾中剔除一个过期或最不活跃的 key，供新的 Item 使用。</p>
</li>
</ul>
<p>Mc 的存储空间分配是以 slab 为单位的，每个 slab 的默认大小时 1MB。因此在存数据时，<strong>Mc 的内存最小分配单位是 1MB。</strong></p>
<p><strong>Item</strong></p>
<p>Mc 中，slabclass 中的 chunk 会首先用 Item 结构体进行初始化，然后存到 freelist 链表中，待需要分配给数据存储时，再从 freelist 中取出，存入 key/value，以及各种辅助属性，然后再存到 LRU 链表及 Hashtable 中。</p>
<p>Item 结构体，首先有两个 <strong>prev、next 指针</strong>，在分配给待存储数据之前，这两个指针用来串联 freelist 链表，在分配之后，则用来串联所在的 LRU 链表。接下来是一个 <strong>h_next 指针</strong>，用来在分配之后串联哈希表的桶单向链表。Item 结构体还存储了<strong>过期时间、所属 slabclass id，key 长度、cas 唯一 id 值</strong>等，最后在 Item 结构体尾部，存储了 <strong>key、flag、value 长度，以及 value block 数据</strong>。在 value 之后的 chunk 空间，就被浪费掉了。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%BA%8C%EF%BC%89-Memcached/cache_12.png" alt="item结构" style="zoom:67%;">

<p>Item 在空闲期间，即<strong>初始分配时以及被回收后，都被 freelist 管理</strong>。</p>
<p>在<strong>存储期间，被哈希表、LRU 管理</strong>。</p>
<p><strong>数据分配流程：</strong></p>
<ul>
<li><strong>计算</strong>：当需要存储 key/value 数据时，首先根据 key/value size，以及 Item 结构体的 size，<strong>计算</strong>出存储这个 key/value 需要的字节数，然后根据这个字节数选择一个能存储的 chunk size 最小的 slabclass。</li>
<li><strong>分配</strong>：再从这个 slabclass 的 freelist 分配一个空闲的 chunk 给这个 key/value 使用。<ul>
<li>如果 <strong>freelist 为空</strong>，首先尝试为该 slabclass <strong>新分配一个 slab</strong>，如果 slab 分配成功，则将 slab 按 size 分拆出一些 chunk，通过 Item 结构初始化后填充到 freelist。</li>
<li>如果 <strong>slab 分配失败</strong>，则通过 LRU <strong>淘汰失效的 Item 或强行剔除一个正常的 Item</strong>，然后这些 Item 也会填充到 freelist。当 freelist 有 Item 时，即可分配给 key/value。这个过程会重试 10 次，直到分配到 Item 位置。</li>
</ul>
</li>
<li><strong>存入哈希表</strong>：当对 key/value 分配 Item 成功，并写入数据后，接下来就会将这个 Item 存入哈希表。</li>
<li><strong>存入LRU</strong>：然后这个 Item 还会被存入 LRU，Mc 会根据这个 key 的过期时间进行判断，如果过期时间小于 61s，则存入 TEMP LRU，否则存入 HOT LRU。</li>
</ul>
<p>如果最终分配失败，则会回复一个 <strong>SERVER_ERROR</strong> 响应，通知 <strong>client</strong> 存储失败。</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><strong>背景</strong></p>
<p>Mc 将数据存储在 Item 中，然后这些 Item 会被 slabclass 的 4 个 LRU 管理。<strong>这些 LRU 都是通过双向链表实现数据记录的。双向链表在进行增加、删除、修改位置时都非常高效，但其获取定位 key 的性能非常低下，只能通过链表遍历来实现。</strong></p>
<p>因此，<strong>Mc 还通过 Hashtable，也就是哈希表，来记录管理这些 Item</strong>，通过对 key 进行哈希计算，从而快速定位和读取这些 key/value 所在的 Item。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%BA%8C%EF%BC%89-Memcached/cache_10.png" alt="HashTable作用" style="zoom:67%;">

<p>哈希表也称散列表，可以通过把 key 映射到哈希表中的一个位置来快速访问记录，定位 key 的时间复杂度只有 O(1)。Mc 的哈希表实际是一个一维指针数组，数组的每个位置称作一个 bucket，即一个桶。性能考虑的需要，Mc 的哈希表的长度设置为 2 的 N 次方。Mc 启动时，默认会构建一个拥有 6.4万 个桶的哈希表，随着新 key 的不断插入，哈希表中的元素超过阀值后，会对哈希表进行扩容，最大可以构建 2 的 32 次方个桶的哈希表。</p>
<p>用 哈希表就存在<strong>哈希冲突</strong>的问题，这里Mc 是通过<strong>单向链表</strong>解决hash冲突的。</p>
<p><strong>哈希表扩容</strong></p>
<p>当 Mc 的哈希表中，Item 数量大于 1.5 倍的哈希桶数量后，Mc 就对哈希表进行扩容处理。</p>
<p>Mc 的哈希扩容是通过哈希维护线程进行处理的。</p>
<p>准备开始扩容时，哈希维护线程会首先将所有 IO 工作线程和辅助线程进行<strong>暂停</strong>，其中辅助线程包括 LRU 维护线程、slab 维护线程、LRU 爬虫线程。待这些线程暂停后，哈希维护线程会将当前的主哈希表设为旧哈希表，然后将新的主哈希表<strong>扩容</strong>之前的 2 倍容量。然后，工作线程及辅助线程<strong>继续</strong>工作，同时哈希维护线程开始逐步将 Item 元素从旧哈希表<strong>迁移</strong>到主哈希表。</p>
<p><strong>锁哈希表</strong></p>
<p>Mc 在启动时，会根据设置的工作线程数，来构建 一个 Item 锁哈希表，线程越多，构建的锁哈希表越大，Mc 的锁哈希表中，每个桶对应一个 Item 锁，Item 锁哈希表最多有 32k 个桶，所以 Mc 最多只有 32768 个 Item 锁。</p>
<p>Mc 哈希表在读取、变更以及扩容迁移过程中，先将 key hash 定位到 Item 锁哈希表的锁桶，然后对 Item 锁进行加锁，然后再进行实际操作。实际上，除了在哈希表，在其他任何时候，只要涉及到在对 Item 的操作，都会根据 Item 中的 key，进行 Item 哈希锁桶加锁，以避免 Item 被同时读写而产生脏数据。</p>
<h2 id="Mc协议"><a href="#Mc协议" class="headerlink" title="Mc协议"></a>Mc协议</h2><h3 id="异常错误响应"><a href="#异常错误响应" class="headerlink" title="异常错误响应"></a>异常错误响应</h3><p>首先看一下Mc在发现异常后，如何进行异常错误响应的，这里是<strong>返回三种错误信息</strong>：</p>
<ul>
<li><strong>协议错误</strong>：一个”ERROR\r\n”的字符串。表明 client 发送了一个非法命令。</li>
<li><strong>client 错误</strong>：格式为”CLIENT_ERROR &lt;error-描述信息&gt;\r\n”。这个错误信息表明 ，client 发送的协议命令格式有误，比如少了字段、多了非法字段等。</li>
<li><strong>server 错误</strong>：格式为”SERVER_ERROR &lt;error-描述信息&gt;\r\n”。这个错误信息表明 Mc server 端，在处理命令时出现的错误。比如在给 key/value 分配 Item 空间失败后，会返回”SERVER_ERROR out of memory storing object” 错误信息。</li>
</ul>
<p>除了错误响应外，还有四种正常的响应，分别为：</p>
<ul>
<li>“<strong>STORED\r\n</strong>”：存储修改成功</li>
<li>“<strong>EXISTS\r\n</strong>”：待 cas 的key 已经被修改过了</li>
<li>“<strong>NOT_STORED\r\n</strong>“：数据没有存储成功，但并不是遇到错误或异常</li>
<li>“<strong>NOT_FOUND\r\n</strong>“：待 cas 的 key 在 Mc 中不存在</li>
</ul>
<h3 id="协议分类"><a href="#协议分类" class="headerlink" title="协议分类"></a>协议分类</h3><p>Mc 协议对应着相应的<strong>操作指令</strong>，主要分为三种：</p>
<ul>
<li>存储协议：Mc 存储指令分 2 行。第一行是<strong>报文首部</strong>，第二行是 <strong>value 的 data block 块</strong>。这两部分用 \r\n 来进行分割和收尾。存储协议指令共有6个：<ul>
<li><strong>Set</strong> 指令用于存储一个 key/value；</li>
<li><strong>Add</strong> 指令是在当 key 不存在时，才存储这个 key/value；</li>
<li><strong>Replace</strong> 指令，是当 key 存在时，才存储这个 key/value；</li>
<li><strong>Append</strong> 指令，是当 key 存在时，追加 data 到 value 的尾部；</li>
<li><strong>Prepend</strong> 指令，是当 key 存在时，将 data 加到 value 的头部</li>
<li><strong>cas</strong> 指令，是指只有当这个 key 存在，且从本 client 获取以来，没有其他任何人修改过时，才进行修改，cas 的英文含义是 compare and set，即比较成功后设置的意思。</li>
</ul>
</li>
<li>获取协议：<ul>
<li><strong>get</strong> 指令：get 指令只获取 key 的 flag 及 value</li>
<li><strong>gets</strong> 指令： gets 会额外多获取一个 cas unique id值。gets 主要是为 cas 指令服务的。</li>
</ul>
</li>
<li>其他协议：Mc 的其他协议指令包括 delete、incr、decr、touch、gat、gats、slabs、lru、stats 这 9 种指令。<ul>
<li><strong>delete</strong> 用于删除一个 key。</li>
<li><strong>incr/decr</strong> 用于对一个无符号长整型数字进行加或减。</li>
<li><strong>touch、gat、gats</strong> 都可以用来修改 key 的过期时间。不同点是 touch 只修改 key 的过期时间，不获取 key对应的value。而 gat、gats 指令，不仅会修改 key 的过期时间，还会获取 key 对应的 flag 和 value 数据。gats 同 gets，还会额外获取 cas 唯一 id 值。</li>
<li><strong>slabs automove</strong> 是一个开关指令，当打开时，就允许 Mc 后台线程自行决定何时将 slab 在slabclass 之间重新分配。</li>
<li><strong>lru</strong> 指令用于 Mc LRU 的设置和调优。</li>
<li><strong>stats</strong> 指令用于获取 Mc 的各种统计数据。</li>
</ul>
</li>
</ul>
<h2 id="Mc常见问题"><a href="#Mc常见问题" class="headerlink" title="Mc常见问题"></a>Mc常见问题</h2><p>Mc 在互联网企业应用广泛，热门语言基本都有 Mc client 的实现。</p>
<h3 id="Java-Mc-Client-实现对比"><a href="#Java-Mc-Client-实现对比" class="headerlink" title="Java Mc Client 实现对比"></a>Java Mc Client 实现对比</h3><ul>
<li>Memcached-Java-Client：推出时间早，性能一般，但足够稳定，不过这个 client 几年前就停止了更新。</li>
<li>SpyMemcached：出现的比较晚，性能较好，但高并发访问场景，稳定性欠缺。近几年变更很少，基本停止了更新。</li>
<li><strong>Xmemcached</strong>： <strong>性能较好，综合表现最佳。</strong>而且社区活跃度高，近些年也一直在持续更新中。Java 新项目启动，推荐使用 Xmemcached。</li>
</ul>
<h3 id="通用调优方案"><a href="#通用调优方案" class="headerlink" title="通用调优方案"></a>通用调优方案</h3><ul>
<li>读写的 key/value 较大，需要设置更大的缓冲 buf，以提高性能。</li>
<li>一些业务场景中，需要启用 TCP_NODELAY，避免 40ms 的延迟问题。</li>
<li>存取的 key/value size 较大，可以设置一个压缩阀值，超过阀值，就对value 进行压缩算法，减少读写及存储的空间。</li>
<li>为了避免缓存雪崩，并更好地应对极热 key 及洪水流量的问题，还可以对 Mc client 进行封装，加入多副本、多层级策略，使 Mc 缓存系统在任何场景下，都可做到高可用、高性能。</li>
</ul>
<h3 id="大数据时代-Mc-经典问题"><a href="#大数据时代-Mc-经典问题" class="headerlink" title="大数据时代 Mc 经典问题"></a><strong>大数据时代 Mc 经典问题</strong></h3><ul>
<li><strong>容量问题</strong>：大数据时代，互联网系统中的很多核心业务，需要缓存的热数据在 300~500GB 以上，远远超过单机物理内存的容量。</li>
<li><strong>性能瓶颈</strong>：线上访问QPS过大，单个物理机、单个资源池很难达到线上的业务要求。</li>
<li><strong>连接瓶颈</strong>：业务实例的连接数远超过单个机器的稳定支撑范围。</li>
<li><strong>硬件资源局部故障</strong>：对于数以万计的硬件设备，随时都有可能出现机器故障，从而导致 Mc 节点访问性能下降、宕机，海量访问穿透到 DB，引发 DB 过载，最终导致整个系统无法访问，引发雪崩现象。</li>
<li><strong>流量洪峰下快速扩展</strong>：大数据时代，由于信息扩散的扁平化，突发事件、重大活动发生时，海量用户同时蜂拥而至，短时间引发巨大流量，很容易出现 CPU 飙升、带宽打满、机器负荷严重过载的现象。</li>
</ul>
<h3 id="Mc-常用架构"><a href="#Mc-常用架构" class="headerlink" title="Mc 常用架构"></a>Mc 常用架构</h3><p><strong>为了解决大中型互联网系统在使用 Mc 时的这些问题。我们可以使用下面的解决方案。</strong></p>
<ul>
<li><p><strong>Memcached 分拆缓存池</strong> ：对系统内的核心业务数据进行分拆，让访问量大的数据，使用独立的缓存池。    对于缓存池的<strong>分布策略</strong>，可以采用<strong>一致性哈希分布</strong>和<strong>哈希取模分布</strong>。Mc 节点故障不可避免，在 Mc 节点故障下线后，如果采用一致性 hash 分布，可以方便的通过 <strong>rehash 策略</strong>，将该 Mc 节点的 hash 点、访问量，均匀分散到其他 Mc 节点。如果采用取模分布，则会直接导致 1/N 的访问 miss，N 是 Mc 资源池的节点数。</p>
</li>
<li><p><strong>Master-Slave 两级架构</strong>：如果某些缓存服务器短期多次故障，反复上下线，多次 rehash 还会产生脏数据。对此，可以采用 Master-Slave 的两级架构方案。</p>
<p>对于读操作，直接访问 master，如果访问 miss，再访问 slave。如果 slave 命中，就将读取到的 key 回写到 master。对于写操作，set、touch 等覆盖类指令，直接更新master 和 slave；而 cas、append 等，以 master 为准，master 在 cas、add 成功后，再将 key 直接 set 到 slave，以保持 master、slave 的数据一致性。</p>
</li>
<li><p><strong>M-S-L1 架构</strong>：80% 的请求会集中在 20% 的数据上，这种现象在互联网系统中广泛存在，我们可以通过在Master-Slave 两级架构基础上增加 L1 层来解决。<strong>L1 层用来缓存日常峰值的热数据</strong>。</p>
<p>读请求时，首先随机选择一个 L1 进行读取，如果 miss 则访问 master，如果 master 也 miss，最后访问 slave。中途，只要任何一层命中，则对上一层资源池进行回写。</p>
</li>
</ul>
<blockquote>
<p>笔记来源：陈波 老师的 《300分钟吃透分布式缓存》课程</p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>缓存</tag>
        <tag>Memcached</tag>
      </tags>
  </entry>
  <entry>
    <title>必会框架（二）- Mybatis</title>
    <url>/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89-Mybatis/</url>
    <content><![CDATA[<h1 id="必会框架（三）-Mybatis"><a href="#必会框架（三）-Mybatis" class="headerlink" title="必会框架（三）-  Mybatis"></a>必会框架（三）-  Mybatis</h1><ul>
<li>Mybatis 工作流程：配置文件 -&gt; SqlSessionFactoryBuilder -&gt; SqlSessionFactory(Configuration) -&gt; SqlSession -&gt; Executor -&gt; MappedStatement -&gt; 数据库</li>
<li>Mybatis 框架设计：<ul>
<li>接口调用方式：基于 Statement ID、基于 Mapper 接口</li>
<li>数据处理层：<ul>
<li>参数映射：参数映射配置、参数映射解析、参数类型解析</li>
<li>SQL解析：SQL语句配置、SQL语句解析、SQL语句动态生成</li>
<li>SQL执行：SimpleExecutor、BatchExecutor、ReuseExecutor</li>
<li>结果处理和映射：结果映射配置、结果类型转换</li>
</ul>
</li>
<li>框架支撑层：<ul>
<li>SQL配置方式：基于 XM配置、基于注解</li>
<li>事务管理</li>
<li>连接池管理</li>
<li>缓存机制</li>
</ul>
</li>
<li>引导层：基于XML配置、基于Java API配置</li>
</ul>
</li>
<li>Mybatis 插件机制</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p>
<p>– 百度百科</p>
</blockquote>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li>MyBatis 是原生SQL，不像 Hibernate 的 HQL 需要额外的学习成本；</li>
<li>MyBatis 的 SQL 语句与代码进行了解耦合，这与 Hibernate 是一致的；</li>
<li>MyBatis 功能简单，学习成本比较低，使用的门槛也非常低，可以快速上手；</li>
<li>MyBatis SQL调优比较灵活，而 Hibernate，SQL 语句是自动生成的，当有复杂语句需要进行优化时就比较难处理。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>相比 Hibernate 这样的全自动 ORM 框架，不能自动生成 SQL 语句，编写 SQL 的工作量比较大，尤其是字段多、关联表多的情况下；该项可基于 Mybatis 第三方框架，例如 Mybatis-plus、Tkmybatis 等，它提供的方法实现对单表的数据操作，不需要写任何sql语句，这极大地提高了项目开发效率。但是对于多表关联的情况不如 JPA等那样强大。</li>
<li>另外一个缺点就是 SQL 语句依赖于具体数据库，导致数据库迁移性差，而 Hibernate 则拥有良好的数据库可移植性。mybatis 也支持多数据库连接，需要注意的是第一点尽量单表查询，减少SQL代码的编写，而使用Mybatis工具（支持多种数据库单表查询）；第二点自己编写的SQL语法规范以IOS标准规范，减少特定数据库语法，减少不同数据库迁移带来的麻烦。</li>
</ul>
<h2 id="Mybatis-工作流程"><a href="#Mybatis-工作流程" class="headerlink" title="Mybatis 工作流程"></a>Mybatis 工作流程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">    SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    SqlSession sqlSession = factory.openSession();</span><br><span class="line">    String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    List&lt;User&gt; list = sqlSession.selectList(</span><br><span class="line">        <span class="string">"com.example.mapper.UserMapper.getUserByName"</span>,name);</span><br><span class="line">    <span class="comment">// 这里也可以使用Mapper接口的方式</span></span><br><span class="line">    <span class="comment">// UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span></span><br><span class="line">    <span class="comment">// List&lt;User&gt; list = mapper.getUserByName(name);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mybatis 工作流程大概可以概述为下面的步骤：</p>
<ul>
<li><p>读取 Mybatis 配置文件；</p>
</li>
<li><p>创建SqlSessionFactoryBuilder对象，调用build(inputstream)方法读取并解析配置文件流，返回SqlSessionFactory对象；</p>
</li>
<li><p>由SqlSessionFactory创建SqlSession 对象，没有手动设置的话，事务默认开启；</p>
</li>
<li><p>调用SqlSession中的api（也可以使用Mapper接口），传入Statement Id和参数，内部进行复杂的处理，最后调用jdbc执行SQL语句，封装结果返回。</p>
</li>
</ul>
<h3 id="解析配置文件"><a href="#解析配置文件" class="headerlink" title="解析配置文件"></a>解析配置文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.build((InputStream)inputStream, (String)<span class="keyword">null</span>, (Properties)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">    SqlSessionFactory var5;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 XMLConfigBuilder 加载解析 mybatis-config.xml 配置文件</span></span><br><span class="line">        XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">        <span class="comment">// parser.parse() 返回 Configuration 对象</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.build(parser.parse());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var14) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, var14);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由源码可知，<strong>Mybatis</strong> 使用 <strong><em>XMLConfigBuilder</em></strong> 对象解析 配置文件。其 <strong><em>parse()</em></strong> 方法将配置文件中的配置项 设置到 <strong><em>Configuration</em></strong> 中并返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.parsed) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.parsed = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">this</span>.parseConfiguration(<span class="keyword">this</span>.parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.configuration;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//保存mybatis-config.xml中的标签setting,本例中开启全局缓存cacheEnabled，设置默认执行器defaultExecutorType=REUSE</span></span><br><span class="line">         Properties settings = settingsAsPropertiess(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">         <span class="comment">//issue #117 read properties first</span></span><br><span class="line">         <span class="comment">//解析是否配置了外部properties，例如本例中配置的jdbc.propertis</span></span><br><span class="line">         propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">         <span class="comment">//查看是否配置了VFS，默认没有，本例也没有使用</span></span><br><span class="line">         loadCustomVfs(settings);</span><br><span class="line">         <span class="comment">//查看是否用了类型别名，减少完全限定名的冗余，本例中使用了别名User代替了com.ctc.Model.User</span></span><br><span class="line">         typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">         <span class="comment">//查看是否配置插件来拦截映射语句的执行，例如拦截Executor的Update方法，本例没有使用</span></span><br><span class="line">         pluginElement(root.evalNode(<span class="string">"plugins"</span>))</span><br><span class="line">         <span class="comment">//查看是否配置了ObjectFactory，默认情况下使用对象的无参构造方法或者是带有参数的构造方法，本例没有使用</span></span><br><span class="line">         objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">         <span class="comment">//查看是否配置了objectWrapperFatory,这个用来或者ObjectWapper，可以访问：对象，Collection，Map属性。本例没有使用</span></span><br><span class="line">         objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">         <span class="comment">//查看是否配置了reflectorFactory,mybatis的反射工具，提供了很多反射方法。本例没有使用</span></span><br><span class="line">         reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">         <span class="comment">//放入参数到configuration对象中</span></span><br><span class="line">         settingsElement(settings);</span><br><span class="line">         <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">         <span class="comment">//查看数据库环境配置</span></span><br><span class="line">         environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">         <span class="comment">//查看是否使用多种数据库，本例没有使用</span></span><br><span class="line">         databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">         <span class="comment">//查看是否配置了新的类型处理器，如果跟处理的类型跟默认的一致就会覆盖。本例没有使用</span></span><br><span class="line">         typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">         <span class="comment">//查看是否配置SQL映射文件,有四种配置方式，resource，url，class以及自动扫包package。本例使用package</span></span><br><span class="line">         mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + var3, var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>spring-boot 中大部分mybatis配置写入<code>properties.yml</code>即可，加载mybtais配置文件可使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mybatis.config-location=classpath:mybatis/mybatis-config.xml</span><br></pre></td></tr></table></figure>

<h3 id="创建SqlSessionFactory"><a href="#创建SqlSessionFactory" class="headerlink" title="创建SqlSessionFactory"></a>创建SqlSessionFactory</h3><p><strong>紧接着使用带有Configuration的构造方法发返回一个DefautSqlSessionFactory。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建SqlSession"><a href="#创建SqlSession" class="headerlink" title="创建SqlSession"></a>创建SqlSession</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//拿到前文从mybatis中解析到的数据库环境配置</span></span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      <span class="comment">//拿到jdbc的事务管理器，有两种一种是jbc,一种的managed。</span></span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">//从mybatis配置文件可以看到本例使用了REUSE，因此返回的是ReuseExecutor并把事务传入对象中</span></span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>返回 <strong>SqlSession</strong> 对象，默认使用<strong><em>DefaultSqlSession</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSession</span><span class="params">(Configuration configuration, Executor executor, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">  <span class="keyword">this</span>.executor = executor;</span><br><span class="line">  <span class="keyword">this</span>.dirty = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.autoCommit = autoCommit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取Mapper代理对象"><a href="#获取Mapper代理对象" class="headerlink" title="获取Mapper代理对象"></a>获取Mapper代理对象</h3><p>这里如果使用<strong>SqlSession API</strong>, 直接获取<strong>MappedStatement</strong>，使用 <strong>executor.query</strong>执行查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">       List var5;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           MappedStatement ms = <span class="keyword">this</span>.configuration.getMappedStatement(statement);</span><br><span class="line">           var5 = <span class="keyword">this</span>.executor.query(ms, <span class="keyword">this</span>.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">           <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + var9, var9);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           ErrorContext.instance().reset();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> var5;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 Mapper 接口方式，则先获取 Mapper 代理对象（JDK动态代理）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// SqlSession getMapper方法</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.configuration.getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configuration getMapper 方法</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MapperRegistry getMapper 方法</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 使用 Mapper代理工厂</span></span><br><span class="line">       MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory)<span class="keyword">this</span>.knownMappers.get(type);</span><br><span class="line">       <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 生成代理对象</span></span><br><span class="line">               <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + var5, var5);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 这里就是使用 JDK动态代理生成</span></span><br><span class="line">       <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[]&#123;<span class="keyword">this</span>.mapperInterface&#125;, mapperProxy);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">       MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy(sqlSession, <span class="keyword">this</span>.mapperInterface, <span class="keyword">this</span>.methodCache);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.newInstance(mapperProxy);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行Mapper方法"><a href="#执行Mapper方法" class="headerlink" title="执行Mapper方法"></a>执行Mapper方法</h3><p>这里就是<strong>通过MapperProxy调用Maper中相应的执行增删改查方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MapperProxy invoke 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.isDefaultMethod(method)) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">this</span>.invokeDefaultMethod(proxy, method, args);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">         <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     MapperMethod mapperMethod = <span class="keyword">this</span>.cachedMapperMethod(method);</span><br><span class="line">     <span class="comment">// 调用 mapperMethod  的 execute 方法</span></span><br><span class="line">     <span class="keyword">return</span> mapperMethod.execute(<span class="keyword">this</span>.sqlSession, args);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>MapperMethod</strong> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        Object param;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>.command.getType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> INSERT:</span><br><span class="line">            param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            result = <span class="keyword">this</span>.rowCountResult(sqlSession.insert(<span class="keyword">this</span>.command.getName(), param));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UPDATE:</span><br><span class="line">            param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            result = <span class="keyword">this</span>.rowCountResult(sqlSession.update(<span class="keyword">this</span>.command.getName(), param));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DELETE:</span><br><span class="line">            param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">            result = <span class="keyword">this</span>.rowCountResult(sqlSession.delete(<span class="keyword">this</span>.command.getName(), param));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SELECT:</span><br><span class="line">            <span class="comment">// 判断方法结果集类型</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsVoid() &amp;&amp; <span class="keyword">this</span>.method.hasResultHandler()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.executeWithResultHandler(sqlSession, args);</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsMany()) &#123;</span><br><span class="line">                result = <span class="keyword">this</span>.executeForMany(sqlSession, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsMap()) &#123;</span><br><span class="line">                result = <span class="keyword">this</span>.executeForMap(sqlSession, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsCursor()) &#123;</span><br><span class="line">                result = <span class="keyword">this</span>.executeForCursor(sqlSession, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">                result = sqlSession.selectOne(<span class="keyword">this</span>.command.getName(), param);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsOptional() &amp;&amp; (result == <span class="keyword">null</span> || !<span class="keyword">this</span>.method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">                    result = Optional.ofNullable(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FLUSH:</span><br><span class="line">            result = sqlSession.flushStatements();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + <span class="keyword">this</span>.command.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.method.getReturnType().isPrimitive() &amp;&amp; !<span class="keyword">this</span>.method.returnsVoid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + <span class="keyword">this</span>.command.getName() + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + <span class="keyword">this</span>.method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>例如  <code>result = this.executeForMany(sqlSession, args);</code>内部则使用的是 <strong>sqlSession</strong> 的查询方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    List result;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.method.hasRowBounds()) &#123;</span><br><span class="line">        RowBounds rowBounds = <span class="keyword">this</span>.method.extractRowBounds(args);</span><br><span class="line">        result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.method.getReturnType().isArray() ? <span class="keyword">this</span>.convertToArray(result) : <span class="keyword">this</span>.convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong><em>sqlSession.selectList</em></strong>方法：调用 <strong>Executor</strong> 的 <strong>query</strong> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    List var5;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MappedStatement ms = <span class="keyword">this</span>.configuration.getMappedStatement(statement);</span><br><span class="line">        <span class="comment">// Executor 的 query 方法</span></span><br><span class="line">        var5 = <span class="keyword">this</span>.executor.query(ms, <span class="keyword">this</span>.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + var9, var9);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <strong>SimpleExecutor</strong> 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    List var9;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        <span class="comment">// 获取 StatementHandler</span></span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>.wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="comment">// prepareStatement</span></span><br><span class="line">        stmt = <span class="keyword">this</span>.prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        <span class="comment">// 执行 handler.query</span></span><br><span class="line">        var9 = handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SimpleStatementHandler</strong>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = <span class="keyword">this</span>.boundSql.getSql();</span><br><span class="line">    <span class="comment">// 执行sql</span></span><br><span class="line">    statement.execute(sql);</span><br><span class="line">    <span class="comment">// 将结果集转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.resultSetHandler.handleResultSets(statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是 Mybatis 工作流程，当然其中还有一些 例如参数处理器<strong>ParameterHandler</strong>、类型解析处理器<strong>TypeHandler</strong>、结果集处理器<strong>ResultSetHandler</strong>等。</p>
<p><img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89-Mybatis/mybatis_01.png" alt="Mybatis工作流程"></p>
<h2 id="Mybatis架构设计"><a href="#Mybatis架构设计" class="headerlink" title="Mybatis架构设计"></a>Mybatis架构设计</h2><h3 id="数据库交互方式"><a href="#数据库交互方式" class="headerlink" title="数据库交互方式"></a>数据库交互方式</h3><p>由上述流程分析可知，Mybatis 实现数据库交互有俩种方式：</p>
<ul>
<li>基于传递 <strong>Statement ID 和参数</strong> 使用 <strong>SqlSession</strong>对象完成数据库交互。</li>
<li>基于<strong>Mapper</strong>接口，使用<strong>JDK动态代理</strong>生成<strong>Mapper</strong>实现类，当然，最终还是调用的 <strong>SqlSession</strong> 的 方法，这种接口调用方式好处是：<ul>
<li>不必自己编写 Mapper 的实现类（例如注入<strong>SqlSessionFactory</strong> 对象获取<strong>SqlSession</strong> ，执行相应方法 ）</li>
<li>满足<strong>面向接口编程</strong>的需要；</li>
<li>面向接口的编程另一个好处是用户可以在接口上可以使用注解来配置SQL语句，这样就可以脱离XML配置文件，实现“0配置”</li>
</ul>
</li>
</ul>
<h3 id="数据处理层"><a href="#数据处理层" class="headerlink" title="数据处理层"></a>数据处理层</h3><p> 数据处理层可以说是<strong>MyBatis</strong> 的核心，从大的方面上讲，它要完成三个功能：</p>
<ul>
<li><p>通过传入参数构建动态SQL语句；</p>
</li>
<li><p>SQL语句的执行</p>
</li>
<li><p>封装查询结果</p>
</li>
</ul>
<h4 id="参数映射"><a href="#参数映射" class="headerlink" title="参数映射"></a>参数映射</h4><p><strong>Mybatis</strong> 参数映射实现 是在 <strong>ParameterHandler</strong> 的默认实现类 <strong>DefaultParameterHandler</strong>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">        ErrorContext.instance().activity(<span class="string">"setting parameters"</span>).object(<span class="keyword">this</span>.mappedStatement.getParameterMap().getId());</span><br><span class="line">        List&lt;ParameterMapping&gt; parameterMappings = <span class="keyword">this</span>.boundSql.getParameterMappings();</span><br><span class="line">        <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); ++i) &#123;</span><br><span class="line">                ParameterMapping parameterMapping = (ParameterMapping)parameterMappings.get(i);</span><br><span class="line">                <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">                    String propertyName = parameterMapping.getProperty();</span><br><span class="line">                    Object value;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">                        value = <span class="keyword">this</span>.boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        value = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.typeHandlerRegistry.hasTypeHandler(<span class="keyword">this</span>.parameterObject.getClass())) &#123;</span><br><span class="line">                        value = <span class="keyword">this</span>.parameterObject;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        MetaObject metaObject = <span class="keyword">this</span>.configuration.newMetaObject(<span class="keyword">this</span>.parameterObject);</span><br><span class="line">                        value = metaObject.getValue(propertyName);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">                    JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        jdbcType = <span class="keyword">this</span>.configuration.getJdbcTypeForNull();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SQLException | TypeException var10) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + var10, var10);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>源码可知，首先获取 <strong>ParameterMapping</strong> 集合，循环集合，将参数<strong>Java类型转换为 JdbcType</strong>，然后调用 <strong>TypeHandler.setParameter</strong> 方法，这里举例 <strong>BigDecimal</strong> 的 <strong>TypeHandler</strong> 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BigDecimalTypeHandler类的 setNonNullParameter 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, BigDecimal parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 PreparedStatement 的setBigDecimal 方法</span></span><br><span class="line">    ps.setBigDecimal(i, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SQL解析"><a href="#SQL解析" class="headerlink" title="SQL解析"></a>SQL解析</h4><p>在前面我们提到 构建 <strong>SqlSessionFactory</strong> 对象并生成 <strong>Configuration</strong> 对象，解析配置文件时， 对<strong>mapper</strong> 文件也做了解析，这对 SQL 动态生成起了铺垫作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// Configuration 的 parseConfiguration 方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">           Properties settings = <span class="keyword">this</span>.settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">           <span class="keyword">this</span>.loadCustomVfs(settings);</span><br><span class="line">           <span class="keyword">this</span>.loadCustomLogImpl(settings);</span><br><span class="line">           <span class="keyword">this</span>.typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">           <span class="keyword">this</span>.pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">           <span class="keyword">this</span>.objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">           <span class="keyword">this</span>.objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">           <span class="keyword">this</span>.reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">           <span class="keyword">this</span>.settingsElement(settings);</span><br><span class="line">           <span class="keyword">this</span>.environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">           <span class="keyword">this</span>.databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">           <span class="keyword">this</span>.typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">           <span class="comment">// 解析mapper 节点</span></span><br><span class="line">           <span class="keyword">this</span>.mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + var3, var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>进入 <strong>mapperElement</strong> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator var2 = parent.getChildren().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                    XNode child = (XNode)var2.next();</span><br><span class="line">                    String resource;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">                        resource = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">                        <span class="keyword">this</span>.configuration.addMappers(resource);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">                        String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">                        String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">                        XMLMapperBuilder mapperParser;</span><br><span class="line">                        InputStream inputStream;</span><br><span class="line">                        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            ErrorContext.instance().resource(resource);</span><br><span class="line">                            inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">                            mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, <span class="keyword">this</span>.configuration, resource, <span class="keyword">this</span>.configuration.getSqlFragments());</span><br><span class="line">                            mapperParser.parse();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            ErrorContext.instance().resource(url);</span><br><span class="line">                            inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">                            mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, <span class="keyword">this</span>.configuration, url, <span class="keyword">this</span>.configuration.getSqlFragments());</span><br><span class="line">                            mapperParser.parse();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (resource != <span class="keyword">null</span> || url != <span class="keyword">null</span> || mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">                            <span class="keyword">this</span>.configuration.addMapper(mapperInterface);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>观察可知，这里  new 了 <strong>XMLMapperBuilder</strong> 的对象，并调用其 <strong><em>parse()</em></strong> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="keyword">this</span>.configuration.isResourceLoaded(<span class="keyword">this</span>.resource)) &#123;</span><br><span class="line">           <span class="comment">// configurationElement 解析mapper</span></span><br><span class="line">           <span class="keyword">this</span>.configurationElement(<span class="keyword">this</span>.parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">           <span class="keyword">this</span>.configuration.addLoadedResource(<span class="keyword">this</span>.resource);</span><br><span class="line">           <span class="keyword">this</span>.bindMapperForNamespace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.parsePendingResultMaps();</span><br><span class="line">       <span class="keyword">this</span>.parsePendingCacheRefs();</span><br><span class="line">       <span class="keyword">this</span>.parsePendingStatements();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">           <span class="keyword">if</span> (namespace != <span class="keyword">null</span> &amp;&amp; !namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">               <span class="comment">// 这里分别处理缓存、参数、结果、sql、增删改查节点</span></span><br><span class="line">               <span class="keyword">this</span>.builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">               <span class="keyword">this</span>.cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">               <span class="keyword">this</span>.cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">               <span class="keyword">this</span>.parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">               <span class="keyword">this</span>.resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">               <span class="keyword">this</span>.sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">               <span class="comment">// 关注 select|insert|update|delete 节点</span></span><br><span class="line">           	<span class="keyword">this</span>.buildStatementFromContext(</span><br><span class="line">               context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. The XML location is '"</span> + <span class="keyword">this</span>.resource + <span class="string">"'. Cause: "</span> + var3, var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>进入解析增删改查节点的方法 ，通过 LanguageDriver 创建SqlSource：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      String id = <span class="keyword">this</span>.context.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">      String databaseId = <span class="keyword">this</span>.context.getStringAttribute(<span class="string">"databaseId"</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">          <span class="comment">// ....此处省略</span></span><br><span class="line">          LanguageDriver langDriver = <span class="keyword">this</span>.getLanguageDriver(lang);</span><br><span class="line">          <span class="comment">// ....此处省略</span></span><br><span class="line">          <span class="comment">// 使用 LanguageDriver 创建SqlSource</span></span><br><span class="line">          SqlSource sqlSource = langDriver.createSqlSource(<span class="keyword">this</span>.configuration, <span class="keyword">this</span>.context, parameterTypeClass);</span><br><span class="line">          <span class="comment">// ....此处省略</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>继续深入代码，<strong>XMLLanguageDriver创建SqlSource，XMLScriptBuilder解析sql：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归解析动态标签</span></span><br><span class="line">    MixedSqlNode rootSqlNode = <span class="keyword">this</span>.parseDynamicTags(<span class="keyword">this</span>.context);</span><br><span class="line">    Object sqlSource;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isDynamic) &#123;</span><br><span class="line">        sqlSource = <span class="keyword">new</span> DynamicSqlSource(<span class="keyword">this</span>.configuration, rootSqlNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sqlSource = <span class="keyword">new</span> RawSqlSource(<span class="keyword">this</span>.configuration, rootSqlNode, <span class="keyword">this</span>.parameterType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (SqlSource)sqlSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可知：最终动态SQL 的生成是交由 <strong>parseDynamicTags</strong> 方法完成的。具体实现方式这里不再详解，可单独了解。</p>
<h4 id="SQL执行"><a href="#SQL执行" class="headerlink" title="SQL执行"></a>SQL执行</h4><p>Mybatis 中 SqlSession执行增删改查都是委托给Executor完成的。<br>Executor主要工作有：</p>
<ul>
<li><p>处理缓存，包括一级缓存和二级缓存</p>
</li>
<li><p>获取数据库连接</p>
</li>
<li><p>创建Statement或者PrepareStatement对象</p>
</li>
<li><p>访问数据库执行SQL语句</p>
</li>
<li><p>处理数据库返回结果</p>
</li>
</ul>
<p><strong>Executor</strong> 继承结构：</p>
<p><img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89-Mybatis/mybatis_02.png" alt="Executor继承结构"></p>
<ul>
<li><strong>CachingExecutor</strong>：CachingExecutor用于处理二级缓存，如果缓存中不存在要查询的数据，那么将查询请求委托给其他的Executor。如果是执行SQL的增删改，那么CachingExecutor将清空二级缓存。</li>
<li><strong>BaseExecutor</strong>：BaseExecutor是除CachingExecutor之外，其他Executor实现类的基类。该类主要处理一级缓存。当调用该类的增删改方法时，将清空一级缓存；当调用执行rollback/commit方法时，将清空一级缓存。</li>
<li><strong>SimpleExecutor</strong>：SimpleExecutor继承自BaseExecutor。当执行增删改查时，该类获取数据库连接，创建<strong>PrepareStatement</strong>或者<strong>Statement</strong>对象，<strong>执行SQL语句</strong>，最后将数据库返回结果转化为设定的对象。SimpleExecutor基本是按照标注JDBC流程执行SQL语句获得返回结果。不做额外处理。</li>
<li><strong>BatchExecutor</strong>：BatchExecutor与SimpleExecutor的处理逻辑是一样，不同的是执行更新方法时，BatchExecutor不是直接执行SQL语句，而是将其放到批次里面，等到提交的时候一起执行。当连续执行的SQL语句相同时，BatchExecutor才会将其加入到同一个批次中，否则新建Statement或者PreparedStatement对象，并创建新批次。</li>
<li><strong>ReuseExecutor</strong>：该类主要特点是复用。它复用的是<strong>Statement对象或者PreparedStatement对象</strong>。<br>该类中有一个属性statementMap，key是SQL语句，value是Statement对象。每次执行首先根据SQL语句查询statementMap，如果有对应的Statement对象，则直接使用该Statement对象，如果没有，则创建新的Statement对象，然后将其和SQL语句添加到statementMap；</li>
</ul>
<p>在 配置类 <strong>org.apache.ibatis.session.Configuration</strong> 中 创建 Executor 的方法中可以看到，默认创建 Executor 实现类为：<strong>SimpleExecutor</strong>，而后 根据配置属性 <strong><em>cacheEnabled</em></strong> 判断是否使用缓存，使用则 为 <strong>CachingExecutor</strong>，而改属性默认为 true，<strong>综上Mybatis默认使用的 Executor  为 CachingExecutor</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">        executorType = executorType == <span class="keyword">null</span> ? <span class="keyword">this</span>.defaultExecutorType : executorType;</span><br><span class="line">        executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">        Object executor;</span><br><span class="line">        <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">            executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">            executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 判断是否开启二级缓存</span></span><br><span class="line">        <span class="comment">// 也可在配置文件中指明： &lt;setting name="cacheEnabled"value="true"/&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cacheEnabled) &#123;</span><br><span class="line">            executor = <span class="keyword">new</span> CachingExecutor((Executor)executor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Executor executor = (Executor)<span class="keyword">this</span>.interceptorChain.pluginAll(executor);</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 但从Configuration 无参构造方法中可知 默认是开启的</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Configuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.safeResultHandlerEnabled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.multipleResultSetsEnabled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.useColumnLabel = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.cacheEnabled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// ....省略</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// XMLConfigBuilder 创建方法中正是调用了 Configuration 无参构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">XMLConfigBuilder</span><span class="params">(XPathParser parser, String environment, Properties props)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> Configuration());</span><br><span class="line">        <span class="keyword">this</span>.localReflectorFactory = <span class="keyword">new</span> DefaultReflectorFactory();</span><br><span class="line">        ErrorContext.instance().resource(<span class="string">"SQL Mapper Configuration"</span>);</span><br><span class="line">        <span class="keyword">this</span>.configuration.setVariables(props);</span><br><span class="line">        <span class="keyword">this</span>.parsed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">        <span class="keyword">this</span>.parser = parser;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>综上，SQL执行逻辑可以关注 <strong>SimpleExecutor</strong> 类，这里 举例<strong>doQuery</strong> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    List var9;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>.wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="comment">// 获取 Statement 对象</span></span><br><span class="line">        stmt = <span class="keyword">this</span>.prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        <span class="comment">// 交由对象handler 执行查询</span></span><br><span class="line">        var9 = handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PreparedStatementHandler</strong>的query方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement)statement;</span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结果处理与映射"><a href="#结果处理与映射" class="headerlink" title="结果处理与映射"></a>结果处理与映射</h4><p><strong>Mybatis</strong> 结果处理与映射 是由 <strong>ResultSetHandler</strong> 处理的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 负责结果集处理，完成映射返回结果集对象</span></span><br><span class="line">    &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">(Statement var1)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">	<span class="comment">// 负责游标对象处理</span></span><br><span class="line">    &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">handleCursorResultSets</span><span class="params">(Statement var1)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">	<span class="comment">// 负责存储过程的输出</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleOutputParameters</span><span class="params">(CallableStatement var1)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Mybatis</strong> 中提供了<strong>ResultSetHandler</strong> 接口的唯一实现类 <strong>DefaultResultSetHandler</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ErrorContext.instance().activity(<span class="string">"handling results"</span>).object(<span class="keyword">this</span>.mappedStatement.getId());</span><br><span class="line">        List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">        ResultSetWrapper rsw = <span class="keyword">this</span>.getFirstResultSet(stmt);</span><br><span class="line">    	<span class="comment">// 获取 mappedStatement 中的结果集 </span></span><br><span class="line">        List&lt;ResultMap&gt; resultMaps = <span class="keyword">this</span>.mappedStatement.getResultMaps();</span><br><span class="line">        <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">        <span class="keyword">this</span>.validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">            ResultMap resultMap = (ResultMap)resultMaps.get(resultSetCount);</span><br><span class="line">            <span class="comment">//根据resultMap处理ResultSetWrapper生成java对象</span></span><br><span class="line">            <span class="keyword">this</span>.handleResultSet(rsw, resultMap, multipleResults, (ResultMapping)<span class="keyword">null</span>);</span><br><span class="line">            rsw = <span class="keyword">this</span>.getNextResultSet(stmt);</span><br><span class="line">            <span class="keyword">this</span>.cleanUpAfterHandlingResultSet();</span><br><span class="line">            ++resultSetCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] resultSets = <span class="keyword">this</span>.mappedStatement.getResultSets();</span><br><span class="line">        <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">                ResultMapping parentMapping = (ResultMapping)<span class="keyword">this</span>.nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">                <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">                    ResultMap resultMap = <span class="keyword">this</span>.configuration.getResultMap(nestedResultMapId);</span><br><span class="line">                    <span class="keyword">this</span>.handleResultSet(rsw, resultMap, (List)<span class="keyword">null</span>, parentMapping);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rsw = <span class="keyword">this</span>.getNextResultSet(stmt);</span><br><span class="line">                <span class="keyword">this</span>.cleanUpAfterHandlingResultSet();</span><br><span class="line">                ++resultSetCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.collapseSingleResultList(multipleResults);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由于 Mybatis 结果集处理过于复杂繁琐，涉及嵌套结果集处理，延迟加载等，暂时不能理解，这里不做深入研究，只做简要分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;ResultMap&gt; resultMaps = <span class="keyword">this</span>.mappedStatement.getResultMaps();</span><br></pre></td></tr></table></figure>

<p>这里从 <strong>mappedStatement</strong> 中获取  <strong>resultMaps</strong>， 即使我们在select的查询中配置的不是resultMap而是resultType，在mybatis中也是按照resultMap进行存储的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据resultMap处理ResultSetWrapper生成java对象</span></span><br><span class="line"><span class="keyword">this</span>.handleResultSet(rsw, resultMap, multipleResults, (ResultMapping)<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>由 <strong>handleResultSet</strong> 方法进入，最终定位 <strong>getRowValue</strong>方法生成Java对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getRowValue</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ResultLoaderMap lazyLoader = <span class="keyword">new</span> ResultLoaderMap();</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    Object rowValue = <span class="keyword">this</span>.createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span><br><span class="line">    <span class="keyword">if</span> (rowValue != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123;</span><br><span class="line">        MetaObject metaObject = <span class="keyword">this</span>.configuration.newMetaObject(rowValue);</span><br><span class="line">        <span class="keyword">boolean</span> foundValues = <span class="keyword">this</span>.useConstructorMappings;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.shouldApplyAutomaticMappings(resultMap, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="comment">// 自动绑定</span></span><br><span class="line">            foundValues = <span class="keyword">this</span>.applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// property 属性绑定</span></span><br><span class="line">        foundValues = <span class="keyword">this</span>.applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;</span><br><span class="line">        foundValues = lazyLoader.size() &gt; <span class="number">0</span> || foundValues;</span><br><span class="line">        rowValue = !foundValues &amp;&amp; !<span class="keyword">this</span>.configuration.isReturnInstanceForEmptyRow() ? <span class="keyword">null</span> : rowValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rowValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了<strong>反射原理创建对象</strong>，并使用 set 赋值。</p>
<h3 id="框架支撑层"><a href="#框架支撑层" class="headerlink" title="框架支撑层"></a>框架支撑层</h3><h4 id="SQL配置方式"><a href="#SQL配置方式" class="headerlink" title="SQL配置方式"></a>SQL配置方式</h4><ul>
<li>基于XML配置方式</li>
<li>基于注解的方式</li>
</ul>
<p>前面我们说到 <strong>Mybatis 动态代理</strong>的好处之一是，面向接口编程，我们可以通过注解的方式配置sql语句，不用再写xml文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(&#123;<span class="string">"&lt;script&gt; SELECT * FROM user WHERE "</span> +</span><br><span class="line"><span class="string">"&lt;if  test= "</span>mobile != <span class="keyword">null</span> and mobile != <span class="string">''</span><span class="string">"&gt; mobile = #&#123;mobile&#125; &lt;/if&gt;"</span> +</span><br><span class="line"><span class="string">"&lt;if  test= "</span>userName != <span class="keyword">null</span> and userName != <span class="string">''</span><span class="string">"&gt;  AND user_name=#&#123;userName&#125; &lt;/if&gt;"</span>&#125;)</span><br><span class="line"><span class="comment">// 参数是对象</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>

<p>同理还有 <strong>@Update \ @Insert \ @Delete \ @Options</strong> 注解等。</p>
<p>还有一种方式 是基于 <strong>Provider</strong> 类注解，将 SQL字符串 由 指定的 Provider 类方法返回，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// 动态查询  type:指定一个类    method:使用这个类中的selectWhitParamSql方法返回的sql字符串  作为查询的语句  				</span></span><br><span class="line"><span class="meta">@SelectProvider</span>(type=Intefaceproxy.Dyno.EmployeeDynaSqlProvider<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">               <span class="title">method</span></span>=<span class="string">"selectWhitParamSql"</span>)</span><br><span class="line">   <span class="function">List&lt;Employee&gt; <span class="title">selectWithParam</span><span class="params">(Map&lt;String,Object&gt; param)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对应的 <strong>Provider</strong>  类中拼接 SQL 字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDynaSqlProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法中的关键字是区分大小写的  SQL SELECT WHERE</span></span><br><span class="line">    <span class="comment">//该方法会根据传递过来的map中的参数内容（或者对象）  动态构建sql语句</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">selectWhitParamSql</span><span class="params">(Map&lt;String, Object&gt; param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SQL() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                SELECT(<span class="string">"*"</span>);</span><br><span class="line">                FROM(<span class="string">"tb_employee"</span>);</span><br><span class="line">                <span class="keyword">if</span> (param.get(<span class="string">"id"</span>)!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    WHERE(<span class="string">"id=#&#123;id&#125;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(param.get(<span class="string">"name"</span>)!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    WHERE(<span class="string">"name=#&#123;name&#125;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(param.get(<span class="string">"sex"</span>)!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    WHERE(<span class="string">"sex=#&#123;sex&#125;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理还有 <strong>@UpdateProvider \ @InsertProvider \ @DeleteProvider \ @Options</strong> 注解等。</p>
<h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><p><strong>MyBatis</strong> 将事务抽象成了<strong>Transaction</strong>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">    <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function">Integer <span class="title">getTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MyBatis</strong> 的事务管理分为俩种形式：</p>
<ul>
<li>使用<strong>JDBC</strong>的事务管理机制：利用java.sql.Connection对象完成对事务的提交（commit()）、回滚（rollback()）、关闭（close()）等。</li>
<li>使用<strong>MANAGED</strong>的事务管理机制：这种机制MyBatis自身不会去实现事务管理，而是让程序的容器如（JBOSS，Weblogic）来实现对事务的管理。</li>
<li><strong>mybatis-spring</strong> 中 使用Spring事务管理机制：Spring官方并没有提供对MyBatis的集成方案，于是MyBatis项目组自己写了一个项目<strong>mybatis-spring</strong>专门用于在spring中使用MyBatis。</li>
</ul>
<p><strong>Transaction</strong> 继承结构：</p>
<p><img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89-Mybatis/mybatis_03.png" alt="Transaction继承结构"></p>
<p>我们分别看一下 每个类的 <strong>commit()</strong> 方法实现：</p>
<p><strong>SpringManagedTransaction</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.connection = DataSourceUtils.getConnection(<span class="keyword">this</span>.dataSource);</span><br><span class="line">    <span class="keyword">this</span>.autoCommit = <span class="keyword">this</span>.connection.getAutoCommit();</span><br><span class="line">    <span class="keyword">this</span>.isConnectionTransactional = 	DataSourceUtils.isConnectionTransactional(<span class="keyword">this</span>.connection, <span class="keyword">this</span>.dataSource);</span><br><span class="line">    LOGGER.debug(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"JDBC Connection ["</span> + <span class="keyword">this</span>.connection + <span class="string">"] will"</span> + (<span class="keyword">this</span>.isConnectionTransactional ? <span class="string">" "</span> : <span class="string">" not "</span>) + <span class="string">"be managed by Spring"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 由上面的openConnection方法可知，判断交由 DataSourceUtils.isConnectionTransactional </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.isConnectionTransactional &amp;&amp; !<span class="keyword">this</span>.autoCommit) &#123;</span><br><span class="line">        LOGGER.debug(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Committing JDBC Connection ["</span> + <span class="keyword">this</span>.connection + <span class="string">"]"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.connection.commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DataSourceUtils.isConnectionTransactional</strong> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isConnectionTransactional</span><span class="params">(Connection con, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取Spring管理的数据库连接</span></span><br><span class="line">        ConnectionHolder conHolder = (ConnectionHolder)TransactionSynchronizationManager.getResource(dataSource);</span><br><span class="line">        <span class="comment">// 对比，判断是否是Spring项目</span></span><br><span class="line">        <span class="keyword">return</span> conHolder != <span class="keyword">null</span> &amp;&amp; connectionEquals(conHolder, con);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JdbcTransaction</strong>：使用的java.sql.Connection 上的commit和rollback功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">	<span class="comment">// 调用 Connection getAutoCommit 判断，只做了简单的封装</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.connection != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.connection.getAutoCommit()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Committing JDBC Connection ["</span> + <span class="keyword">this</span>.connection + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.connection.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ManagedTransaction</strong>：可以看到，它什么都不会做，它将事务管理的权利移交给了容器来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="连接池管理"><a href="#连接池管理" class="headerlink" title="连接池管理"></a>连接池管理</h4><p>当我们使用原始JDBC连接数据库时，需要经过 加载驱动、建立连接、再执行<code>SQL</code>的一个过程，当下一个<code>SQL</code>到来的时候，还需要进行一次这个流程，每次都新建一个连接，随着用户操作的逐渐增多，每次都和数据库建立连接对数据库来说也是一种压力。</p>
<p>为了减少这种不必要的消耗，可以对数据的操作进行拆分。在<code>Mybatis</code>中，<strong>数据库连接的建立和管理的部分叫做数据库连接池。</strong></p>
<ul>
<li><p>连接池就是用于存储连接的一个容器</p>
</li>
<li><p>容器其实就是一个<strong>集合对象</strong>, 该集合必须是<strong>线程安全</strong>的, 不能两个线程拿到同一连接</p>
</li>
<li><p>该集合还必须实现队列的特性: <strong>先进先出</strong></p>
</li>
</ul>
<p>我们知道，<strong>MyBatis</strong>是通过工厂模式来创建数据源<strong>DataSource</strong>对象的，<strong>MyBatis</strong>定义了抽象的工厂接口 <strong>DataSourceFactory</strong>,通过其<strong>getDataSource</strong>()方法返回数据源<strong>DataSource</strong>。</p>
<p><strong>MyBatis</strong>创建了<strong>DataSource</strong>实例后，会将其放到<strong>Configuration</strong>对象内的<strong>Environment</strong>对象中，供以后使用。</p>
<p>当我们需要创建<strong>SqlSession</strong>对象<strong>并需要执行SQL语句时</strong>，这时候<strong>MyBatis</strong>会去调用<strong>dataSource</strong>对象来创建<strong>java.sql.Connection</strong>对象。（Connection对象是使用时创建的）</p>
<p>那么 关于 <strong>Connection</strong> 的池子，即由 连接的创建者 <strong>dataSource</strong> 属性决定，<code>SqlMapConfig.xml</code>中的<strong>dataSource</strong>标签，<strong>type</strong>属性就是表示采用何种连接池方式，mybatis 提供<strong>三种</strong> 相应属性：</p>
<ul>
<li><strong>UNPOOLED</strong>：采用传统的获取连接的方式，虽然也实现<code>Javax.sql.DataSource</code>接口，但是并没有使用池的思想; <strong>MyBatis</strong> 首先会实例化一个<code>UnpooledDataSourceFactory</code>工厂实例，然后通过<code>.getDataSource()</code> 方法返回一个<strong>UnpooledDataSource</strong> 实例对象引用。使用 <strong>UnpooledDataSource</strong>的 <code>getConnection()</code> ,每调用一次就会产生一个新的 <strong>Connection</strong> 实例对象。</li>
<li><strong>POOLED</strong>：采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现;</li>
<li><strong>JNDI</strong>：采用服务器提供的<strong>JNDI</strong>技术实现，来获取<strong>DataSource</strong>对象，不同的服务器所能拿到DataSource 不一样，例如<strong>tomcat</strong>服务器，采用的连接池是<strong>dbcp</strong>连接池</li>
</ul>
<p>这里我们重点关注后俩种属性：</p>
<p><strong>PooledDataSource</strong></p>
<p>将<code>java.sql.Connection</code>对象包裹成<code>PooledConnection</code>对象放到了<code>PoolState</code>类型的容器中维护。 <code>MyBatis</code>将连接池中的<code>PooledConnection</code>分为两种状态： <strong>空闲状态（idle）</strong>和<strong>活动状态(active)</strong>，这两种状态的<code>PooledConnection</code>对象分别被存储到<code>PoolState</code>容器内的<strong><code>idleConnections</code></strong>和<strong><code>activeConnections</code></strong>两个List集合中：</p>
<ul>
<li><p><strong>idleConnections</strong>: 空闲(idle)状态<code>PooledConnection</code>对象被放置到此集合中，表示当前闲置的没有被使用的<code>PooledConnection</code>集合，调用<code>PooledDataSource</code>的<code>getConnection()</code>方法时，会优先从此集合中取<code>PooledConnection</code>对象。当用完一个java.sql.Connection对象时，<code>MyBatis</code>会将其包裹成<code>PooledConnection</code>对象放到此集合中。</p>
</li>
<li><p><strong>activeConnections</strong>: 活动(active)状态的<code>PooledConnection</code>对象被放置到名为<code>activeConnections</code>的<code>ArrayList</code>中，表示当前正在被使用的<code>PooledConnection</code>集合，调用<code>PooledDataSource</code>的<code>getConnection()</code>方法时，会优先从<code>idleConnections</code>集合中取<code>PooledConnection</code>对象,如果没有，则看此集合是否已满，如果未满，<code>PooledDataSource</code>会创建出一个<code>PooledConnection</code>，添加到此集合中，并返回</p>
</li>
</ul>
<p>当我们 使用 完 <strong>Connection</strong> 时，调用<code>.close()</code>方法并没有将 连接真正销毁，而是 放入了连接池中，这里 <strong>Mybatis</strong> 使用了 <strong>Connection</strong>  代理对象，当<strong>close</strong>时候，会回收 <strong>connection</strong> , 不会真正的<strong>close</strong>。</p>
<h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>缓存是一般的ORM 框架都会提供的功能，目的就是<strong>提升查询的效率和减少数据库的压力</strong>。跟Hibernate 一样，MyBatis 也有<strong>一级缓存</strong>和<strong>二级缓存</strong>，并且预留了集成<strong>第三方缓存</strong>的接口。</p>
<p><strong>MyBatis</strong> 跟缓存相关的类都在<code>cache</code>包里面，其中有一个<strong>Cache</strong> 接口，只有一个默认的实现类 <strong>PerpetualCache</strong>，它是用<strong>HashMap</strong> 实现的。</p>
<p>除此之外还有很多的<strong>装饰器</strong>，通过这些装饰器可以额外实现很多的功能：回收策略、日志记录、定时刷新等等。</p>
<p>例如：BlockingCache 阻塞缓存、FifoCache FIFO策略缓存、LoggingCache 带日志的缓存、LruCache LRU策略缓存等，都在 <code>cache.decorators</code>包下面。</p>
<h5 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h5><p>一级缓存也叫<strong>本地缓存</strong></p>
<ul>
<li><strong>MyBatis</strong> 的一级缓存是在<strong>会话（SqlSession）层面</strong>进行缓存的；</li>
<li>MyBatis 的一级缓存是<strong>默认开启</strong>的，不需要任何的配置。</li>
<li>在<strong>同一个会话</strong>里面，多次执行相同的SQL 语句，会直接从内存取到缓存的结果，不会再发送SQL 到数据库。但是不同的会话里面，即使执行的SQL 一模一样（通过一个Mapper 的同一个方法的相同参数调用），也不能使用到一级缓存。</li>
<li>MyBatis在开启一个数据库会话时，会 创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。</li>
<li>如果SqlSession调用了<strong><em>close()</em></strong>方法，会释<strong>放掉一级缓存PerpetualCache对象</strong>，一级缓存将不可用；</li>
<li>如果SqlSession调用了<strong><em>clearCache()</em></strong>方法，会<strong>清空PerpetualCache对象中的数据</strong>，但是该对象仍可使用；</li>
<li>SqlSession中执行了任何一个<strong>update操作(update()、delete()、insert())</strong> ，都会<strong>清空PerpetualCache对象的数据</strong>，但是该对象可以继续使用；</li>
</ul>
<p><strong>工作流程</strong></p>
<ol>
<li>对于某个查询，根据statementId,params,rowBounds来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果</li>
<li>判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中；</li>
<li>如果命中，则直接将缓存结果返回；</li>
<li>如果没命中：<ol>
<li>去数据库中查询数据，得到查询结果；</li>
<li>将key和查询到的结果分别作为key,value对存储到Cache中；</li>
<li>将查询结果返回；</li>
</ol>
</li>
</ol>
<p>源码分析：前面我们知道 一级缓存的实现代码在 <strong>Executor</strong> 的默认实现类 <strong>BaseExecutor</strong> 中实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BaseExecutor 的 query 方法中</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ++<span class="keyword">this</span>.queryStack;</span><br><span class="line">    <span class="comment">// 获取缓存</span></span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List)<span class="keyword">this</span>.localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取不到直接从数据库中获取</span></span><br><span class="line">        list = <span class="keyword">this</span>.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    --<span class="keyword">this</span>.queryStack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一级缓存的不足：</strong></p>
<p>使用一级缓存的时候，因为缓存<strong>不能跨会话共享</strong>，不同的会话之间对于相同的数据可能有不一样的缓存。在有多个会话或者分布式环境下，会存在脏数据的问题。如果要解决这个问题，就要用到二级缓存。MyBatis 一级缓存无法关闭，但是有两种级别可选：</p>
<ul>
<li><p>session 级别的缓存，在同一个 sqlSession 内，对同样的查询将不再查询数据库，直接从缓存中。</p>
</li>
<li><p>statement 级别的缓存， 为了避免这个问题，可以将一级缓存的级别设为 statement 级别的，这样每次查询结束都会清掉一级缓存。</p>
</li>
</ul>
<p><strong>关闭一级缓存的方法</strong>：</p>
<ul>
<li>全局关闭：设置 <code>mybatis.configuration.local-cache-scope=statement</code></li>
<li>指定 mapper 关闭：在 <code>mapper.xml</code> 的指定 statement 上标注 <code>flushCache=&quot;true&quot;</code></li>
</ul>
<h5 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h5><p>二级缓存是用来解决一级缓存不能跨会话共享的问题的。</p>
<ul>
<li>二级缓存的作用范围是 <code>namespace</code>,可以被多个SqlSession 共享（只要是同一个接口里面的相同方法，都可以共享）;</li>
<li>二级缓存<strong>生命周期和应用同步</strong>。</li>
<li>MyBatis查询数据的顺序是：<strong>二级缓存  —&gt; 一级缓存 —&gt; 数据库</strong>。</li>
<li>二级缓存的实现是在 装饰器的类<strong>CachingExecutor</strong>里，</li>
<li>对于查询请求，会判断二级缓存是否有缓存结果，如果有就直接返回，如果没有委派交给真正的查询器Executor 实现类，如SimpleExecutor执行查询（会走一级缓存）。</li>
</ul>
<p><strong>开启二级缓存的方法</strong></p>
<ol>
<li><p>配置 <code>mybatis.configuration.cache-enabled=true</code>，mybatis默认该配置为<strong>true</strong>，只要没有显式地设置cacheEnabled=false，都会用CachingExecutor 装饰基本的执行器。</p>
</li>
<li><p>在Mapper.xml 中配置<cache>标签</cache></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"org.apache.ibatis.cache.impl.PerpetualCache"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">size</span>=<span class="string">"1024"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">eviction</span>=<span class="string">"LRU"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">flushInterval</span>=<span class="string">"120000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">readOnly</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>映射语句文件中的所有 select 语句的结果将会被缓存。</p>
</li>
<li><p>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。<strong>所有的增删改都会刷新二级缓存</strong>，导致二级缓存失效，所以适合在查询为主的应用中使用</p>
</li>
<li><p>缓存会使用最<strong>近最少使用</strong>算法（<strong>LRU</strong>, Least Recently Used）算法来清除不需要的缓存。</p>
</li>
<li><p>缓存不会定时进行刷新。</p>
</li>
<li><p>缓存会保存列表或对象的 1024 个引用。</p>
</li>
<li><p>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</p>
</li>
<li><p>二级缓存是事务性的。事务不提交，二级缓存不生效。因为二级缓存使用TransactionalCacheManager（TCM）来管理，最后又调用了TransactionalCache 的getObject()、putObject 和commit()方法，TransactionalCache里面又持有了真正的Cache 对象。</p>
</li>
<li><p>如果在一个namespace 中刷新了缓存，另一个namespace 中没有刷新，就会出现读到脏数据的情况。所以，推荐在一个Mapper 里面只操作单表的情况使用。</p>
</li>
<li><p>跨namespace 的缓存共享的问题，可以使用<cache-ref>来解决：</cache-ref></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">"com.example.crud.dao.UserMapper"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>cache-ref 代表引用别的命名空间的Cache 配置，两个命名空间的操作使用的是同一个Cache。在这种情况下，多个Mapper 的操作都会引起缓存刷新，缓存的意义已经不大了.</p>
</li>
</ul>
<p>可用的清除策略有：</p>
<ul>
<li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li>
<li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li>
<li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li>
<li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li>
</ul>
<p><strong>默认的清除策略是 LRU。</strong></p>
<h5 id="自定义缓存"><a href="#自定义缓存" class="headerlink" title="自定义缓存"></a>自定义缓存</h5><p>除了MyBatis 自带的二级缓存之外，我们也可以通过实现Cache 接口来自定义二级缓存。MyBatis 官方提供了一些第三方缓存集成方式。你只需要：</p>
<ul>
<li><p>自定义缓存实现类，实现 <strong>Cache</strong> 接口；</p>
</li>
<li><p>配置文件中cache类型为自己的缓存实现类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"com.example.cache.CustormCache"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Mybatis-插件机制"><a href="#Mybatis-插件机制" class="headerlink" title="Mybatis 插件机制"></a>Mybatis 插件机制</h2><p><strong>Mybatis插件可以对框架进行扩展，实现自定义功能，并且对于用户是无感知的。</strong></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>MyBatis有四大核心对象：</p>
<ul>
<li><strong>ParameterHandler</strong>：处理SQL的参数对象</li>
<li><strong>ResultSetHandler</strong>：处理SQL的返回结果集</li>
<li><strong>StatementHandler</strong>：数据库的处理对象，用于执行SQL语句</li>
<li><strong>Executor：MyBatis</strong>的执行器，用于执行增删改查操作</li>
</ul>
<p><strong>MyBatis 提供了对四大组件扩展的机制。</strong></p>
<p>核心思想就是使用<strong>JDK动态代理</strong>的方式，对这四个对象进行<strong>包装增强</strong>。具体的做法是，创建一个类实现Mybatis的拦截器接口，并且加入到拦截器链中，在创建核心对象的时候，不直接返回，而是遍历拦截器链，把每一个拦截器都作用于核心对象中。这么一来，Mybatis创建的核心对象其实都是代理对象，都是被包装过的。</p>
<p>以 <strong>Executor</strong> 类为例：</p>
<p><strong>Configuration</strong>类中的<strong>newExecutor</strong>方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">      executorType = executorType == <span class="keyword">null</span> ? <span class="keyword">this</span>.defaultExecutorType : executorType;</span><br><span class="line">      executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">      Object executor;</span><br><span class="line">      <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">          executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">          executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.cacheEnabled) &#123;</span><br><span class="line">          executor = <span class="keyword">new</span> CachingExecutor((Executor)executor);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 拦截器链对 使用 插件对executor增强</span></span><br><span class="line">      Executor executor = (Executor)<span class="keyword">this</span>.interceptorChain.pluginAll(executor);</span><br><span class="line">      <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>interceptorChain.pluginAll</strong> 方法中，迭代 <strong>Interceptor</strong> 执行 <strong>plugin</strong> 方法 返回 代理对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    Interceptor interceptor;</span><br><span class="line">    <span class="keyword">for</span>(Iterator var2 = <span class="keyword">this</span>.interceptors.iterator(); var2.hasNext(); target = interceptor.plugin(target)) &#123;</span><br><span class="line">        interceptor = (Interceptor)var2.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而我们 要实现的 就是 <strong>Interceptor 接口</strong></p>
<h3 id="自定义-Interceptor-拦截器"><a href="#自定义-Interceptor-拦截器" class="headerlink" title="自定义 Interceptor 拦截器"></a>自定义 <strong>Interceptor</strong> 拦截器</h3><p>我们先来看一下 <strong>Interceptor</strong> 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation 调用信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 调用结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable 若发生异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用插件。如应用成功，则会创建目标对象的代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 应用的结果对象，可以是代理对象，也可以是 target 对象，也可以是任意对象。具体的，看代码实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置拦截器属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> properties 属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义 拦截器 <strong>CustomIntercepter</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;</span><br><span class="line">        <span class="meta">@Signature</span>(type = Executor<span class="class">.<span class="keyword">class</span>,  <span class="title">method</span> </span>= <span class="string">"query"</span>,</span><br><span class="line">        args = &#123;</span><br><span class="line">           MappedStatement<span class="class">.<span class="keyword">class</span>, </span></span><br><span class="line"><span class="class">           <span class="title">Object</span>.<span class="title">class</span>, </span></span><br><span class="line"><span class="class">           <span class="title">RowBounds</span>.<span class="title">class</span>, </span></span><br><span class="line"><span class="class">           <span class="title">ResultHandler</span>.<span class="title">class</span>&#125;)&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CustomIntercepter</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次执行的时候，都是执行这个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对方法进行了增强"</span>);</span><br><span class="line">        <span class="comment">//执行原方法</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一个拦截器对象，丢到拦截器链中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"将要包装的目标对象"</span>+target);</span><br><span class="line">        <span class="comment">// 这里使用JDK动态代理返回对象</span></span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target,<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置的初始化参数"</span>+properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>拦截器要 实现 <strong>Interceptor</strong> 接口，并实现相应方法</p>
</li>
<li><p><strong>@Intercepts</strong> 注解指明作用对象，拦截方法，参数类型等</p>
</li>
<li><p><code>mybatis-config.xml</code> 配置文件中配置 <strong>plugins</strong> </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">       &lt;plugin interceptor=<span class="string">"com.example.mybatis.inceptor.CustomIncepetor"</span>&gt;</span><br><span class="line">           &lt;property name=<span class="string">"name"</span> value=<span class="string">"zhangsan"</span>/&gt;</span><br><span class="line">       &lt;/plugin&gt;</span><br><span class="line">   &lt;/plugins&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意这里 的 <code>plugin</code> 方法，<strong>return Plugin.wrap(target,this);</strong></p>
<p><strong>Plugin</strong> 即为代理对象，使用<strong>JDK动态代理</strong>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插件类，一方面提供创建动态代理对象的方法，另一方面实现对指定类的指定方法的拦截处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Interceptor interceptor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截的方法映射</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * KEY：类</span></span><br><span class="line"><span class="comment">     * VALUE：方法集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Plugin</span><span class="params">(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"> Set&lt;Method&gt;&gt; signatureMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.interceptor = interceptor;</span><br><span class="line">        <span class="keyword">this</span>.signatureMap = signatureMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建目标类的代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interceptor 拦截器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得拦截的方法映射</span></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">        <span class="comment">// 获得目标类的类型</span></span><br><span class="line">        Class&lt;?&gt; type = target.getClass();</span><br><span class="line">        <span class="comment">// 获得目标类的接口集合</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">        <span class="comment">// 若有接口，则创建目标对象的 JDK Proxy 对象</span></span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                    type.getClassLoader(),</span><br><span class="line">                    interfaces,</span><br><span class="line">                    <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line"> <span class="comment">// 因为 Plugin 实现了 InvocationHandler 接口，所以可以作为 JDK 动态代理的调用处理器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有，则返回原始的目标对象</span></span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获得目标方法是否被拦截</span></span><br><span class="line">            Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">            <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">                <span class="comment">// 如果是，则拦截处理该方法</span></span><br><span class="line">                <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是，则调用原方法</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上则为Mybatis插件机制原理。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><strong>Mybatis 插件的常见使用场景</strong>：</p>
<ul>
<li>分页：例如开源框架 PageHelper，MyBatis-Plus 等</li>
<li>自动设置字段值到数据库：例如审计字段自动入表，除了数据库触发器方式，Mybatis插件也可实现</li>
<li>数据屏蔽，字段加密：针对查询数据，根据配置表配置，对敏感数据屏蔽，加密等</li>
</ul>
<blockquote>
<p>笔记参考：</p>
<p><a href="https://blog.csdn.net/luanlouis/article/details/40422941" target="_blank" rel="noopener">https://blog.csdn.net/luanlouis/article/details/40422941</a></p>
<p><a href="https://www.cnblogs.com/fangjian0423/p/mybaits-dynamic-sql-analysis.html" target="_blank" rel="noopener">https://www.cnblogs.com/fangjian0423/p/mybaits-dynamic-sql-analysis.html</a></p>
<p><a href="https://blog.csdn.net/weixin_38308374/article/details/109062502" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38308374/article/details/109062502</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/103217343" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103217343</a></p>
<p><a href="https://www.cnblogs.com/wuzhenzhao/p/11103043.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuzhenzhao/p/11103043.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/163863114" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/163863114</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>必会框架（一）- Spring</title>
    <url>/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89-Spring/</url>
    <content><![CDATA[<h1 id="必会框架（一）-Spring"><a href="#必会框架（一）-Spring" class="headerlink" title="必会框架（一）-  Spring"></a>必会框架（一）-  Spring</h1><ul>
<li>Spring Framework  ：spring架构组成、Ioc容器、context、Spring初始化、事件机制、DI、AOP</li>
<li>SpringMVC：工作原理，流程，组件，优缺点</li>
<li>SpringData：JDBC、Redis、MonggoDB等相关数据源操作</li>
<li>SpringBoot：常用注解、自动配置、约定大于配置</li>
<li>SpringCloud：微服务解决方案 </li>
</ul>
<h3 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h3><blockquote>
<p><strong>Spring</strong>框架是一个<a href="https://baike.baidu.com/item/开放源代码/114160" target="_blank" rel="noopener">开放源代码</a>的<a href="https://baike.baidu.com/item/J2EE/110838" target="_blank" rel="noopener">J2EE</a>应用程序框架，由[Rod Johnson](<a href="https://baike.baidu.com/item/Rod" target="_blank" rel="noopener">https://baike.baidu.com/item/Rod</a> Johnson/1423612)发起，是针对bean的生命周期进行管理的轻量级容器（lightweight container）。 Spring解决了开发者在J2EE开发中遇到的许多常见的问题，提供了功能强大IOC、<a href="https://baike.baidu.com/item/AOP/1332219" target="_blank" rel="noopener">AOP</a>及Web MVC等功能。Spring可以单独应用于构筑应用程序，也可以和Struts、Webwork、Tapestry等众多Web框架组合使用，并且可以与 Swing等<a href="https://baike.baidu.com/item/桌面应用程序/2331979" target="_blank" rel="noopener">桌面应用程序</a>AP组合。因此， Spring不仅仅能应用于JEE应用程序之中，也可以应用于桌面应用程序以及小应用程序之中。Spring框架主要由七部分组成，分别是 Spring Core、 Spring AOP、 Spring ORM、 Spring DAO、Spring Context、 Spring Web和 Spring Web MVC。《百度百科》</p>
</blockquote>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>轻量</strong>：从大小和开销俩各方面<strong>Spring</strong> 都是轻量的。</li>
<li><strong>控制反转</strong>（<strong>Ioc</strong>）：一个对象的依赖不是通过自己创建，而是通过被动的方式传递进来。具体表现为<strong>Spring</strong>中<strong>Bean</strong>都是需要注册到<strong>Bean</strong>工厂中，将<strong>Bean</strong> 的初始化和生命周期管理交由工厂实现管理，而调用者只需知道<strong>Bean</strong>的名字就可以在容器中获得<strong>Bean</strong>的实例。</li>
<li><strong>面向切面</strong>（<strong>AOP</strong>）：<strong>Spring</strong>提供了面向切面编程的支持。允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务管理）进行内聚性的开发。</li>
<li><strong>容器：Spring</strong> 作为一个容器，可以管理对象的生命周期、对象与对象之间的依赖关系。可以通过配置文件来定义对象，以及设置其他对象的依赖关系。</li>
<li><strong>低侵入式设计，代码污染极低</strong>，独立于各种应用服务器，基于Spring框架的应用，可以真正实现<strong>Write Once,Run Anywhere</strong>。</li>
<li><strong>集成能力强</strong>：集成多种优秀的开源框架。</li>
</ul>
<img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89-Spring/framework_02.png" alt="Spring framework架构提" style="zoom:75%;">



<h4 id="核心容器（Core-Container）"><a href="#核心容器（Core-Container）" class="headerlink" title="核心容器（Core Container）"></a>核心容器（Core Container）</h4><p>如图所示，<strong>Spring</strong>的核心容器是其他模块建立的基础，有<strong>Spring-core、Spring-beans、Spring-context、Spring-context-support和Spring-expression（String表达式语言）</strong>等模块组成。</p>
<ul>
<li><strong>Spring-core模块</strong>：提供了框架的基本组成部分，包括<strong>控制反转</strong>（Inversion of Control，<strong>IOC</strong>）和<strong>依赖注入</strong>（Dependency Injection，<strong>DI</strong>）功能。</li>
<li><strong>Spring-beans模块</strong>：提供了<strong>BeanFactory</strong>，是<strong>工厂模式</strong>的一个经典实现，Spring将管理对象称为<strong>Bean</strong>。</li>
<li><strong>Spring-context模块</strong>：建立在Core和Beans模块的基础之上，提供一个<strong>框架式的对象访问方式</strong>，是访问定义和配置的任何对象的媒介。<strong>ApplicationContext</strong>接口是Context模块的焦点。</li>
<li><strong>Spring-context-support模块</strong>：支持整合第三方库到Spring应用程序上下文，特别是用于高速缓存（EhCache、JCache）和任务调度（CommonJ、Quartz）的支持。</li>
<li><strong>Spring-expression模块</strong>：提供了强大的表达式语言去支持运行时查询和操作对象图。</li>
</ul>
<h5 id="spring-core"><a href="#spring-core" class="headerlink" title="spring-core"></a>spring-core</h5><p>如图显示，<strong>spring-core</strong> 目录模块（参考Spring5.x）:</p>
<ul>
<li><p><strong>asm</strong>：字节码框架，能动态改变字节码文件。（<strong>Java</strong>是静态语言，一旦编译完成无法修改，无法像动态语言例如 <strong>JS</strong> 那样在执行器可以随意添加方法、属性）；</p>
</li>
<li><p><strong>cglib</strong>：动态代理，代码生成库；</p>
</li>
<li><p><strong>core</strong>：核心包：注解和元注解、别名注册和属性访问、encode和decode输入流、转换器服务包、环境配置（profiles）、日志类、序列化和反序列化类、代码风格、可执行任务类等；</p>
</li>
<li><p><strong>lang</strong>：部分注解：@NonNull、@NonNullApi、@Nullable等；</p>
</li>
<li><p><strong>objenesis</strong>：objenesis是一个小型java类库用来实例化一个特定class的对象（非构造器）；</p>
</li>
<li><p><strong>util</strong>：工具类包，常用<strong>ObjectUtils</strong>、<strong>ClassUtils</strong>等。</p>
</li>
</ul>
<img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89-Spring/framework_03.png" alt="spring-core目录结构" style="zoom:50%;">

<h5 id="Ioc-容器"><a href="#Ioc-容器" class="headerlink" title="Ioc 容器"></a>Ioc 容器</h5><p><strong>Spring</strong> 容器是 <strong>Spring</strong> 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。<strong>Spring</strong> 容器使用<strong>依赖注入（DI）</strong>来管理组成一个应用程序的组件。这些对象被称为 <strong>Spring Beans</strong>。</p>
<p><strong>Bean</strong>是<strong>Spring</strong>框架中<strong>最核心</strong>的概念之一.</p>
<blockquote>
<p>In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container.</p>
<p>在 <strong>Spring</strong> 中，构成应用程序<strong>主干</strong>并由<strong>Spring IoC容器</strong>管理的<strong>对象</strong>称为<strong>bean</strong>。<strong>bean</strong>是一个由<strong>Spring IoC</strong>容器实例化、组装和管理的<strong>对象</strong>。</p>
</blockquote>
<p><strong>BeanFactory</strong></p>
<p><strong>Bean</strong>的创建是典型的工厂模式，顶级接口为 <strong><em>BeanFactory</em></strong> ；</p>
<p><strong>Spring</strong> 使用 <strong>BeanFactory</strong> 来实例化、配置和管理 <strong>Bean</strong>；</p>
<p><strong>BeanFactory</strong> 只能管理单例（Singleton）<strong>Bean</strong> 的生命周期。它不能管理原型 (prototype, 非单例) <strong>Bean</strong> 的生命周期；</p>
<p><strong>BeanFactory</strong> 有着庞大的继承、实现体系，有众多的子接口、实现类。</p>
<img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89-Spring/framework_04.png" alt="BeanFactory基本类体系结构" style="zoom:80%;">

<ul>
<li><p>一级接口：<strong>BeanFactory</strong> 作为主接口，不继承任何接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.ResolvableType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 工厂Bean前缀</span></span><br><span class="line">	String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Bean 的方法</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, @Nullable Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断：是否包含，是否是单例，是否是属性，类型是否匹配</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, @Nullable Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取类型</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取别名</span></span><br><span class="line">	String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二级接口：<strong><em>ListableBeanFactory</em></strong>、<strong><em>AutowireCapableBeanFactory</em></strong>、<strong><em>HierarchicalBeanFactory</em></strong> 三个接口继承了 <strong>BeanFactory</strong> ，功能上得到了增强。</p>
</li>
<li><p>三级接口：<strong><em>ConfigurableBeanFactory</em></strong> 对 二级接口 <strong><em>HierarchicalBeanFactory</em></strong> 再次增强，此外还继承了 <strong><em>SingletonBeanRegistry</em></strong> 接口。</p>
</li>
<li><p>四级接口：<strong><em>ConfigurableListableBeanFactory</em></strong> 继承了以上所有接口，功能最为强大。</p>
</li>
<li><p>一级抽象类：<strong><em>AbstractBeanFactory</em></strong> 实现了 三级接口  <strong><em>ConfigurableBeanFactory</em></strong> 的功能。</p>
</li>
<li><p>二级抽象类：<strong><em>AbstractAutowireCapableBeanFactory</em></strong> 继承自 <strong><em>AbstractBeanFactory</em></strong> 抽象类，并实现了二级接口 <strong><em>AutowireCapableBeanFactory</em></strong> 的功能。</p>
</li>
<li><p>实现类：<strong><em>DefaultListableBeanFactory</em></strong> 并非抽象类，其继承了二级抽象类 <strong><em>AbstractAutowireCapableBeanFactory</em></strong> ，并且实现了四级接口 <strong><em>ConfigurableListableBeanFactory</em></strong> 的功能。</p>
</li>
<li><p>实现类：<strong><em>XmlBeanFactory</em></strong> 继承自 <strong><em>DefaultListableBeanFactory</em></strong>，重写了部分功能，可以从<strong>classpath</strong>或文件系统等获取资源。</p>
</li>
</ul>
<p><strong>几点说明：</strong></p>
<ul>
<li><strong>XmlBeanFactory</strong>通过 <strong>Resource</strong> 装载 <strong>Spring</strong> 配置信息并启动 <strong>IoC</strong> 容器，然后就可以通过<strong><em>factory.getBean</em></strong>从 <strong>IoC</strong> 容器中获取 <strong>Bean</strong> 了。</li>
<li><strong>BeanFactroy</strong>采用的是延迟加载形式来注入<strong>Bean</strong>的，通过<strong>BeanFactory</strong>启动<strong>IoC</strong>容器时，并不会初始化配置文件中定义的<strong>Bean</strong>，初始化动作发生在第一个调用时。（即只有在使用到某个<strong>Bean</strong>时(调用<strong><em>getBean()</em></strong>)，才对该<strong>Bean</strong>进行加载实例化）（<strong><em>ApplicationContext</em></strong> 与之相反，在容器启动时，一次性创建了所有的<strong>Bean</strong>。这样，在容器启动时，就可以发现<strong>Spring</strong>中存在的配置错误。但缺点是占用更多内存，当配置<strong>Bean</strong>较多时，程序启动较慢，可以通过配置懒加载的方式提升启动速度。）</li>
<li>对于单实例（singleton）的<strong>Bean</strong>来说，<strong>BeanFactory</strong>会缓存<strong>Bean</strong>实例，所以第二次使用<strong>getBean</strong>时直接从<strong>IoC</strong>容器缓存中获取<strong>Bean</strong>。</li>
<li><strong><em>BeanFactory</em></strong> 主要面对的是<strong>Spring</strong> 框架的基础设施，通常开发者使用的则是 <strong><em>ApplicationContext</em></strong>。</li>
</ul>
<p><strong>ApplicationContext</strong></p>
<p><strong>ApplicationContext</strong> 由 <strong>BeanFactory</strong> 派生而来，提供了更多面向实际应用的功能。</p>
<ul>
<li>访问应用程序组件的<strong>Bean</strong>工厂方法。继承自  <strong><em>ListableBeanFactory</em></strong> 、<strong><em>HierarchicalBeanFactory</em></strong> 接口；</li>
<li>以通用方式加载文件资源的能力。继承自 <strong><em>ResourceLoader</em></strong> 接口；</li>
<li>向注册侦听器发布事件的能力。继承自 <strong><em>ApplicationEventPublisher</em></strong> 接口；</li>
<li>解析消息的能力，支持国际化。继承自 <strong>MessageSource</strong> 接口；</li>
<li>从父上下文继承。后代上下文中的定义总是优先。单个父上下文可以被整个<strong>web</strong>应用程序使用，而每个<strong>servlet</strong>都有自己独立于任何其他<strong>servlet</strong>的子上下文。</li>
</ul>
<p>常用子类（接口）包括：</p>
<ul>
<li><p><strong>ConfigurableApplicationContext</strong></p>
<ul>
<li><p><strong>ClassPathXmlApplicationContext</strong> 从<strong>classpath</strong>的<strong><em>xml</em></strong>配置文件创建，可以从<strong><em>jar</em></strong>包中读取配置文件。ClassPathXmlApplicationContext 编译路径总有三种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext factory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">ApplicationContext factory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>); </span><br><span class="line">ApplicationContext factory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"file:E:/demo/applicationContext.xml"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>FileSystemXmlApplicationContext</strong> 从文件系统或者<strong><em>url</em></strong>指定的<strong><em>xml</em></strong>配置文件创建，参数为配置文件名或文件名数组，有相对路径与绝对路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext factory=<span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"src/applicationContext.xml"</span>);</span><br><span class="line">ApplicationContext factory=<span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"E:/demo/applicationContext.xml"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>WebApplicationContext</strong></p>
<ul>
<li><p><strong>XmlWebApplicationContext</strong> 从<strong><em>web</em></strong>应用的根目录读取配置文件，需要先在<strong><em>web.xml</em></strong>中配置，可以配置<strong>监听器</strong>或者<strong>servlet</strong>来实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- listener --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者 servlet --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>context<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.context.ContextLoaderServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上两种方式都默认配置文件为<strong><em>WEB-INF/applicationContext.xml</em></strong>，也可使用<strong><em>context-param</em></strong>指定配置文件:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/myApplicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h4 id="Spring-初始化"><a href="#Spring-初始化" class="headerlink" title="Spring 初始化"></a>Spring 初始化</h4><h5 id="Bean-的定义"><a href="#Bean-的定义" class="headerlink" title="Bean 的定义"></a>Bean 的定义</h5><p><strong>Bean</strong> 是一个被实例化，组装，并通过 <strong>Spring IoC 容器</strong>所管理的对象，这些 <strong>bean</strong> 是由用容器提供的配置元数据创建的。</p>
<p>元数据包含：</p>
<ul>
<li>如何创建一个 bean；</li>
<li>bean 的生命周期的详细信息；</li>
<li>bean 的依赖关系。</li>
</ul>
<p>具体对应属性如下：</p>
<ul>
<li><strong>class</strong>：指定用来创建 <strong>bean</strong> 的 <strong>bean</strong> 类。</li>
<li><strong>name</strong>：用来指定唯一的 <strong>bean</strong> 标识符；例如基于<strong><em>xml</em></strong>配置的元数据中，使用 <strong>id</strong> 或 <strong>name</strong> 属性定义 <strong>Bean</strong> 标识符；基于注解方式时， <strong>@Component、@Service</strong> 等可以指定名称，或类型的首字母小写。  </li>
<li><strong>scope</strong>：对象 做用域 ；</li>
<li><strong>constructor-arg</strong>：构造器参数；</li>
<li><strong>properties</strong>：属性；</li>
<li><strong>autowiring mode</strong>: 自动注入模式；</li>
<li><strong>lazy-initialization mode</strong>: 懒加载模式；</li>
<li><strong>initialization 方法</strong>：初始化方法；</li>
<li><strong>destruction 方法</strong>：摧毁方法。</li>
</ul>
<p><strong>Spring 配置 元数据</strong></p>
<ul>
<li>基于 XML 的配置文件。例如：classpath:applicationContext.xml</li>
<li>基于 注解的配置。例如：@Component、@Controller、@Service、@Repository 等</li>
<li>基于 Java 的配置。例如：@Bean 注解的方法里面 通过构造方法或者 构造者模式等构建bean返回。</li>
</ul>
<h5 id="Bean-的做用域"><a href="#Bean-的做用域" class="headerlink" title="Bean 的做用域"></a>Bean 的做用域</h5><table>
<thead>
<tr>
<th align="left">作用域</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>singleton</strong></td>
<td align="left">该作用域将 <strong>bean</strong> 的定义的限制在每一个 <strong>Spring IoC</strong> 容器中的一个单一实例(默认)。</td>
</tr>
<tr>
<td align="left"><strong>prototype</strong></td>
<td align="left">该作用域将单一 <strong>bean</strong> 的定义限制在任意数量的对象实例。</td>
</tr>
<tr>
<td align="left"><strong>request</strong></td>
<td align="left">该作用域将 <strong>bean</strong> 的定义限制为 <strong>HTTP</strong> 请求。只在 <strong>web-aware Spring ApplicationContext</strong> 的上下文中有效。</td>
</tr>
<tr>
<td align="left"><strong>session</strong></td>
<td align="left">该作用域将 <strong>bean</strong> 的定义限制为 <strong>HTTP</strong> 会话。 只在<strong>web-aware Spring ApplicationContext</strong>的上下文中有效。</td>
</tr>
<tr>
<td align="left"><strong>global-session</strong></td>
<td align="left">该作用域将 <strong>bean</strong> 的定义限制为全局 <strong>HTTP</strong> 会话。只在 <strong>web-aware Spring ApplicationContext</strong> 的上下文中有效。</td>
</tr>
</tbody></table>
<ul>
<li><strong>singleton 作用域</strong></li>
</ul>
<p>如果作用域设置为 <strong>singleton</strong>，那么 <strong>Spring IoC</strong> 容器刚好创建一个由该 <strong>bean</strong> 定义的对象的实例。该单一实例将存储在这种单例 <strong>bean</strong> 的高速缓存中，以及针对该 <strong>bean</strong> 的所有后续的请求和引用都返回缓存对象。</p>
<ul>
<li><strong>prototype 作用域</strong></li>
</ul>
<p>如果作用域设置为 <strong>prototype</strong>，那么每次特定的 <strong>bean</strong> 发出请求时 <strong>Spring IoC</strong> 容器就创建对象的新的 <strong>Bean</strong> 实例。一般说来，满状态的 <strong>bean</strong> 使用 <strong>prototype</strong> 作用域和没有状态的 <strong>bean</strong> 使用 <strong>singleton</strong> 作用域。</p>
<h5 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h5><p>​    前面说到当客户端通过显示或者隐式的方式调用 <strong>BeanFactory</strong> 的 <strong>getBean()</strong> 方法来请求某个实例对象的时候，会触发相应 <strong>bean</strong> 的实例化进程，（使用 <strong>ApplicationContext</strong> 容器时，该容器启动的时候会立刻调用注册到该容器所有 <strong>bean</strong> 定义的实例化方法。其次对于<strong>signleton</strong> 类型的 <strong>bean</strong>，该类型的 <strong>bean</strong> 只会在第一次调用 <strong>getBean()</strong> 的时候才会触发，而后续的调用则会直接返回容器<strong>缓存</strong>中的实例对象。）</p>
<p><strong>getBean</strong>() 只是 <strong>bean</strong> 实例化进程的入口，真正的实现逻辑其实是在 <strong>AbstractAutowireCapableBeanFactory</strong> 的 <strong>doCreateBean</strong>() 实现：</p>
<img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89-Spring/framework_05.png" alt="Bean的实例化过程" style="zoom:65%;">

<p>原来我们采用 <strong>new</strong> 的方式创建对象，用完对象在其脱离作用域后就会被回收，对于后续操作我们无权也没法干涉，但是采用 <strong>Spring</strong> 容器后，<strong>Spring</strong> 容器将会对其所有管理的 <strong>Bean</strong> 对象全部给予一个统一的生命周期管理，同时在这个阶段我们也可以对其进行干涉（比如对 <strong>bean</strong> 进行<strong>增强处理</strong>，对 <strong>bean</strong> 进行篡改等）</p>
<p>观察 源码 <strong>doCreateBean</strong>() 可知，核心的方法如下：</p>
<ul>
<li><strong>createBeanInstance()</strong> 创建Bean 实例；</li>
<li><strong>populateBean()</strong> 填充 bean 里面的属性值，包括 @AutoWired、@Resource、@Value 标记的属性；</li>
<li><strong>initializeBean()</strong> 对 Bean 进行初始化操作，包括一些初始化方法的执行。</li>
</ul>
<p><strong>激活 Aware 接口</strong></p>
<p>当 <strong>Spring</strong> 完成 <strong>bean 对象实例化</strong>并且<strong>设置完相关属性和依赖</strong>后，则会开始 <strong>bean</strong> 的初始化进程<strong><em>initializeBean()</em></strong>，初始化第一个阶段是检查当前 <strong>bean</strong> 对象是否实现了一系列以 <strong>Aware</strong> 结尾的的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">               invokeAwareMethods(beanName, bean);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;, getAccessControlContext());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           invokeAwareMethods(beanName, bean);</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否实现Aware接口</span></span><br><span class="line"><span class="comment">// 在初始化阶段主要是感知 BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">			((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">			ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">			<span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">				((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">			((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>BeanNameAware</strong>：对该 <strong>bean</strong> 对象定义的 <strong>beanName</strong> 设置到当前对象实例中</li>
<li><strong>BeanClassLoaderAware</strong>：将当前 <strong>bean</strong> 对象相应的 <strong>ClassLoader</strong> 注入到当前对象实例</li>
<li><strong>BeanFactoryAware：BeanFactory</strong> 容器会将自身注入到当前对象实例中，这样当前对象就会拥有一个 <strong>BeanFactory</strong> 容器的引用。</li>
</ul>
<p>除此之外还有一些其他的 <strong>Aware</strong> 接口：</p>
<ul>
<li><p><strong>LoadTimeWeaverAware</strong>：加载Spring Bean时织入第三方模块，如AspectJ</p>
</li>
<li><p><strong>BootstrapContextAware</strong>：资源适配器BootstrapContext，如JCA,CCI</p>
</li>
<li><p><strong>ResourceLoaderAware</strong>：底层访问资源的加载器</p>
</li>
<li><p><strong>PortletConfigAware</strong>：PortletConfig</p>
</li>
<li><p><strong>PortletContextAware</strong>：PortletContext</p>
</li>
<li><p><strong>ServletConfigAware</strong>：ServletConfig</p>
</li>
<li><p><strong>ServletContextAware</strong>：ServletContext</p>
</li>
<li><p><strong>MessageSourceAware</strong>：国际化</p>
</li>
<li><p><strong>ApplicationEventPublisherAware</strong>：应用事件</p>
</li>
<li><p><strong>NotificationPublisherAware</strong>：JMX通知</p>
</li>
</ul>
<p><strong>BeanPostProcessor</strong></p>
<p><strong><em>BeanPostProcessor</em></strong> 会处理当前容器内所有符合条件的实例化后的 <strong>bean</strong> 对象。并对该对象进行有效的扩展，允许 <strong>Spring</strong> 在初始化 <strong>bean</strong> 阶段对其进行定制化修改，如处理标记接口或者为其提供代理实现等。</p>
<p><strong>BeanPostProcessor</strong> 接口提供了两个方法，在不同的时机执行，分别对应上图的前置处理和后置处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">     <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">     <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>InitializingBean 和 init-method</strong></p>
<ul>
<li><p><strong>InitializingBean</strong> 是一个接口，它为 <strong>Spring Bean</strong> 的初始化提供了一种方式，它有一个 <strong>afterPropertiesSet</strong>() 方法。</p>
</li>
<li><p><strong>init-method</strong> 是初始化方法，在对象定义时指定，例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.example.demo.dto.UserDTO"</span> id=<span class="string">"user"</span> init-method=<span class="string">"init"</span>&gt;</span><br><span class="line">    &lt;property name="name" value="张三"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>bean</strong> 的初始化进程中会判断先当前 <strong>bean</strong> 是否实现了 <strong>InitializingBean</strong>，如果实现了则调用 <strong>afterPropertiesSet</strong>() 进行初始化工作。然后再检查是否也指定了 <strong>init-method()</strong>，如果指定了则通过反射机制调用指定的 <strong>init-method()</strong>。</p>
</li>
<li><p>推荐使用 <strong>init-method()</strong> 方式，因为实现接口会污染应用程序，造成一定代码入侵。</p>
</li>
</ul>
<p><strong>DisposableBean 和 destroy-method</strong></p>
<p>与 <strong>InitializingBean</strong> 和 <strong>init-method</strong> 用于对象的自定义初始化工作相似，<strong>DisposableBean</strong>和 <strong>destroy-method</strong> 则用于对象的自定义销毁工作。</p>
<p>当一个 <strong>bean</strong> 对象经历了实例化、设置属性、初始化阶段,那么该 <strong>bean</strong> 对象就可以供容器使用了（调用的过程）。当完成调用后，如果是 <strong>singleton</strong> 类型的 <strong>bean</strong> ，则会看当前 <strong>bean</strong> 是否应实现了 <strong>DisposableBean</strong> 接口或者配置了 <strong>destroy-method</strong> 属性，如果是的话，则会为该实例注册一个用于对象销毁的回调方法，便于在这些 <strong>singleton</strong> 类型的 <strong>bean</strong> 对象销毁之前执行销毁逻辑。</p>
<p>但是，并不是对象完成调用后就会立刻执行销毁方法，因为这个时候 <strong>Spring</strong> 容器还处于运行阶段，只有<strong>当 Spring 容器关闭的时候才会去调用</strong>。但是， <strong>Spring</strong> 容器不会这么聪明会自动去调用这些销毁方法，而是需要我们主动去告知 <strong>Spring</strong> 容器。</p>
<ul>
<li>对于 <strong>BeanFactory</strong> 容器而言，我们需要主动调用 <strong>destroySingletons()</strong> 通知 <strong>BeanFactory</strong> 容器去执行相应的销毁方法。</li>
<li>对于 <strong>ApplicationContext</strong> 容器而言调用 <strong>registerShutdownHook</strong>() 方法。</li>
</ul>
<p>拓展：<strong>InstantiationAwareBeanPostProcessor</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由源码可知，<strong>InstantiationAwareBeanPostProcessor</strong> 接口继承自 <strong><em>BeanPostProcessor</em></strong> 接口，但其内部还有三个额外方法：</p>
<ul>
<li><strong>postProcessBeforeInstantiation</strong>： 自身方法，是最先执行的方法，它在目标对象实例化之前调用，该方法的返回值类型是Object，我们可以返回任何类型的值。由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(比如代理对象)。如果该方法的返回值代替原本该生成的目标对象，后续只有<strong>postProcessAfterInitialization</strong>方法会调用，其它方法不再调用；否则按照正常的流程走。</li>
<li><strong>postProcessAfterInstantiation</strong>：在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置，都是null。因为它的返回值是决定要不要调用 <strong>postProcessPropertyValues</strong>方法的其中一个因素（因为还有一个因素是<strong><em>mbd.getDependencyCheck()</em></strong>）；如果该方法返回<strong>false</strong>,并且不需要<strong>check</strong>，那么<strong>postProcessPropertyValues</strong>就会被忽略不执行；如果返回<strong>true</strong>，<strong>postProcessPropertyValues</strong>就会被执行。</li>
<li><strong>postProcessPropertyValues</strong>：对属性值进行修改，如果<strong>postProcessAfterInstantiation</strong>方法返回<strong>false</strong>，该方法可能不会被调用。可以在该方法内对属性值进行修改。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * 自定义处理器</span><br><span class="line"> * <span class="meta">@author</span> dengp</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BeanPostProcessor接口中的方法</span></span><br><span class="line"><span class="comment">     * 在Bean的自定义初始化方法之前执行</span></span><br><span class="line"><span class="comment">     * Bean对象已经存在了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"》》》初始化前：postProcessBeforeInitialization"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BeanPostProcessor接口中的方法</span></span><br><span class="line"><span class="comment">     * 在Bean的自定义初始化方法执行完成之后执行</span></span><br><span class="line"><span class="comment">     * Bean对象已经存在了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"》》》初始化后：postProcessAfterInitialization"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * InstantiationAwareBeanPostProcessor中自定义的方法</span></span><br><span class="line"><span class="comment">     * 在方法实例化之前执行  Bean对象还没有</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"》》》实例化前：postProcessBeforeInstantiation"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * InstantiationAwareBeanPostProcessor中自定义的方法</span></span><br><span class="line"><span class="comment">     * 在方法实例化之后执行  Bean对象已经创建出来了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"》》》实例化后：postProcessAfterInstantiation"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * InstantiationAwareBeanPostProcessor中自定义的方法</span></span><br><span class="line"><span class="comment">     * 可以用来修改Bean中属性的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"》》》设置属性：postProcessPropertyValues"</span>);</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserDTO 对象</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDTO</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"》》》DTO 内对象被实例化..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"》》》DTO 内自定义初始化的方法...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"》》》DTO 内set方法属性设置："</span>+ name);</span><br><span class="line">        <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UserDTO&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>applicationContext.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string"> http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.example.demo.dto.UserDTO"</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">init-method</span>=<span class="string">"start"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册InstantiationAwareBeanPostProcessor对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.example.demo.beanpost.MyInstantiationAwareBeanPostProcessor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Test 调用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBeanPostProcessorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    UserDTO user = ac.getBean(UserDTO<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="comment">// 关闭销毁</span></span><br><span class="line">    ac.registerShutdownHook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>日志打印：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">》》》实例化前：postProcessBeforeInstantiation</span><br><span class="line">》》》DTO 内对象被实例化...</span><br><span class="line">》》》实例化后：postProcessAfterInstantiation</span><br><span class="line">》》》设置属性：postProcessPropertyValues</span><br><span class="line">》》》DTO 内set方法属性设置：张三</span><br><span class="line">》》》初始化前：postProcessBeforeInitialization</span><br><span class="line"><span class="comment">// 如果该 bean 实现了 InitializingBean 接口，则调用 .afterPropertiesSet() 方法</span></span><br><span class="line">》》》DTO 内自定义初始化的方法....</span><br><span class="line">》》》初始化后：postProcessAfterInitialization</span><br><span class="line"><span class="comment">// 对象完成初始化，开始方法调用。</span></span><br><span class="line"><span class="comment">// 在容器进行关闭之前，如果该 bean 实现了 DisposableBean 接口，则调用 destroy() 方法。</span></span><br><span class="line"><span class="comment">// 在容器进行关闭之前，如果该 bean 配置了 destroy-mehod，则调用其指定的方法。</span></span><br><span class="line"></span><br><span class="line">UserDTO&#123;name=<span class="string">'张三'</span>, age=<span class="string">'null'</span>&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Spring-事件机制"><a href="#Spring-事件机制" class="headerlink" title="Spring 事件机制"></a>Spring 事件机制</h4><p><strong>Spring</strong>事件机制分为：</p>
<ul>
<li>事件发布器(<strong>EventPublisher</strong>)</li>
<li>事件监听器(<strong>EventListener</strong>)</li>
<li>事件多播器(<strong>ApplicationEventMulticaster</strong>)。</li>
</ul>
<p><strong>Spring</strong> 事件机制对应常用设计模式之<strong>观察者模式</strong>，主要就是用来解耦。<br><strong>Spring</strong> 的 <strong>ApplicationContext</strong> 提供了支持事件和代码中监听器的功能。我们可以创建 <strong>bean</strong> 用来监听在 <strong>ApplicationContext</strong> 中发布的事件。如果一个 <strong>bean</strong> 实现了 <strong>ApplicationListener</strong> 接口，当一个 <strong>ApplicationEvent</strong> 被发布以后，<strong>bean</strong> 会自动被通知。</p>
<p><strong>事件发布器 （EventPublisher）</strong></p>
<p>事件发布对象实现 <strong>ApplicationEventPublisherAware</strong> 这个<strong>Aware</strong> 接口，<strong>广播事件</strong>动作需要利用到<strong><em>applicationEventPublisher</em></strong>，所以 事件发布器中需要注入该对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义事件发布器，实现ApplicationEventPublisherAware 接口</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventPublish</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">       <span class="comment">// 发布事件，这里非 ApplicationEvent 对象，会被封装成 PayloadApplicationEvent&lt;String&gt;</span></span><br><span class="line">       applicationEventPublisher.publishEvent(msg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>事件对象：</strong></p>
<ul>
<li><strong>ApplicationEvent</strong> 为事件本身，用户可以继承该对象向实现自定义<strong>Event</strong></li>
<li>也可以 是<strong>Object</strong> 对象（如上面的<strong>String</strong>），但是如果<strong>event</strong>真实类型不是<strong>ApplicationEvent</strong>的话，那么<strong>event</strong>会被封装成<strong>PayloadApplicationEvent</strong></li>
</ul>
<p><strong>事件监听器（EventListener）</strong></p>
<p>事件监听者需要实现<strong>ApplicationListener</strong>接口，也可以 在方法上使用 <strong><em>@EventListener</em></strong> 注解（原理是通过扫描这个注解来创建监听器并自动添加到<strong>ApplicationContext</strong>中.）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里事件为String，所以监听器泛型为封装的 PayloadApplicationEvent&lt;String&gt; 对象</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">PayloadApplicationEvent</span>&lt;<span class="title">String</span>&gt;&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(PayloadApplicationEvent event)</span> </span>&#123;</span><br><span class="line">       String msg =(String) event.getPayload();</span><br><span class="line">       System.out.println(<span class="string">"ListenerA receive:"</span> + msg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>指定事件（<strong>ApplicationEvent</strong> 类型实现类和 <strong>PayloadApplicationEvent</strong><Object>）监听器可以监听到指定的事件。</Object></p>
</li>
<li><p>发布的事件类型是<strong>ApplicationEvent</strong>的实现类<strong>A</strong>，那么所有监听者的<strong>onApplicationEvent</strong>的参数类型是<strong>A</strong>或者<strong>A的子类</strong>都会收到事件。</p>
</li>
</ul>
<p><strong>事件多播器（ApplicationEventMulticaster）</strong></p>
<p><strong>ApplicationEventMulticaster</strong> 接口可以管理多个<strong>ApplicationListener</strong>对象。并将事件发布给这些监听器。</p>
<p><strong>ApplicationContext</strong>正是通过<strong>ApplicationEventMulticaster</strong>对象来发布事件给监听器。</p>
<p><strong>Spring</strong> 在创建默认的事件多播器 <strong>SimpleApplicationEventMulticaster</strong> 时，<strong>taskExecutor</strong> 属性默认是<strong>null</strong>，所以默认情况下所有的监听器的 <strong>onApplicationEvent</strong> 是直接在<strong>当前线程</strong>(事件发布者所在线程)中调用。如果 <strong>onApplicationEvent</strong> 有阻塞操作也会导致事件发布者被阻塞，后续的其他监听器也会被阻塞无法调用。<br>我们可以为默认事件多播器设置 <strong>taskExecutor</strong> 属性，从而达到异步监听的目的。</p>
<p><strong>XML方式配置：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"executorService"</span> <span class="attr">class</span>=<span class="string">"java.util.concurrent.Executors"</span> <span class="attr">factory-method</span>=<span class="string">"newScheduledThreadPool"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"applicationEventMulticaster"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.event.SimpleApplicationEventMulticaster"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"taskExecutor"</span> <span class="attr">ref</span>=<span class="string">"executorService"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<strong><em>AbstractApplicationContext.refresh()</em></strong> 方法中进行刷新时有调用 <strong><em>initApplicationEventMulticaster</em></strong> 方法进行初始化容器事件广播器，并放入至上下文的<strong><em>applicationEventMulticaster</em></strong> 属性中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取beanFactory</span></span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="comment">//从beanFactory中获取事件广播器</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="comment">//如果有，则赋值给applicationEventMulticaster</span></span><br><span class="line">		<span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">				beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//如果没有，则创建一个SimpleApplicationEventMulticaster</span></span><br><span class="line">		<span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">		<span class="comment">//将创建的SimpleApplicationEventMulticaster注册到beanFactory中</span></span><br><span class="line">		beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"No '"</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">"' bean, using "</span> +</span><br><span class="line">					<span class="string">"["</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <strong>IOC</strong> 容器初始化完成后，<strong>事件多播器</strong>也初始化完成。我们就可以直接调用 <strong>publishEvent</strong> 进行发布事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">	publishEvent(event, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(event, <span class="string">"Event must not be null"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断事件类型是否为ApplicationEvent，如果不是则封装成PayloadApplicationEvent</span></span><br><span class="line">	ApplicationEvent applicationEvent;</span><br><span class="line">	<span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">		applicationEvent = (ApplicationEvent) event;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="keyword">this</span>, event);</span><br><span class="line">		<span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">			eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 IOC 初始化过程中的早期事件需要立即进行发布</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//使用默认多播器进行事件发布</span></span><br><span class="line">		getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用父类上下文进行发布事件</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">			((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关注 <strong>ApplicationEventMulticaster</strong> 的 multicastEvent 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将给定的应用程序事件多播到适当的侦听器</span></span><br><span class="line">	multicastEvent(event, resolveDefaultEventType(event));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取到事件对应的分解类型</span></span><br><span class="line">	ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">	<span class="comment">// 获取到多播器的当前线程池</span></span><br><span class="line">	Executor executor = getTaskExecutor();</span><br><span class="line">	<span class="comment">// 获取当前应用中与给定事件类型匹配的ApplicationListeners的监听器集合，不符合的监听器会被排除在外。再循环执行</span></span><br><span class="line">	<span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">		<span class="comment">// 如果线程池不为空，则通过线程池异步执行</span></span><br><span class="line">		<span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">			executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 否则由当前线程执行</span></span><br><span class="line">			invokeListener(listener, event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">	ErrorHandler errorHandler = getErrorHandler();</span><br><span class="line">	<span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			doInvokeListener(listener, event);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">			errorHandler.handleError(err);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		doInvokeListener(listener, event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInvokeListener</span><span class="params">(ApplicationListener listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 实际监听器接受该事件并处理</span></span><br><span class="line">		listener.onApplicationEvent(event);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ClassCastException ex) &#123;</span><br><span class="line">		String msg = ex.getMessage();</span><br><span class="line">		<span class="keyword">if</span> (msg == <span class="keyword">null</span> || matchesClassCastMessage(msg, event.getClass())) &#123;</span><br><span class="line">			Log logger = LogFactory.getLog(getClass());</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">"Non-matching event type for listener: "</span> + listener, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>流程步骤如下：</strong></p>
<ol>
<li>初始化事件多播器</li>
<li>事件发布器发布事件</li>
<li>事件多播器接收到事件后，检索监听器集合得到需要执行事件处理的监听器</li>
<li>循环调用具体监听器方法处理事件</li>
</ol>
<p><strong>Spring 提供的五种标准事件：</strong></p>
<ul>
<li>上下文更新事件（<strong>ContextRefreshedEvent</strong>）：在调用<strong>ConfigurableApplicationContext</strong> 接口中的<strong><em>refresh()</em></strong>方法时被触发。</li>
<li>上下文开始事件（<strong>ContextStartedEvent</strong>）：当容器调用<strong>ConfigurableApplicationContext</strong>的<strong><em>start()</em></strong>方法开始/重新开始容器时触发该事件。</li>
<li>上下文停止事件（<strong>ContextStoppedEvent</strong>）：当容器调用<strong>ConfigurableApplicationContext</strong>的<strong><em>stop()</em></strong>方法停止容器时触发该事件。</li>
<li>上下文关闭事件（<strong>ContextClosedEvent</strong>）：当<strong>ApplicationContext</strong>被关闭时触发该事件。容器被关闭时，其管理的所有单例<strong>Bean</strong>都被销毁。</li>
<li>请求处理事件（<strong>RequestHandledEvent</strong>）：在<strong>Web</strong>应用中，当一个<strong>http</strong>请求（<strong>request</strong>）结束触发该事件。</li>
</ul>
<h4 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h4><p>将依赖关系的管理交给 <strong>Spring</strong> 维护，在当前类需要用到其他类的对象，由 <strong>Spring</strong> 为我们提供，只需要在配置文件中说明关系的维护。</p>
<p><strong>能够注入的数据：</strong></p>
<ul>
<li>基本类型和 <strong>String</strong></li>
<li>其他 <strong>Bean</strong> 类型（配置文件或者注解配置过的类）</li>
<li>复杂集合类型</li>
</ul>
<p><strong>注入方式</strong></p>
<ul>
<li><p>基于构造函数的依赖注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      构造函数注入：</span></span><br><span class="line"><span class="comment">      使用的标签：constructor-arg</span></span><br><span class="line"><span class="comment">      标签出现的位置：bean标签内部</span></span><br><span class="line"><span class="comment">      标签的属性</span></span><br><span class="line"><span class="comment">           type:用于指定要注入的数据的数据类型，该数据构造函数中某个或某些参数类型</span></span><br><span class="line"><span class="comment">           index:用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引位置从0开始</span></span><br><span class="line"><span class="comment">           name:用于指定给构造函数中指定名称的参数赋值（常用）</span></span><br><span class="line"><span class="comment">           =================以上用于指定个给构造函数中那个参数赋值==========</span></span><br><span class="line"><span class="comment">           value:用于提供基本类型和string类型数据</span></span><br><span class="line"><span class="comment">           ref:用于指定其他的bean类型数据，它指的就是在spring的Ioc核心容器中出现过的bean对象</span></span><br><span class="line"><span class="comment">       优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功</span></span><br><span class="line"><span class="comment">       弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果融不到这些数据，页必须提供</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.example.dto.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zhangsan"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置一个地址对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"com.example.dto.Address"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>  </span>&#123;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="keyword">private</span> Integer age;</span><br><span class="line">      <span class="keyword">private</span> Address address;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">(String name,Integer age,Address address)</span></span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.name=name;</span><br><span class="line">          <span class="keyword">this</span>.age=age;</span><br><span class="line">          <span class="keyword">this</span>.address=address;</span><br><span class="line">      &#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于 <strong>Set</strong> 方法的依赖注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--set方法注入      常用</span></span><br><span class="line"><span class="comment">    涉及的标签：property</span></span><br><span class="line"><span class="comment">    出现的位置：bean标签的内部</span></span><br><span class="line"><span class="comment">     name:用于注入时所调用的set方法名称</span></span><br><span class="line"><span class="comment">     value:用于提供基本类型和string类型数据</span></span><br><span class="line"><span class="comment">     ref:用于指定其他的bean类型数据，它指的就是在spring的Ioc核心容器中出现过的bean对象</span></span><br><span class="line"><span class="comment">  优势：创建对象时没有明确的限制，可以直接使用默认构造函数</span></span><br><span class="line"><span class="comment">  弊端：如果由某个成员，必须有值，则获取对象时，有可能set方法没有执行</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.example.dto.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zhangsan"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>基于 <strong>Set</strong> 方法完成负责集合类型的注入 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    复杂类型的注入/集合类型的注入</span></span><br><span class="line"><span class="comment">    用于给List结构集合注入的标签</span></span><br><span class="line"><span class="comment">         Array List Set</span></span><br><span class="line"><span class="comment">    用于给List结构集合注入的标签</span></span><br><span class="line"><span class="comment">         Map Properties</span></span><br><span class="line"><span class="comment">    结构相同，标签可以互换</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService3"</span> <span class="attr">class</span>=<span class="string">"com.li.service.impl.AccountServiceImpl3"</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- List\Set 配置相同，将 array 标签改为 list 、set即可 --&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"arrayFiled"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapFiled"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"testKey"</span> <span class="attr">value</span>=<span class="string">"aaa"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"propsFiled"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testKey"</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>注解方式</strong></p>
<ul>
<li><p>用于创建对象：作用和XML配置文件的<bean>标签的实现功能一致；</bean></p>
<ol>
<li><p><strong>@Component</strong>: 作用：用于当前类存入<strong>spring</strong>容器</p>
<p>属性：<strong>value</strong>: 用于指定bean的id，当我们不写时，默认为当前类的名称且首字母小写。</p>
</li>
<li><p><strong>@Controller</strong> : 用于表现层</p>
</li>
<li><p><strong>@Service</strong>: 用于业务层</p>
</li>
<li><p><strong>@Repository</strong>: 用于持久层</p>
</li>
</ol>
</li>
<li><p>用于注入数据：作用和XML配置文件中的bean标签中的<property>作用一样；</property></p>
<ol>
<li><p><strong>@Autowried（byType）</strong></p>
<p>作用：自动按<strong>类型</strong>注入，只要容器中由唯一的bean对象类型和要注入的变量类型匹配，就可以成功注入</p>
<p>位置：可以为成员变量，也可以为方法</p>
</li>
<li><p><strong>@Qualifier</strong></p>
<p>作用：再按照<strong>类型</strong>注入的基础之上再按照<strong>名称</strong>注入，它在给类成员注入时不能单独使用，和<strong>Autowired</strong>配合使用，但是给方法注入时可以。</p>
<p>属性：value：用于指定注入bean的id</p>
</li>
<li><p><strong>@Resources（byName）</strong> </p>
<p>作用：属于<strong><em>JSR-250</em></strong>规范定义的注解，支持根据<strong>类型和名称</strong>进行对象注入，它可以独立使用</p>
<p>属性：name:用于指定bean的id</p>
<p> <strong>以上三种注入只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现</strong></p>
</li>
<li><p><strong>@Value</strong></p>
<p>作用：用于注入基本类型和<strong>String</strong>类型数据</p>
<p>属性：value：用于指定数据的值，它可以使用spring中的spEL(也就是spring的el表达式)</p>
<p>SpEl的写法：${表达式}     </p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>用于改变作用范围：作用和在<strong>bean</strong>标签中使用<strong>scope</strong>属性实现的功能一样的</p>
<p><strong>@Scope</strong> </p>
<p>作用：用于指定bean的作用范围</p>
<p>属性：value:指定范围取值。常用的值：singleton(单例) prototype(多例）</p>
</li>
<li><p>和生命周期相关：作用和在bean标签中使用<strong>init-method</strong>和<strong>destroy-method</strong>的作用一样</p>
<p><strong>@PreDestroy</strong>：用于指定销毁，属于<strong><em>JSR-250</em></strong>规范定义的注解</p>
<p><strong>@PostConstruct</strong>：用于指定初始化，属于<strong><em>JSR-250</em></strong>规范定义的注解</p>
</li>
</ul>
<h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><p><strong>AOP （Aspect Orient Programming）</strong>,直译过来就是 <strong>面向切面编程</strong>。<strong>AOP</strong> 是一种编程思想，是面向对象编程（<strong>OOP</strong>）的一种补充。</p>
<p><strong>AOP</strong> 要达到的效果是，保证开发者不修改源代码的前提下，去为系统中的业务组件添加某种通用功能。</p>
<ul>
<li><strong>静态 AOP 实现</strong>： AOP 框架在编译阶段对程序源代码进行修改，生成了静态的 AOP 代理类（生成的 *.class 文件已经被改掉了，需要使用特定的编译器），比如<strong>AspectJ</strong>。</li>
<li><strong>动态 AOP 实现</strong>： AOP 框架在运行阶段对动态生成代理对象（在内存中以 JDK 动态代理，或 CGlib 动态地生成 AOP 代理类），如 <strong>SpringAOP</strong>。</li>
</ul>
<p><strong>AOP 领域中的特性术语：</strong></p>
<ul>
<li><strong>通知（Advice</strong>）: <strong>AOP</strong> 框架中的增强处理。通知描述了切面何时执行以及如何执行增强处理。</li>
<li><strong>连接点（join point</strong>）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用。</li>
<li><strong>切点（PointCut）</strong>: 可以插入增强处理的连接点。</li>
<li><strong>切面（Aspect）</strong>: 切面是通知和切点的结合。</li>
<li><strong>引入（Introduction）</strong>：引入允许我们向现有的类添加新的方法或者属性。</li>
<li><strong>织入（Weaving）</strong>: 将增强处理添加到目标对象中，并创建一个被增强的对象，这个过程就是织入。</li>
<li><strong>目标对象（Target Object）</strong>: 包含连接点的对象。也被称作被通知或被代理对象。POJO</li>
<li><strong>AOP代理（AOP Proxy）</strong>: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是<strong>JDK动态代理</strong>或者<strong>CGLIB代理</strong>。</li>
</ul>
<p><strong>Spring AOP</strong></p>
<p><strong>AOP</strong>编程可不是<strong>Spring</strong>独有的，<strong>Spring</strong>只是支持<strong>AOP</strong>编程的框架之一。</p>
<p><strong>AOP</strong>分两类，一类可以对方法的参数进行拦截，一类是对方法进行拦截，<strong>SpringAOP</strong>属于后者，所以<strong>Spring</strong>的<strong>AOP</strong>是属于方法级的</p>
<p><strong>通知类型：</strong></p>
<ul>
<li><strong>前置通知（Before）</strong>： 标识一个前置增强方法，相当于<strong>BeforeAdvice</strong>的功能.</li>
<li><strong>后置通知（After）</strong>： final增强，不管是抛出异常或者正常退出都会执行.</li>
<li><strong>返回后通知（AfterReturning）</strong>： 后置增强，似于<strong>AfterReturningAdvice</strong>, 方法正常退出时执行.</li>
<li><strong>异常后通知（AfterThrowing）</strong>： 异常抛出增强，相当于<strong>ThrowsAdvice</strong>.</li>
<li><strong>环绕通知（Around）</strong>： 环绕增强，相当于<strong>MethodInterceptor</strong>.</li>
</ul>
<p><strong>execution</strong>：用于匹配方法执行的连接点；</p>
<p><strong>Spring</strong> 支持 基于 <strong>XML配置</strong> 和 基于<strong>@AspectJ</strong> 注解 俩种方式来实现自定义 方面。</p>
<ul>
<li><strong>XML Schema based：</strong>方面是使用常规类以及基于配置的 XML 来实现的。</li>
<li><strong>@AspectJ based：</strong>@AspectJ 引用一种声明方面的风格作为带有 Java 5 注释的常规 Java 类注释。</li>
</ul>
<p><strong>基于 XML配置方式</strong></p>
<p>配置 AOP xml 配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 描述中使用 aop 命名空间标签 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- bean definition &amp; AOP specific configuration --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 目标对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetObject"</span> <span class="attr">class</span>=<span class="string">"com.example.aop.argetObject"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 切面类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aspect"</span> <span class="attr">class</span>=<span class="string">"com.example.aop.Aspect"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 面向切面编程 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义切面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"aspect"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--定义切点--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"action"</span> <span class="attr">expression</span>=<span class="string">"execution(* *.*(..))"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 声明前置通知 (在切点方法被执行前调用)--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforeMethod"</span> <span class="attr">pointcut-ref</span>=<span class="string">"action"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 声明后置通知 (在切点方法被执行后调用)--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"afterMethod"</span> <span class="attr">pointcut-ref</span>=<span class="string">"action"</span>/&gt;</span></span><br><span class="line">            .....</span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>基于 @Aspect 注解方式</strong></p>
<ul>
<li>首先要开启<strong>@Aspect</strong> 支持（applicationContext.xml）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mybatis-spring</span>=<span class="string">"http://mybatis.org/schema/mybatis-spring"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置开启@Aspect支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义<strong>Aspect</strong> 类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.aop;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切点表达式:</span></span><br><span class="line"><span class="comment">     *     ..两个点表明多个，*代表一个</span></span><br><span class="line"><span class="comment">     *     表达式代表切入com..service包下的所有类的所有方法，方法参数不限，返回类型不限。  </span></span><br><span class="line"><span class="comment">     *  其中访问修饰符可以不写，不能用*，，第一个*代表返回类型不限，第二个*表示所有类，第三个*表示所有方法，..两个点表示方法里的参数不限。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String POINT_CUT = <span class="string">"execution(* com..service.*.*(..))"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 命名切点</span></span><br><span class="line"><span class="comment">     * public 切点可访问性修饰符</span></span><br><span class="line"><span class="comment">     *         与类可访问性修饰符的功能是相同的，它可以决定定义的切点可以在哪些类中可使用。</span></span><br><span class="line"><span class="comment">     * pointCut 切点名称</span></span><br><span class="line"><span class="comment">     * void   返回类型</span></span><br><span class="line"><span class="comment">     *     因为命名切点仅利用方法名及访问修饰符的信息，</span></span><br><span class="line"><span class="comment">     *  一般定义方法的返回类型为 void ，并且方法体为空 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(POINT_CUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切点方法之前执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(value=<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@Before：切点方法之前执行....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切点方法之后执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span>(value=<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@After：切点方法之后执行....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 切点方法返回后执行</span></span><br><span class="line"><span class="comment">    *     如果第一个参数为JoinPoint，则第二个参数为返回值的信息</span></span><br><span class="line"><span class="comment">    *     如果第一个参数不为JoinPoint，则第一个参数为returning中对应的参数</span></span><br><span class="line"><span class="comment">    *     returning：限定了只有目标方法返回值与通知方法参数类型匹配时才能执行后置返回通知，否则不执行，</span></span><br><span class="line"><span class="comment">    *     参数为Object类型将匹配任何目标返回值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"pointCut()"</span>,returning = <span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint,Object result)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@AfterReturning：切点方法返回后执行....."</span>);</span><br><span class="line">        System.out.println(<span class="string">"返回值："</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切点方法抛异常执行</span></span><br><span class="line"><span class="comment">     *     定义一个名字，该名字用于匹配通知实现方法的一个参数名，当目标方法抛出异常返回后，将把目标方法抛出的异常传给通知方法；</span></span><br><span class="line"><span class="comment">     *     throwing:限定了只有目标方法抛出的异常与通知方法相应参数异常类型时才能执行后置异常通知，否则不执行，</span></span><br><span class="line"><span class="comment">     *     对于throwing对应的通知方法参数为Throwable类型将匹配任何异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@AfterThrowing</span>(value = <span class="string">"pointCut()"</span>,throwing = <span class="string">"exception"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">(JoinPoint joinPoint,Throwable exception)</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"@afterThrowing：切点方法抛异常执行....."</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      * 属于环绕增强，能控制切点执行前，执行后，，用这个注解后，程序抛异常，会影响<span class="doctag">@AfterThrowing</span>这个注解</span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      * org.aspectj.lang.JoinPoint 接口表示目标类连接点对象，它定义这些主要方法。</span></span><br><span class="line"><span class="comment">      * Object[] getArgs()：获取连接点方法运行时的入参列表。</span></span><br><span class="line"><span class="comment">      * Signature getSignature()：获取连接点的方法签名对象。</span></span><br><span class="line"><span class="comment">      * Object getTarget()：获取连接点所在的目标对象。</span></span><br><span class="line"><span class="comment">      * Object getThis()：获取代理对象。</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      * <span class="doctag">@throws</span> Throwable </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Around</span>(value=<span class="string">"pointCut()"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"@Around：切点方法环绕start....."</span>);</span><br><span class="line">         Object[] args = pjp.getArgs();</span><br><span class="line">         Object o = pjp.proceed(args);</span><br><span class="line">         System.out.println(<span class="string">"@Around：切点方法环绕end....."</span>);</span><br><span class="line">         <span class="keyword">return</span> o;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h4><p><strong>Spring事务</strong>的本质其实就是<strong>数据库对事务的支持</strong>，没有数据库的事务支持，spring是无法提供事务功能的。对于纯JDBC操作数据库，想要用到事务，可以按照以下步骤进行：</p>
<ol>
<li><strong>获取连接</strong> Connection con = DriverManager.getConnection()</li>
<li><strong>开启事务</strong>con.setAutoCommit(true/false);</li>
<li><strong>执行CRUD</strong></li>
<li><strong>提交事务/回滚事务</strong> con.commit() / con.rollback();</li>
<li><strong>关闭连接</strong> conn.close();</li>
</ol>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul>
<li><strong>编程式事务</strong>：指在代码中手动的管理事务的提交、回滚等操作，代码侵入性比较强</li>
<li><strong>声明式事务</strong>：基于AOP面向切面的，它将具体业务与事务处理部分解耦，代码侵入性很低，所以在实际开发中声明式事务用的比较多。声明式事务也有两种实现方式，是基于<strong>TX和AOP的xml配置文件</strong>方式，二种就是基于@<strong>Transactional</strong>注解了。</li>
</ul>
<p>这里举例 <strong>注解的方式</strong>配置事务。</p>
<h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><p>1、定义事务管理器，传入 数据源对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">	JpaTransactionManager transactionManager = <span class="keyword">new</span> JpaTransactionManager(); </span><br><span class="line">	transactionManager.setDataSource(dataSource()); </span><br><span class="line">	<span class="keyword">return</span> transactionManager; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、在对应需要事务的类或方法上添加注解 <strong><em>@Transactional</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Transactional注解来自org.springframework.transaction.annotation包，而不是javax.transaction。</span></span><br><span class="line"><span class="meta">@Transactional</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveSomething</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//数据库操作 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h5><ul>
<li>配置文件开启注解驱动，在相关的类和方法上通过注解<strong><em>@Transactional</em></strong>标识。类上添加<strong><em>@Transactional</em></strong>则代表该类的所有方法都有事务。</li>
<li><strong>Spring</strong> 在启动的时候会去解析生成相关的bean，这时候会查看拥有相关注解的类和方法，并且为这些类和方法生成<strong>代理</strong>，并根据<strong><em>@Transaction</em></strong>的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了（开启正常提交事务，异常回滚事务）。</li>
<li>真正的数据库层的事务提交和回滚是通过<strong>bin log和redo log</strong>实现的。</li>
</ul>
<h5 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h5><p><strong>Spring</strong>的事务机制是<strong>用统一的机制来处理不同数据访问技术的事务处理</strong>。<strong>Spring</strong>的事务机制提供了一个<strong><em>PlatformTransactionManager</em></strong>接口，不同的数据访问技术的事务使用不同的接口实现</p>
<ul>
<li><strong>JDBC</strong>：DataSourceTransactionManager</li>
<li><strong>JPA</strong>：JpaTransactionManager</li>
<li><strong>Hibernate</strong>：HibernateTransactionManager</li>
<li><strong>JDO</strong>：JdoTransactionManager</li>
<li><strong>分布式事务</strong>：JtaTransactionManager</li>
</ul>
<h5 id="Spring-事务隔离级别"><a href="#Spring-事务隔离级别" class="headerlink" title="Spring 事务隔离级别"></a>Spring 事务隔离级别</h5><p><a href="http://blogsea.cn/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener">分布式事务</a>课程中，我们学习了<strong>数据库隔离级别</strong></p>
<p><img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89-Spring/framework_09.png" alt="数据库隔离级别"></p>
<p><strong>脏读</strong>：一事务对数据进行了增删改，但未提交，另一事务可以读取到未提交的数据。如果第一个事务这时候回滚了，那么第二个事务就读到了脏数据。</p>
<p><strong>不可重复读</strong>：一个事务中发生了两次读操作，第一次读操作和第二次操作之间，另外一个事务对数据进行了修改，这时候两次读取的数据是不一致的。</p>
<p><strong>幻读</strong>：第一个事务对一定范围的数据进行批量修改，第二个事务在这个范围增加一条数据，这时候第一个事务就会丢失对新增数据的修改。</p>
<p>总结：</p>
<ul>
<li><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。</p>
</li>
<li><p>大多数的数据库默认隔离级别为 <strong>Read Commited</strong>，比如 SqlServer、Oracle</p>
</li>
<li><p>少数数据库默认隔离级别为：<strong>Repeatable Read</strong> 比如： MySQL InnoDB</p>
</li>
</ul>
<p><strong>Spring 中的事务隔离级别</strong></p>
<p><img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89-Spring/framework_10.png" alt="Spring 事务隔离级别"></p>
<h5 id="事务嵌套（传播机制）"><a href="#事务嵌套（传播机制）" class="headerlink" title="事务嵌套（传播机制）"></a>事务嵌套（传播机制）</h5><ul>
<li><p><strong>PROPAGATION_REQUIRED</strong> (spring 默认)</p>
<p>支持当前事务,如果有就加入当前事务中;如果当前方法没有事务,就新建一个事务;</p>
</li>
<li><p><strong>PROPAGATION_REQUIRES_NEW</strong></p>
<p>新建事务,如果当前存在事务,就把当前事务挂起;如果当前方法没有事务,就新建事务;</p>
<p>他与 <strong>PROPAGATION_REQUIRED</strong> 的事务区别在于事务的回滚程度了。</p>
</li>
<li><p><strong>PROPAGATION_NESTED</strong></p>
<p>如果当前方法有事务,则在嵌套事务内执行;如果当前方法没有事务,则与required操作类似;</p>
</li>
<li><p><strong>PROPAGATION_MANATORY</strong></p>
<p>支持当前事务,如果有就加入当前事务中;如果当前没有事务,就抛出异常;</p>
</li>
<li><p><strong>PROPAGATION_SUPPORTS</strong></p>
<p>支持当前事务,如果有就加入当前事务中;如果当前方法没有事务,就以非事务的方式执行;</p>
<p>这种时候，内部方法的事务性完全依赖于最外层的事务。</p>
</li>
<li><p><strong>PROPAGATION_NOT_SUPPORTED</strong></p>
<p>以非事务方式执行,如果当前方法存在事务就挂起当前事务;如果当前方法不存在事务,就以非事务方式执行;</p>
</li>
<li><p><strong>PROPAGATION_NERVER</strong></p>
<p>以非事务方式执行,如果当前方法存在事务就抛出异常;如果当前方法不存在事务,就以非事务方式执行;</p>
</li>
</ul>
<h5 id="Transactional-失效原因"><a href="#Transactional-失效原因" class="headerlink" title="@Transactional 失效原因"></a>@Transactional 失效原因</h5><ul>
<li><p><strong>@Transactional 做用于非public方法上</strong>。</p>
<p>因为在<strong>Spring AOP</strong>代理时<strong>TransactionInterceptor</strong> （事务拦截器）在目标方法执行前后进行拦截，<strong>DynamicAdvisedInterceptor</strong>（CglibAopProxy 的内部类）的 <strong><em>intercept</em></strong> 方法或 <strong>JdkDynamicAopProxy</strong> 的 <strong><em>invoke</em></strong> 方法会间接调用 <strong>AbstractFallbackTransactionAttributeSource</strong>的 <strong><em>computeTransactionAttribute</em></strong>方法，获取<strong>Transactional</strong> 注解的事务配置信息。其中此方法会检查目标方法的修饰符是否为 <strong>public</strong>，<strong>不是 public则不会获取@Transactional 的属性配置信息</strong>。</p>
</li>
</ul>
<ul>
<li><p><strong>@Transactional 注解属性 rollbackFor 设置错误</strong>。</p>
<p><strong>rollbackFor</strong> 可以指定能够触发事务回滚的异常类型。Spring默认抛出了<strong>未检查unchecked异常（继承自 RuntimeException 的异常）或者 Error才回滚事务</strong>。如果需要制定异常回滚，则需配置 rollbackFor ，</p>
<p><strong>若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。</strong></p>
</li>
</ul>
<ul>
<li><p><strong>同一个类中方法调用，导致@Transactional失效</strong>。</p>
<p>这是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。</p>
<p>解决方法可以是，上层自定义 self() 方法，返回代理对象。调用本类方法时，使用 <strong><em>self().testB()</em></strong> 即可。</p>
<p>具体实现方法为 ：</p>
<ol>
<li><p>自定义 接口  <strong>ProxySelf</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ProxySelf&lt;T&gt; &#123;</span><br><span class="line">    default T self() &#123;</span><br><span class="line">        return AopContext.currentProxy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>service 接口继承 ProxySelf ，泛型传入自身接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserService</span> <span class="keyword">extends</span> <span class="title">ProxySelf</span>&lt;<span class="title">IUserService</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>service 实现类中调用 <strong><em>this.self().testB()</em></strong> 方法即可。</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>异常被你的 catch “吃了” 导致@Transactional失效</strong></p>
</li>
<li><p><strong>数据库引擎不支持事务</strong>：例如 Mysql 切换 MyISAM 引擎等</p>
</li>
</ul>
<p><strong>更多事务扩展知识</strong>可在<a href="http://blogsea.cn/2020/05/27/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener">分布式架构之事务管理</a>中学习。</p>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>在早期 Java Web 的开发中，统一把显示层、控制层、数据层的操作全部交给 JSP 或者 JavaBean 来进行处理，我们称之为 <strong>Model1</strong></p>
<p><strong>出现的弊端：</strong></p>
<ul>
<li><p>JSP 和 Java Bean 之间严重耦合，Java 代码和 HTML 代码也耦合在了一起</p>
</li>
<li><p>要求开发者不仅要掌握 Java ，还要有高超的前端水平</p>
</li>
<li><p>前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试</p>
</li>
<li><p>代码难以复用</p>
</li>
</ul>
<p>正因为上面的种种弊端，所以很快这种方式就被 <strong>Servlet + JSP + Java Bean</strong> 所替代了，早期的 <strong>MVC</strong> 模型<strong>（Model2）</strong></p>
<p>为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 <strong>NoSQL</strong> 的强势崛起，Spring MVC 应运而生。</p>
<p><img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89-Spring/framework_06.png" alt="SpringMVC诞生背景"></p>
<p><strong>传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。</strong> 在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL 。</p>
<p><strong>特点：</strong></p>
<ul>
<li>结构松散，几乎可以在 Spring MVC 中使用各类视图</li>
<li>松耦合，各个模块分离</li>
<li>与 Spring 无缝集成</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><strong>SpringMVC</strong> 核心是在 <strong><em>DispatcherServlet</em></strong> 类，简单来说就是：客户端发送请求到 <strong>DispatcherServlet</strong>，<strong>DispatcherServlet</strong> 查询 <strong>handlerMapping</strong> 找到处理请求的 <strong>Controller</strong>，<strong>Controller</strong> 调用业务逻辑后，返回 <strong>ModelAndView</strong>（或者<strong>Json</strong>数据），<strong>DispatcherServlet</strong> 查询 <strong>ModelAndView</strong>，找到指定视图<br>视图将结果返回到客户端。</p>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p><img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89-Spring/framework_07.png" alt="SpringMVC执行流程"></p>
<ul>
<li>用户发送请求至前端控制器<strong>DispatcherServlet</strong>；</li>
<li><strong>DispatcherServlet</strong>收到请求后，调用<strong>HandlerMapping</strong>处理器映射器，请求获取<strong>Handle</strong>；</li>
<li>处理器映射器根据请求<strong>url</strong>找到具体的处理器，生成<strong>处理器对象及处理器拦截器</strong>(如果有则生成)一并返回给<strong>DispatcherServlet</strong>；</li>
<li><strong>DispatcherServlet</strong> 调用 <strong>HandlerAdapter</strong>处理器适配器；</li>
<li><strong>HandlerAdapter</strong> 经过适配调用 具体处理器(<strong>Handler</strong>，也叫后端控制器)；</li>
<li><strong>Handler</strong>执行完成返回<strong>ModelAndView</strong>；</li>
<li><strong>HandlerAdapter</strong>将<strong>Handler</strong>执行结果<strong>ModelAndView</strong>返回给<strong>DispatcherServlet</strong>；</li>
<li><strong>DispatcherServlet</strong>将<strong>ModelAndView</strong>传给<strong>ViewResolver</strong>视图解析器进行解析；</li>
<li><strong>ViewResolver</strong>解析后返回具体<strong>View</strong>；</li>
<li><strong>DispatcherServlet</strong>对<strong>View</strong>进行渲染视图（即将模型数据填充至视图中）</li>
<li><strong>DispatcherServlet</strong>响应用户。</li>
</ul>
<h4 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h4><ul>
<li><p><strong>DispatcherServlet：前端控制器</strong><br>用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p>
</li>
<li><p><strong>HandlerMapping：处理器映射器</strong><br>HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
</li>
<li><p><strong>Handler：处理器</strong><br>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</p>
</li>
<li><p><strong>HandlAdapter：处理器适配器</strong><br>通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
</li>
<li><p><strong>ViewResolver：视图解析器</strong><br>View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。</p>
</li>
<li><p><strong>View：视图</strong><br>springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。<br>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p>
</li>
</ul>
<h4 id="SpringMVC-拦截器"><a href="#SpringMVC-拦截器" class="headerlink" title="SpringMVC 拦截器"></a>SpringMVC 拦截器</h4><p><strong>Spring MVC</strong>中的拦截器（<strong>Interceptor</strong>）类似于<strong>Servlet</strong>中的过滤器（<strong>Filter</strong>），它主要用于拦截用户请求并作相应的处理。例如通过拦截器可以进行<strong>权限验证、记录请求信息的日志、判断用户是否登录等</strong>。</p>
<p>通常自定义拦截器类可以有两种方式：</p>
<ul>
<li>通过实现<strong>HandlerInterceptor</strong>接口，或继承<strong>HandlerInterceptor</strong>接口的实现类（如<strong>HandlerInterceptorAdapter</strong>）来定义。</li>
<li>通过实现<strong>WebRequestInterceptor</strong>接口，或继承<strong>WebRequestInterceptor</strong>接口的实现类来定义。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">                             HttpServletResponse response, Object handler)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">                           HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>preHandle() 方法</strong>：该方法会在控制器方法前执行，其返回值表示是否中断后续操作。当其返回值为true时，表示继续向下执行；<br>当其返回值为false时，会中断后续的所有操作（包括调用下一个拦截器和控制器类中的方法执行等）。</li>
<li><strong>postHandle()方法</strong>：该方法会在控制器方法调用之后，且解析视图之前执行。可以通过此方法对请求域中的模型和视图做出进一步的修改。</li>
<li><strong>afterCompletion()方法</strong>：该方法会在整个请求完成，即视图渲染结束之后执行。可以通过此方法实现一些资源清理、记录日志信息等工作。</li>
</ul>
<p><strong>拦截器配置</strong></p>
<ul>
<li><p>xml配置文件方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--拦截器1--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置拦截器的作用路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义在&lt;mvc:interceptor&gt;下面的表示匹配指定路径的请求才进行拦截--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.example.interceptor.Intercptor1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--拦截器2--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/hello"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.example.interceptor.Interceptor2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">      ....</span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>java代码方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注册CustomInterceptor拦截器</span></span><br><span class="line">        InterceptorRegistration registration = registry.addInterceptor(<span class="keyword">new</span> CustomInterceptor());</span><br><span class="line">        registration.addPathPatterns(<span class="string">"/**"</span>);                      <span class="comment">//所有路径都被拦截</span></span><br><span class="line">        registration.excludePathPatterns(                         <span class="comment">//添加不拦截路径</span></span><br><span class="line">            <span class="string">"/login"</span>,                <span class="comment">//登录</span></span><br><span class="line">            <span class="string">"/**/*.html"</span>,            <span class="comment">//html静态资源</span></span><br><span class="line">            <span class="string">"/**/*.js"</span>,              <span class="comment">//js静态资源</span></span><br><span class="line">            <span class="string">"/**/*.css"</span>,             <span class="comment">//css静态资源</span></span><br><span class="line">            <span class="string">"/**/*.woff"</span>,</span><br><span class="line">            <span class="string">"/**/*.ttf"</span></span><br><span class="line">        );    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>SpringMVC拦截器 与 过滤器（Filter）的区别与联系</strong></p>
<ul>
<li><p><strong>Spring</strong> 拦截器与 <strong>Servlet</strong> 的 过滤器（<strong>Filter</strong>）有相似之处，二者都是<strong>AOP编程思想</strong>的体现，都能实现权限检查、日志记录等。</p>
</li>
<li><p><strong>Filter</strong> 是 <strong>Servlet</strong> 规范规定的，只用于 <strong>Web</strong> 应用程序中；而拦截器 既用于 <strong>Web</strong> 程序，也可以用于<strong>Application</strong>、<strong>Swing</strong>程序中。</p>
</li>
<li><p><strong>Filter</strong> 是 <strong>Servlet</strong> 规范定义的，是 <strong>Servlet</strong> 容器支持的；拦截器 则是 <strong>Spring</strong> 容器内的，是<strong>Spring</strong> 框架支持的。</p>
</li>
<li><p>拦截器是 <strong>Spring</strong> 的组件，归 <strong>Spring</strong> 管理，配置在 <strong>Spring</strong> 文件中，因此能使用 <strong>Spring</strong> 中的任何资源、对象，例如<strong>Service</strong>对象，数据源，事务管理等，通过<strong>Ioc</strong> 注入到拦截器即可，而<strong>Filter</strong> 不能。</p>
</li>
<li><p><strong>Filter</strong> 在 <strong>Servlet</strong> 前后起作用；而拦截器能够深入到方法前后、异常抛出前后，因此拦截器拥有更大弹性。</p>
</li>
<li><p><strong>Filter</strong> 和 拦截器 作用顺序比较：</p>
<p><img src="/2021/03/15/%E5%BF%85%E4%BC%9A%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89-Spring/framework_08.png" alt="Filter 和 拦截器执行顺序"></p>
</li>
</ul>
<h3 id="SpringData"><a href="#SpringData" class="headerlink" title="SpringData"></a>SpringData</h3><h4 id="JPA（待更新）"><a href="#JPA（待更新）" class="headerlink" title="JPA（待更新）"></a>JPA（待更新）</h4><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p><a href="http://blogsea.cn/2020/04/28/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">SpringBoot学习之启动配置原理</a></p>
<p><a href="http://blogsea.cn/2020/05/07/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">SpringBoot学习之自动配置原理</a></p>
<p><a href="http://blogsea.cn/2020/05/08/SpringBoot-SpringBoot%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener">SpringBoot学习之日志管理</a></p>
<p>另补充<strong>SpringBoot</strong>关键注解：</p>
<ul>
<li><strong>@SpringBootApplication</strong> ：包含了 @ComponentScan、@EnableAutoConfiguration、@SpringBootConfiguration 三个注解</li>
<li><strong>@SpringBootConfiguration：</strong>包含了 @Configuration 注解。</li>
<li><strong>@EnableAutoConfiguration：</strong>自动配置</li>
<li><strong>@Conditional相关 ：</strong>控制自动配置的生效条件的注解<ul>
<li>@ConditionalOnBean</li>
<li>@ConditionalOnClass</li>
<li>@ConditionalOnExpression</li>
<li>@ConditionalOnMissingBean</li>
<li>@ConditionalOnMissingClass</li>
<li>@ConditionalOnNotWebApplication</li>
</ul>
</li>
</ul>
<p><strong>SpringBoot</strong> 相关模块：</p>
<ul>
<li><strong>starter：</strong>Starter 是 Spring Boot 提供的无缝集成功能的一种方式，使用某个功能时开发者不需要关注各种依赖库的处理，不需要具体的配置信息，由 Spring Boot 自动配置进行 Bean的创建。例如需要使用 Web 功能时，只需要在依赖中引入 Spring-boot-starter-web 即可。</li>
<li><strong>actuator：</strong>Actuator 是用来对应用程序进行监视和管理，通过 RESTful API 请求来监管、审计、收集应用的运行情况。</li>
<li><strong>devtools：</strong>DevTools 提供了一系列开发工具的支持，来提高开发效率。例如热部署能力等。</li>
<li><strong>cli：</strong>CLI 就是命令行接口，是一个命令行工具，支持使用 Groovy 脚本，可以快速搭建 Spring 原型项目。</li>
</ul>
<p><strong>SpringBoot</strong> 配置文件：</p>
<ul>
<li><strong>bootstarp：</strong>应用程序的父上下文，会先于 applicaton 加载，主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。bootstrap 里面的属性会优先加载，默认也不能被本地相同配置覆盖。</li>
<li><strong>application：</strong>默认配置文件，可区分环境。</li>
</ul>
<h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><p>涉及篇幅过多，后续补充</p>
<blockquote>
<p>笔记来源：网络知识点整理</p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>面试复习</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存（三）- Redis</title>
    <url>/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/</url>
    <content><![CDATA[<h1 id="缓存之Redis（三）"><a href="#缓存之Redis（三）" class="headerlink" title="缓存之Redis（三）"></a>缓存之Redis（三）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C语言" target="_blank" rel="noopener">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/数据库/103728" target="_blank" rel="noopener">数据库</a>，并提供多种语言的API。它的所有数据结构都存在内存中，可以用作缓存、数据库和消息中间件。</p>
<p>一个 Redis 实例可以有多个存储数据的字典，客户端可以通过 select 来选择字典即 DB 进行数据存储。</p>
<p>– 百度百科</p>
</blockquote>
<p><strong>特性</strong>：</p>
<ul>
<li><p>同为 key-value 存储组件，Memcached 只能支持<strong>二进制字节块</strong>这一种数据类型。而 Redis 的数据类型却丰富的多，它具有 <strong>8 种核心数据类型</strong>，每种数据类型都有一系列操作指令对应。</p>
</li>
<li><p>Redis <strong>性能很高</strong>，单线程压测可以达到 10~11w 的 QPS。单线程性能高是因为没有线程切换，线程间通信，线程竞争，不需要加锁，没有上下文切换开销，所有数据操作都是在内存中操作，所以 Redis 的性能很高。</p>
</li>
<li><p><strong>可持久化</strong>，提供俩种持久化方式：</p>
<ul>
<li>快照方式：将某时刻所有数据都写入硬盘的 <strong>RDB</strong> 文件</li>
<li>追加文件方式：即将所有写命令都以追加的方式写入硬盘的 <strong>AOF</strong> 文件，AOF 文件会随时间流逝变得越来越大，此时，可以通过 bgrewriteaof 指令，对 AOF 进行重写，只保留数据的最后内容，来大大缩减 AOF 的内容。</li>
</ul>
<p>线上 Redis 一般会<strong>同时使用</strong>两种方式，通过开启 appendonly 及关联配置项，将写命令及时追加到 AOF 文件，同时在每日流量低峰时，通过 bgsave 保存当时所有内存数据快照。 </p>
</li>
<li><p>Redis <strong>支持复制</strong>特性：master-多slave，读写分离，把所有写操作落在 Redis 的 master，所有读操作随机落在 Redis 的多个 slave 。</p>
</li>
<li><p>Redis <strong>支持支持 Lua脚本</strong>：Redis 自 2.6 版本开始支持 Lua，通过支持 client 端自定义的 Lua 脚本，Redis 可以减少网络开销，提升处理性能，还可以把脚本中的多个操作作为一个整体来操作，实现原子性更新。</p>
</li>
<li><p>Redis 还<strong>支持事务</strong>，在 multi 指令后，指定多个操作，然后通过 exec 指令一次性执行，中途如果出现异常，则不执行所有命令操作，否则，按顺序一次性执行所有操作，执行过程中不会执行任何其他指令。</p>
</li>
<li><p>Redis 还<strong>支持 Cluster 特性</strong>，可以通过自动或手动方式，将所有 key 按哈希分散到不同节点，在容量不足时，还可以通过 Redis 的迁移指令，把其中一部分 key 迁移到其他节点。</p>
</li>
</ul>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_20.png" alt="Redis特性" style="zoom:47%;">

<h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><p> 8 种核心数据类型：</p>
<ul>
<li><strong>string 字符串类型；</strong></li>
<li><strong>list 列表类型；</strong></li>
<li><strong>set 集合类型；</strong></li>
<li><strong>sorted set 有序集合类型；</strong></li>
<li><strong>hash 类型；</strong></li>
<li>bitmap 位图类型； </li>
<li>geo 地理位置类型；</li>
<li>HyperLogLog 基数统计类型。</li>
</ul>
<h3 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a><strong>string 字符串</strong></h3><p><strong>string</strong> 是 <strong>Redis</strong> 的最<strong>基本数据类型</strong>。可以把它理解为 Mc 中 key 对应的 value 类型。</p>
<ul>
<li><p>string 类型是二进制安全的，即 string 中可以包含任何数据。</p>
</li>
<li><p>Redis 中的普通 string 采用 <strong>raw encoding</strong> 即原始编码方式，该编码方式会<strong>动态扩容</strong>，并通过<strong>提前预分配</strong>冗余空间，来减少内存频繁分配的开销。</p>
</li>
<li><p>在字符串长度小于 1MB 时，按所需长度的 2 倍来分配，超过 1MB，则按照每次额外增加 1MB 的容量来预分配。</p>
</li>
<li><p>Redis 中的<strong>数字也存为 string 类型</strong>，但编码方式跟普通 string 不同，数字<strong>采用整型编码</strong>，字符串内容直接设为整数值的二进制字节序列。</p>
</li>
<li><p>在存储普通字符串，序列化对象，以及计数器等场景时，都可以使用 Redis 的字符串类型，字符串数据类型对应使用的指令包括 set、get、mset、incr、decr 等。</p>
</li>
</ul>
<h3 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a><strong>list 列表</strong></h3><p>Redis 的 list 列表，是一个<strong>快速双向链表</strong>，存储了一系列的 string 类型的字串值。</p>
<ul>
<li><p>list 中的元素<strong>按照插入顺序排列</strong>。</p>
</li>
<li><p>插入元素的方式，可以通过 <strong>lpush</strong> 将一个或多个元素插入到列表的<strong>头部</strong>，也可以通过 <strong>rpush</strong> 将一个或多个元素插入到队列<strong>尾部</strong>，还可以通过 <strong>lset、linsert</strong> 将元素插入到<strong>指定位置或指定元素的前后</strong>。</p>
</li>
<li><p>list 列表的获取，可以通过 lpop、rpop 从对头或队尾弹出元素，如果队列为空，则返回 nil。</p>
<p>还可以通过 Blpop、Brpop 从队头/队尾阻塞式弹出元素，如果 list 列表为空，没有元素可供弹出，则持续阻塞，直到有其他 client 插入新的元素。这里阻塞弹出元素，可以设置过期时间，避免无限期等待。</p>
<p>list 列表还可以通过 LrangeR 获取队列内指定范围内的所有元素。Redis 中，list 列表的偏移位置都是基于 0 的下标，偏移量也可以是负数。</p>
</li>
<li><p>对于<strong>常规的 pop、push 元素，性能很高，时间复杂度为 O(1)</strong>，因为是列表直接追加或弹出。但对于通过<strong>随机插入、随机删除，以及随机范围获取</strong>，需要轮询列表确定位置，<strong>性能就比较低下</strong>了。</p>
</li>
<li><p>feed timeline（是一种把信息根据时间顺序排序呈现给订阅用户进行消费的形式） 存储时，由于 feed id 一般是递增的，可以直接存为 list，用户发表新 feed，就直接追加到队尾。另外消息队列、热门 feed 等业务场景，都可以使用 list 数据结构。</p>
</li>
</ul>
<h3 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a><strong>set 集合</strong></h3><p>set 是 string 类型的<strong>无序集合</strong>，set 中的元素是唯一的，即 set 中<strong>不会出现重复的元素</strong>。Redis 中的集合一般是通过 <strong>dict 哈希表实现</strong>的，所以插入、删除，以及查询元素，可以根据元素 hash 值直接定位，时间复杂度为 O(1)。</p>
<p>除了常规的添加、删除、查找元素外，常用 set 指令：</p>
<ul>
<li><p><strong>sismember</strong> 指令判断该 key 对应的 set 数据结构中，是否存在某个元素，如果存在返回 1，否则返回 0；</p>
</li>
<li><p><strong>sdiff</strong> 指令来对多个 set 集合执行差集；</p>
</li>
<li><p><strong>sinter</strong> 指令对多个集合执行交集；</p>
</li>
<li><p><strong>sunion</strong> 指令对多个集合执行并集；</p>
</li>
<li><p><strong>spop</strong> 指令弹出一个随机元素；</p>
</li>
<li><p><strong>srandmember</strong> 指令返回一个或多个随机元素。</p>
</li>
</ul>
<p>set 集合的特点是查找、插入、删除特别高效，时间复杂度为 O(1)，所以在社交系统中，可以用于存储关注的好友列表，用来判断是否关注，还可以用来做好友推荐使用。另外，还可以利用 set 的唯一性，来对服务的来源业务、来源 IP 进行精确统计。</p>
<h3 id="sorted-set-zset-有序集合"><a href="#sorted-set-zset-有序集合" class="headerlink" title="sorted set (zset) 有序集合"></a><strong>sorted set (zset) 有序集合</strong></h3><p>Redis 中的 sorted set <strong>有序集合</strong>也称为 <strong>zset</strong>，有序集合同 set 集合类似，也是 string 类型元素的集合，且所有元素不允许重复。</p>
<p>有序集合中，每个元素都会关联一个 double 类型的 score 分数值。<strong>有序集合通过这个 score 值进行由小到大的排序</strong>。有序集合中，元素不允许重复，但 score 分数值却允许重复。</p>
<p>除了常规的添加、删除、查找元素外，还可以通过以下指令对 sorted set 进行操作：</p>
<ul>
<li>zscan 指令：按顺序获取有序集合中的元素；</li>
<li>zscore 指令：获取元素的 score 值；</li>
<li>zrange指令：通过指定 score 返回指定 score 范围内的元素；</li>
<li>在某个元素的 score 值发生变更时，还可以通过 zincrby 指令对该元素的 score 值进行加减。</li>
<li>通过 zinterstore、zunionstore 指令对多个有序集合进行取交集和并集，然后将新的有序集合存到一个新的 key 中，如果有重复元素，重复元素的 score 进行相加，然后作为新集合中该元素的 score 值。</li>
</ul>
<p>zset 有序集合的特点是：<strong>所有元素按 score 排序，而且不重复；查找、插入、删除非常高效，时间复杂度为 O(1)。</strong></p>
<p>因此，可以用有序集合来统计排行榜，实时刷新榜单，还可以用来记录学生成绩，从而轻松获取某个成绩范围内的学生名单，还可以用来对系统统计增加权重值，从而在 dashboard 实时展示。</p>
<h3 id="hash-哈希"><a href="#hash-哈希" class="headerlink" title="hash 哈希"></a><strong>hash 哈希</strong></h3><p>Redis 中的哈希实际是 <strong>field 和 value 的一个映射表</strong>。</p>
<p>hash 数据结构的特点是在单个 key 对应的哈希结构内部，可以记录多个键值对，即 field 和 value 对，value 可以是任何字符串。而且<strong>这些键值对查询和修改很高效</strong>。</p>
<p>所以可以用 hash 来存储具有多个元素的复杂对象，然后分别修改或获取这些元素。</p>
<p>hash 结构中的一些重要指令:</p>
<ul>
<li>hmset 指令批量插入多个 field、value 映射；</li>
<li>hmget 指令获取多个 field 对应的 value 值；</li>
<li>hexists 指令判断某个 field 是否存在；</li>
<li>如果 field 对应的 value 是整数，还可以用 hincrby 来对该 value 进行修改。</li>
</ul>
<p>最后了解一下 Redis 中剩下的三个数据类型：<strong>bitmap 位图</strong>、<strong>GEO 地理位置</strong>、<strong>hyperLogLog 基数统计</strong></p>
<ul>
<li><p><strong>bitmap 位图</strong>：Redis 中的 bitmap 位图是一串连续的二进制数字，底层实际是基于 string 进行封装存储的，按 bit 位进行指令操作的。</p>
<p>bitmap 位图的特点是按位设置、求与、求或等操作很高效，而且存储成本非常低，用来存对象标签属性的话，一个 bit 即可存一个标签。</p>
<p>可以用 bitmap，存用户最近 N 天的登录情况，每天用 1 bit，登录则置 1。个性推荐在社交应用中非常重要，可以对新闻、feed 设置一系列标签，如军事、娱乐、视频、图片、文字等，用 bitmap 来存储这些标签，在对应标签 bit 位上置 1。对用户，也可以采用类似方式，记录用户的多种属性，并可以很方便的根据标签来进行多维度统计。bitmap 位图的重要指令包括：setbit、 getbit、bitcount、bitfield、 bitop、bitpos 等。</p>
</li>
<li><p><strong>GEO 地理位置</strong>：Redis 在 3.2 版本之后增加了对 GEO 地理位置的处理功能。Redis 的 GEO 地理位置本质上是基于 sorted set 封装实现的。在存储分类 key 下的地理位置信息时，需要对该分类 key 构建一个 sorted set 作为内部存储结构，用于存储一系列位置点。</p>
<p>Redis 的 GEO 地理位置数据结构，应用场景很多，比如查询某个地方的具体位置，查当前位置到目的地的距离，查附近的人、餐厅、电影院等。GEO 地理位置数据结构中，重要指令包括 geoadd、geopos、geodist、georadius、georadiusbymember 等。</p>
</li>
<li><p><strong>hyperLogLog 基数统计</strong>：Redis 的 hyperLogLog 是用来做基数统计的数据类型，当输入巨大数量的元素做统计时，只需要很小的内存即可完成。HyperLogLog 不保存元数据，只记录待统计元素的估算数量，这个估算数量是一个带有 0.81% 标准差的近似值，在大多数业务场景，对海量数据，不足 1% 的误差是可以接受的。</p>
<p>在大中型系统中，统计每日、每月的 UV 即独立访客数，或者统计海量用户搜索的独立词条数，都可以用 hyperLogLog 数据类型来进行处理。</p>
</li>
</ul>
<h2 id="Redis的设计原则"><a href="#Redis的设计原则" class="headerlink" title="Redis的设计原则"></a>Redis的设计原则</h2><h3 id="Redis-协议"><a href="#Redis-协议" class="headerlink" title="Redis 协议"></a><strong>Redis 协议</strong></h3><p><strong>RESP</strong>（Redis Serialization Protocol）<strong>Redis 序列化协议</strong>， 是一种二进制安全协议，<strong>可以供 Redis 或其他任何 Client-Server 使用</strong>。在 Redis 内部，还会基于 RESP 进一步扩展细节。该协议的设计是为了方便以一种统一的风格和原则来设计和使用Redis指令。</p>
<h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p><strong>Redis 序列化协议的设计原则有三个</strong>：</p>
<ul>
<li>第一是实现简单；</li>
<li>第二是可快速解析；</li>
<li>第三是便于阅读。</li>
</ul>
<p><strong>Redis 协议的请求响应模型有三种：</strong> </p>
<ul>
<li><strong>ping-pong 模式</strong>：即 client 发送一个请求，server 回复一个响应，一问一答的访问模式。</li>
<li><strong>pipeline 模式</strong>：即 client 一次连续发送多个请求，然后等待 server 响应，server 处理完请求后，把响应返回给 client。</li>
<li><strong>pub/sub 模式</strong>：即发布订阅模式，client 通过 subscribe 订阅一个 channel，然后 client 进入订阅状态，静静等待。当有消息产生时，server 会持续自动推送消息给 client，不需要 client 的额外请求。而且客户端在进入订阅状态后，只可接受订阅相关的命令如 SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE 和 PUNSUBSCRIBE，除了这些命令，其他命令一律失效。</li>
</ul>
<p><strong>Redis 请求指令格式类型有 2 种：</strong></p>
<ul>
<li><strong>inline cmd 内联命令格式</strong>：使用 inline cmd 内联格式，只需要用空格分隔请求指令及参数，简单快速，一个简单的例子如 mget key1 key2\r\n。</li>
<li><strong>Array 数组格式</strong>：以 * 开头，随后跟一个数组长度 N，然后以回车换行结尾；然后后面跟随 N 个数组元素。</li>
</ul>
<p><strong>Redis 协议的响应格式有 5 种：</strong></p>
<ul>
<li><strong>simple strings 简单字符串类型</strong>：以 + 开头，后面跟字符串，以 CRLF（即 \r\n）结尾。这种类型不是二进制安全类型，字符串中不能包含 \r 或者 \n。例如：+OK\r\n 。</li>
<li><strong>错误响应</strong>：Redis 协议将错误作为一种专门的类型，格式同简单字符串类型，唯一不同的是以 -（减号）开头。Redis 内部实现对 Redis 协议做了进一步规范，减号后面一般先跟 ERR 或者 WRONGTYPE，然后再跟其他简单字符串，最后以 CRLF（回车换行）结束。</li>
<li><strong>Integer 整数类型</strong>：整数类型以 ：开头，后面跟字符串表示的数字，最后以回车换行结尾。Redis 中许多命令都返回整数，但整数的含义要由具体命令来确定。比如，对于 incr 指令，：后的整数表示变更后的数值；</li>
<li><strong>bulk strings 字符串块类型</strong>：字符串块分<strong>头部和真正字符串内容</strong>两部分。字符串块用于表示二进制安全的字符串，最大长度可以支持 512MB。<ul>
<li>字符串块类型的头部， 为 $ 开头，随后跟真正字符串内容的字节长度，然后以 CRLF 结尾。</li>
<li>字符串块的头部之后，跟随真正的字符串内容，最后以 CRLF 结束字符串块。</li>
</ul>
</li>
<li><strong>Arrays 数组类型</strong>：如果一个命令需要返回多条数据就需要用数组格式类型，另外，前面提到 client 的请求命令也是主要采用这种格式。以 * 开头，随后跟一个数组长度 N，然后以回车换行结尾；然后后面跟随 N 个数组元素，每个数组元素的类型，可以是 Redis 协议中除内联格式外的任何一种类型。</li>
</ul>
<h4 id="协议分类"><a href="#协议分类" class="headerlink" title="协议分类"></a><strong>协议分类</strong></h4><p>Redis 协议主要分为 16 种，<strong>其中 8 种协议对应前面我们讲到的 8 种数据类型</strong>，你选择了使用什么数据类型，就使用对应的响应操作指令即可。</p>
<p>剩下 8 种协议如下：</p>
<ul>
<li><strong>pub-sub 发布订阅协议</strong>，client 可以订阅 channel，持续等待 server 推送消息。</li>
<li><strong>事务协议</strong>，事务协议可以用 multi 和 exec 封装一些列指令，来一次性执行。</li>
<li><strong>脚本协议</strong>，关键指令是 eval、evalsha 和 script等。</li>
<li><strong>连接协议</strong>，主要包括权限控制，切换 DB，关闭连接等。</li>
<li><strong>复制协议</strong>，包括 slaveof、role、psync 等。</li>
<li><strong>配置协议</strong>，config set/get 等，可以在线修改/获取配置。</li>
<li><strong>调试统计协议</strong>，如 slowlog，monitor，info 等。</li>
<li><strong>其他内部命令</strong>，如 migrate，dump，restore 等。</li>
</ul>
<h3 id="Redis-client-的使用及改进"><a href="#Redis-client-的使用及改进" class="headerlink" title="Redis client 的使用及改进"></a><strong>Redis client 的使用及改进</strong></h3><p>由于 Redis 使用广泛，几乎所有主流语言都有对 Redis 开发了对应的 client。 Java 语言中，广泛使用的有 Jedis、Redisson 等。</p>
<ul>
<li><strong>Jedis</strong>：它的优势是轻量，简洁，便于集成和改造，它支持连接池，提供指令维度的操作，几乎支持 Redis 的所有指令，但它不支持读写分离。</li>
<li><strong>Redisson</strong>： 基于 Netty 实现，非阻塞 IO，性能较高，而且支持异步请求和连接池，还支持读写分离、读负载均衡，它内建了 tomcat Session ，支持 spring session 集成，但 redisson 实现相对复杂。</li>
</ul>
<p>在新项目启动时，如果只是简单的 Redis 访问业务场景，可以直接用 Jedis，甚至可以简单封装 Jedis，实现 master-slave 的读写分离方案。如果想直接使用读写分离，想集成 spring session 等这些高级特性，也可以采用 redisson。 </p>
<p>Redis client 在使用中，需要根据业务及运维的需要，进行相关改进。在 client 访问异常时，可以增加<strong>重试策略</strong>，在访问某个 slave 异常时，需要重试其他 slave 节点。需要增加对 <strong>Redis 主从切换、slave 扩展</strong>的支持，比如采用守护线程定期扫描 master、slave 域名，发现 IP 变更，及时切换连接。</p>
<p>对于多个 slave 的访问，还需要增加<strong>负载均衡</strong>策略。最后，Redis client 还可以与配置中心、Redis 集群管理平台整合，从而实时感知及协调 Redis 服务的访问。</p>
<h2 id="Redis-系统架构"><a href="#Redis-系统架构" class="headerlink" title="Redis 系统架构"></a>Redis 系统架构</h2><img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_21.png" alt="Redis系统架构" style="zoom:80%;">

<p>Redis 组件的系统架构如图所示，主要包括：</p>
<ul>
<li><strong>事件处理模块</strong>：Redis 中的事件处理模块，采用的是作者自己开发的 ae 事件驱动模型，可以进行<strong>高效的网络 IO 读写、命令执行，以及时间事件处理</strong>。    </li>
<li><strong>数据存储及管理模块</strong>：Redis 的内存数据都存在 redisDB 中。</li>
<li><strong>用于系统扩展的主从复制/集群管理模块</strong>：主从复制，Redis cluster 集群。</li>
<li><strong>为插件化功能扩展的 Module System 模块</strong>：Redis 在 4.0 版本之后引入了 Module System 模块，可以方便使用者，在不修改核心功能的同时，进行插件化功能开发。使用者可以将新的 feature 封装成动态链接库，Redis 可以在启动时加载，也可以在运行过程中随时按需加载和启用。</li>
</ul>
<h3 id="Redis-事件驱动模型"><a href="#Redis-事件驱动模型" class="headerlink" title="Redis 事件驱动模型"></a><strong>Redis 事件驱动模型</strong></h3><p>Redis 是一个事件驱动程序，但和 Memcached 不同的是，Redis 并没有采用 libevent 或 libev 这些开源库，而是<strong>直接开发了一个新的事件循环组件</strong>。Redis 作者给出的理由是，尽量减少外部依赖，而自己开发的事件模型也足够简洁、轻便、高效，也更易控制。</p>
<p>Redis 的事件驱动模型机制封装在 aeEventLoop 等相关的结构体中，网络连接、命令读取执行回复，数据的持久化、淘汰回收 key 等，几乎所有的核心操作都通过 ae 事件模型进行处理。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_22.png" alt="Redis事件驱动模型" style="zoom:80%;">

<p><strong>Redis 的事件驱动模型处理 2 类事件：</strong></p>
<ul>
<li><strong>文件事件</strong>，如连接建立、接受请求命令、发送响应等；</li>
<li><strong>时间事件</strong>，如 Redis 中定期要执行的统计、key 淘汰、缓冲数据写出、rehash等。</li>
</ul>
<h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p>Redis 的文件事件采用典型的 <strong>Reactor 模式</strong>进行处理。    </p>
<p><strong>处理机制分为 4 部分：</strong></p>
<ul>
<li><p><strong>连接 socket</strong>；</p>
</li>
<li><p><strong>IO 多路复用程序</strong>：Redis 封装了 4 种多路复用程序；每种封装实现都提供了相同的 API 实现。<strong>编译时，会按照性能和系统平台，选择最佳的 IO 多路复用函数作为底层实现</strong>，选择顺序是，首先尝试选择 Solaries 中的 evport，如果没有，就尝试选择 Linux 中的 epoll，否则就选择大多 UNIX 系统都支持的 kqueue，最终就会选择 select 作为底层实现方案。</p>
</li>
<li><p><strong>文件事件分派器</strong>：Redis 中的文件事件分派器是 aeProcessEvents 函数。<strong>它会首先计算最大可以等待的时间，然后利用 aeApiPoll 等待文件事件的发生。</strong>如果在等待时间内，一旦 IO 多路复用程序产生了事件通知，则会立即轮询所有已产生的文件事件，并将文件事件放入 aeEventLoop 中的 aeFiredEvents 结构数组中。</p>
<p>这里会涉及将多路复用中的事件类型，转换为 Redis 的 ae 事件驱动模型中的事件类型。</p>
<p>aeProcessEvents 在获取到触发的事件后，会根据事件类型，将文件事件 dispatch 派发给对应事件处理函数。如果同一个 socket，同时有读事件和写事件，Redis 派发器会首先派发处理读事件，然后再派发处理写事件。</p>
</li>
<li><p><strong>事件处理器</strong>；Redis 中文件事件函数的注册和处理主要分为 3 种。</p>
<ul>
<li><strong>连接处理器 acceptTcpHandler</strong>：Redis 在启动时，在 initServer 中对监听的 socket 注册读事件，事件处理器为 acceptTcpHandler，该函数在有新连接进入时，会被派发器派发读任务。</li>
<li><strong>请求处理器 readQueryFromClient</strong>：连接函数在创建 client 时，会对新连接 socket 注册一个读事件，该读事件的事件处理器就是 readQueryFromClient。</li>
<li><strong>命令回复处理器 sendReplyToClient</strong>：当 redis需要发送响应给client时，Redis 事件循环中会对client的连接socket注册写事件，这个写事件的处理函数就是sendReplyToClient。</li>
</ul>
</li>
</ul>
<p><strong>协议命令解析及处理：</strong></p>
<ul>
<li><p>请求命令进入，触发 IO 读事件后。client 会从连接文件描述符读取请求，并存入 client 的 query buffer 中。</p>
</li>
<li><p>client 读取完请求命令后，则根据 query buff 进行协议解析。协议解析时，首先查看协议的首字符。</p>
<ul>
<li>如果是 *，则解析为字符块数组类型，即 MULTIBULK。</li>
<li>否则请求解析为 INLINE 类型。INLINE 类型是以 CRLF 结尾的单行字符串，协议命令及参数以空格分隔。</li>
</ul>
</li>
<li><p>协议解析完毕后，将请求参数个数存入 client 的 argc 中，将请求的具体参数存入 client 的 argv 中。</p>
</li>
</ul>
<p><strong>对于 quit 指令</strong>，直接返回 OK，设置 flag 为回复后关闭连接。</p>
<p><strong>对于非 quit 指令</strong>，以 client 中 argv[0] 作为命令，从 server 中的命令表中找到对应的 redisCommand。如果没有找到 redisCommand，则返回未知 cmd 异常。如果找到 cmd，则开始执行 redisCommand 中的 proc 函数，进行具体命令的执行。在命令执行完毕后，将响应写入 client 的写缓冲。并按配置和部署，将写指令分发给 aof 和 slaves。同时更新相关的统计数值。</p>
<h4 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h4><p><strong>Redis 中的时间事件分为 2 类：</strong></p>
<ul>
<li><strong>单次时间事件</strong>，即执行完毕后，该时间事件就结束了。</li>
<li><strong>周期性事件</strong>，在事件执行完毕后，会继续设置下一次执行的事件，从而在时间到达后继续执行，并不断重复。</li>
</ul>
<p><strong>时间事件主要有 5 个属性：</strong></p>
<ul>
<li><p><strong>事件 ID</strong>：Redis 为时间事件创建全局唯一 ID，该 ID 按从小到大的顺序进行递增。</p>
</li>
<li><p><strong>执行时间 when_sec 和 when_ms</strong>：精确到毫秒，记录该事件的到达可执行时间。</p>
</li>
<li><p><strong>时间事件处理器 timeProc</strong>：在时间事件到达时，Redis 会调用相应的 timeProc 处理事件。</p>
</li>
<li><p><strong>关联数据 clientData</strong>：在调用 timeProc 时，需要使用该关联数据作为参数。</p>
</li>
<li><p><strong>链表指针 prev 和 next</strong>：它用来将时间事件维护为双向链表，便于插入及查找所要执行的时间事件。</p>
</li>
</ul>
<p>时间事件的处理是在事件循环中的 aeProcessEvents 中进行。</p>
<p><strong>执行过程</strong>：</p>
<ul>
<li>首先<strong>遍历所有的时间事件</strong>。比较事件的时间和当前时间，找出可执行的时间事件。</li>
<li>然后执行时间事件的 <strong>timeProc 函数</strong>。</li>
<li>执行完毕后，对于周期性时间，设置时间新的执行时间；对于单次性时间，设置事件的 ID为 -1，后续在事件循环中，下一次执行 aeProcessEvents 的时候从链表中删除。</li>
</ul>
<h3 id="数据存储及管理模块"><a href="#数据存储及管理模块" class="headerlink" title="数据存储及管理模块"></a>数据存储及管理模块</h3><p>Redis 中所有数据都保存在 DB 中，<strong>一个 Redis 默认最多支持 16 个 DB</strong>。Redis 中的每个 DB 都对应一个 redisDb 结构，即每个 Redis 实例，默认有 16 个 redisDb。用户访问时，<strong>默认使用的是 0 号 DB</strong>，可以通过 select $dbID 在不同 DB 之间切换。</p>
<h4 id="redisDb"><a href="#redisDb" class="headerlink" title="redisDb"></a>redisDb</h4><p>redisDb 结构分为五个部分：</p>
<ul>
<li><strong>dict 主字典</strong>：用来存储当前 DB 中的所有数据，它将 key 和各种数据类型的 value 关联起来，该 dict 也称 key space。</li>
<li><strong>expires 过期字典</strong>：用来存储过期时间 key，存的是 key 与过期时间的映射。</li>
<li><strong>blocking_keys 阻塞字典</strong>：存储的是处于阻塞状态的 key 及 client 列表。例如：在执行 Redis 中 list 的阻塞命令 blpop、brpop 或者 brpoplpush 时，如果对应的 list 列表为空，Redis 就会将对应的 client 设为阻塞状态，同时将该 client 添加到 DB 中 blocking_keys 这个阻塞 dict。</li>
<li><strong>ready_keys 解除阻塞字典</strong>：当有其他调用方在向某个 key 对应的 list 中增加元素时，Redis 会检测是否有 client 阻塞在这个 key 上，即检查 blocking_keys 中是否包含这个 key，如果有则会将这个 key 加入 read_keys 这个 dict 中。</li>
<li><strong>watched_keys 监控字典</strong>：当 client 使用 watch 指令来监控 key 时，这个 key 和 client 就会被保存到 watched_keys 这个 dict 中。</li>
</ul>
<p>redisDb 中可以保存所有的数据类型，而 Redis 中所有数据类型都是存放在一个叫 <strong>redisObject</strong> 的结构中。</p>
<h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a><strong>dict</strong></h4><p><strong>Redis 中的数据实际是存在 DB 中的 2 个核心 dict 字典中的</strong>。实际上 dict 也是 Redis 的一种使用广泛的内部数据结构。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_24.png" alt="dict数据结构" style="zoom:90%;">

<p><strong>Redis 中的 dict，类似于 Memcached 中 hashtable。</strong>都可以用于 key 或元素的快速插入、更新和定位。</p>
<p>dict 字典中，有一个长度为 2 的哈希表数组，日常访问用 0 号哈希表，如果 0 号哈希表元素过多，则分配一个 2 倍 0 号哈希表大小的空间给 1 号哈希表，然后进行逐步迁移，rehashidx 这个字段就是专门用来做标志迁移位置的。</p>
<p>在哈希表操作中，<strong>采用单向链表来解决 hash 冲突问题</strong>。dict 中还有一个重要字段是 type，它用于保存 hash 函数及 key/value 赋值、比较函数。</p>
<p>dictht 中的 table 是一个 hash 表数组，每个桶指向一个 dictEntry 结构。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_25.png" alt="dictht结构" style="zoom:67%;">

<p>其中 <strong>key 是 sds 字符串</strong>（简单动态字符串，本质是一个 char<em>，内部通过 sdshdr 进行管理。），v*</em>alue 为存储各种数据类型的 redisObject 结构**。</p>
<h4 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h4><img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_23.png" alt="redisObject结构" style="zoom:80%;">

<p><strong>redisObject 由 5 个字段组成：</strong></p>
<ul>
<li><strong>type</strong>：即 Redis 对象的数据类型，目前支持 7 种 type 类型，如上图；</li>
<li><strong>encoding</strong>：Redis 对象的内部编码方式，即内部数据结构类型，目前支持 10 种编码方式，如图；</li>
<li><strong>LRU</strong>：存储的是淘汰数据用的 LRU 时间或 LFU 频率及时间的数据。</li>
<li><strong>refcount</strong>：记录 Redis 对象的引用计数，用来表示对象被共享的次数，共享使用时加 1，不再使用时减 1，当计数为 0 时表明该对象没有被使用，就会被释放，回收内存。</li>
<li><strong>ptr</strong>：它指向对象的内部数据结构。比如一个代表 string 的对象，它的 ptr 可能指向一个 sds 或者一个 long 型整数。</li>
</ul>
<h4 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a><strong>ziplist</strong></h4><p>为了<strong>节约内存，并减少内存碎片</strong>，Redis 设计了 ziplist 压缩列表内部数据结构。</p>
<p>压缩列表是<strong>一块连续的内存空间</strong>，可以连续存储多个元素，没有冗余空间，是一种连续内存数据块组成的<strong>顺序型内存结构</strong>。</p>
<p>由于 ziplist 是连续紧凑存储，没有冗余空间，所以插入新的元素需要 realloc 扩展内存，所以如果 ziplist 占用空间太大，realloc 重新分配内存和拷贝的开销就会很大，所以 ziplist <strong>不适合存储过多元素，也不适合存储过大的字符串。</strong> </p>
<p>因此只有在元素数和 value 数都不大的时候，ziplist 才作为 hash 和 zset 的内部数据结构。其中 ：</p>
<ul>
<li><strong>hash</strong> 使用 ziplist 作为内部数据结构的限制时，元素数默认不超过 512 个，value 值默认不超过 64 字节。可以通过修改配置来调整 hash_max_ziplist_entries 、hash_max_ziplist_value 这两个阀值的大小。</li>
<li><strong>zset 有序集合</strong>，使用 ziplist 作为内部数据结构的限制元素数默认不超过 128 个，value 值默认不超过 64 字节。可以通过修改配置来调整 zset_max_ziplist_entries 和 zset_max_ziplist_value 这两个阀值的大小。</li>
</ul>
<h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a><strong>quicklist</strong></h4><p>Redis 在 3.2 版本之后引入 quicklist，用以替换 linkedlist。</p>
<p>因为 linkedlist 每个节点有前后指针，要占用 16 字节，而且每个节点独立分配内存，很容易加剧内存的碎片化。而 ziplist 由于紧凑型存储，增加元素需要 realloc，删除元素需要内存拷贝，天然不适合元素太多、value 太大的存储。</p>
<p>而 quicklist 快速列表应运而生，它是一个<strong>基于 ziplist 的双向链表</strong>。将数据分段存储到 ziplist，然后将这些 ziplist 用双向指针连接。</p>
<p><strong>快速列表从头尾读写数据很快，时间复杂度为 O(1)。也支持从中间任意位置插入或读写元素，但速度较慢，时间复杂度为 O(n)。</strong>快速列表当前主要作为 <strong>list 列表的内部数据结构</strong>。</p>
<h4 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a><strong>zskiplist</strong></h4><p>跳跃表 zskiplist 是一种<strong>有序数据结构，它通过在每个节点维持多个指向其他节点的指针，从而可以加速访问</strong>。（联想到Java中的SkipList）</p>
<p>跳跃表支持平均 O(logN) 和最差 O(n) 复杂度的节点查找。</p>
<p>在大部分场景，跳跃表的效率和平衡树接近，但跳跃表的实现比平衡树要简单，所以不少程序都用跳跃表来替换平衡树。</p>
<p>如果 <strong>sorted set（zset） 类型</strong>的元素数比较多或者元素比较大，Redis 就会选择跳跃表来作为 sorted set有序集合的内部数据结构。</p>
<p><strong>总结：8种数据类型对应哪些内部数据结构？</strong></p>
<ul>
<li>string 字符串，Redis 主要采用 sds 来进行存储。</li>
<li>list 列表，Redis 采用 quicklist 进行存储。</li>
<li>set 集合类型，Redis 采用 dict 来进行存储。</li>
<li>sorted set 有序集合类型<ul>
<li>如果元素数小于 128 且元素长度小于 64，则使用 ziplist 存储，</li>
<li>否则使用 zskiplist 存储。</li>
</ul>
</li>
<li>哈希类型<ul>
<li>如果元素数小于 512，并且元素长度小于 64，则用 ziplist 存储，</li>
<li>否则使用 dict 字典存储。</li>
</ul>
</li>
<li>hyperloglog，采用 sds 简单动态字符串存储。</li>
<li>geo<ul>
<li>如果位置数小于 128，则使用 ziplist 存储，</li>
<li>否则使用 zskiplist 存储。</li>
</ul>
</li>
<li>bitmap，采用 sds 简单动态字符串存储。</li>
</ul>
<h3 id="主从复制-集群管理模块"><a href="#主从复制-集群管理模块" class="headerlink" title="主从复制\集群管理模块"></a>主从复制\集群管理模块</h3><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>为了避免单点故障，数据存储需要进行多副本构建。同时由于 Redis 的核心操作是单线程模型的，单个 Redis 实例能处理的请求 TPS 有限。因此 Redis 自面世起，基本就提供了复制功能，而且对复制策略不断进行优化。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_26.png" alt="主从复制架构图" style="zoom:75%;">

<ul>
<li>Redis 的一个 master 可以挂载多个 slave，而 slave 下还可以挂载多个 slave，形成<strong>多层嵌套结构</strong>。</li>
<li>所有写操作都在 master 实例中进行，master 执行完毕后，将写指令分发给挂在自己下面的 slave 节点。实现同步。</li>
<li>主库 master 和从库 slave 之间通过复制 id 进行匹配，避免 slave 挂到错误的 master。</li>
<li>写操作在master，读操作可以分摊到所有slave节点，<strong>读写分离</strong>，这样整个 master-slave 组合，读写能力都可以得到大幅提升。</li>
<li>master 在分发写请求时，同时会将写指令复制一份存入<strong>复制积压缓冲</strong>，这样当 slave 短时间断开重连时，只要 slave 的<strong>复制位置点</strong>仍然在复制积压缓冲，则可以从之前的复制位置点之后继续进行复制，提升复制效率。</li>
</ul>
<p><strong>Redis复制分为2类：</strong></p>
<ul>
<li><p><strong>全量复制（同步）</strong>：master 会将内存数据通过 bgsave 落地到 <strong>rdb</strong>，同时，将构建 内存快照期间 的写指令，存放到复制缓冲中，当 rdb 快照构建完毕后，master 将 <strong>rdb 和复制缓冲队列中的数据</strong>全部发送给 slave，slave 完全重新创建一份数据。</p>
<p>这个过程，耗时，耗性能，耗带宽，对系统性能和资源资源的访问都影响比较大。在 Redis 2.8 之前，Redis 基本只支持全量复制。</p>
</li>
<li><p><strong>增量复制（同步）</strong>：master 只发送 slave 上次复制位置之后的写指令，不用构建 rdb，而且传输内容非常有限，对 master、slave 的负荷影响很小，对带宽的影响可以忽略，整个系统受影响非常小。</p>
</li>
</ul>
<h4 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h4><p>通过上面的学习，我们知道<strong>复制功能可以 N 倍提升 Redis 节点的读性能</strong>，而集群则可以通过<strong>分布式方案来 N 倍提升 Redis 的写性能</strong>。除了提升性能之外，Redis 集群还可以提供更大的容量，提升资源系统的可用性。</p>
<p><strong>Redis 集群的分布式方案主要有 3 种</strong>：</p>
<ul>
<li><strong>Client 端分区方案</strong></li>
<li><strong>Proxy 分区方案</strong></li>
<li><strong>Redis Cluster 分区方案</strong></li>
</ul>
<h5 id="Client-端分区"><a href="#Client-端分区" class="headerlink" title="Client 端分区"></a>Client 端分区</h5><p><strong>Client 端分区方案</strong>就是由 Client 决定数据被存储到哪个 Redis 分片，或者由哪个 Redis 分片来获取数据。它的核心思想是<strong>通过哈希算法将不同的 key 映射到固定的 Redis 分片节点上</strong>。</p>
<ul>
<li>对于单个 key 请求，Client 直接对 key 进行哈希后，确定 Redis 分片，然后进行请求。</li>
<li>而对于一个请求附带多个 key 的场景，Client 会首先将这些 key 按哈希分片进行分类，从而将一个请求分拆为多个请求，然后再分别请求不同的哈希分片节点。</li>
</ul>
<p>Client 通过哈希算法将数据进行分布,<strong>一般采用的哈希算法是:</strong></p>
<ul>
<li><strong>取模哈希;</strong></li>
<li><strong>一致性哈希</strong>;</li>
<li><strong>区间分布哈希</strong>：实际是一种取模哈希的变种，取模哈希是哈希并取模计算后，按哈希值来分配存储节点，而区间哈希是在哈希计算后，将哈希划分为多个区间，然后将这些区间分配给存储节点。如哈希后分 1024 个哈希点，然后将 0-511 作为分片 1，将 512-1023 作为分片 2。</li>
</ul>
<p><strong>问题：</strong>对于 Client 端分区，由于 Redis 集群有多个 master 分片，同时每个 master 下挂载多个 slave，每个 Redis 节点都有独立的 IP 和端口。如果 master 异常需要切换 master，或读压力过大需要扩展新的 slave，这些都会涉及集群存储节点的变更，需要 Client 端做连接切换。</p>
<p><strong>解决方案</strong>：为了避免 Client 频繁变更 IP 列表，可以采用 DNS 的方式来管理集群的主从。对 Redis 集群的每个分片的主和从均采用不同 DNS 域名。Client 通过域名解析的方式获取域名下的所有 IP，然后来访问集群节点。</p>
<p>在 DNS 访问模式下，Client 需要异步定时探测主从域名，如果发现 IP 变更，及时与新节点建立连接，并关闭老连接。</p>
<p><strong>优缺点</strong></p>
<ul>
<li><strong>优点</strong>：Client 端分区方案的优点在于分区逻辑简单，配置简单，Client 节点之间和 Redis 节点之间均无需协调，灵活性强。而且 Client 直接访问对应 Redis 节点，没有额外环节，性能高效。</li>
<li><strong>缺点</strong>：但该方案扩展不便。在 Redis 端，只能成倍扩展，或者预先分配足够多的分片。在 Client 端，每次分片后，业务端需要修改分发逻辑，并进行重启。</li>
</ul>
<h5 id="Proxy-端分区"><a href="#Proxy-端分区" class="headerlink" title="Proxy 端分区"></a>Proxy 端分区</h5><p>Proxy 端分区方案是指 Client 发送请求给 Proxy 请求代理组件，Proxy 解析 Client 请求，并将请求分发到正确的 Redis 节点，然后等待 Redis 响应，最后再将结果返回给 Client 端。</p>
<ul>
<li>对于单个 key 请求，Proxy 直接对 key 进行哈希后，确定 请求路由，然后进行请求。</li>
<li>如果一个请求包含多个 key，Proxy 需要将请求的多个 key，按分片逻辑分拆为多个请求，然后分别请求不同的 Redis 分片，接下来等待Redis响应，在所有的分拆响应到达后，再进行聚合组装，最后返回给 Client。</li>
</ul>
<p><strong>如果系统运行中，主从变更或发生扩缩容，也只需由 Proxy 变更完成，业务 Client 端基本不受影响。</strong></p>
<p><strong>常见的 Proxy 端分区方案有2种：</strong></p>
<ul>
<li>基于 Twemproxy 的简单分区方案：Twitter 开源的一个组件，支持 Redis 和 Memcached 协议访问的代理组件。Twemproxy 实现简单、稳定性高，在一些访问量不大且很少发生扩缩的业务场景中，可以很好的满足需要。但由于 Twemproxy 是单进程单线程模型的，对包含多个 key 的 mutli 请求，由于需要分拆请求，然后再等待聚合，处理性能较低。可单独详细了解。</li>
<li>基于Codis 的可平滑数据迁移的分区方案：Codis 是一个较为成熟的分布式 Redis 解决方案。对于业务 Client 访问，连接 Codis-proxy 和连接单个 Redis 几乎没有区别。Codis 底层除了会自动解析分发请求之外，还可以在线进行数据迁移，使用非常方便。</li>
</ul>
<p>以上俩种方案可自行了解。</p>
<p><strong>优缺点</strong></p>
<ul>
<li><strong>优点</strong>：使 Client 访问逻辑和 Redis 分布逻辑解耦，业务访问便捷简单。在资源发生变更或扩缩容时，只用修改数量有限的 Proxy 即可，数量庞大的业务 Client 端不用做调整。</li>
<li><strong>缺点</strong>：访问时请求需要经过 Proxy 中转，访问多跳了一级，性能会存在损耗，一般损耗会达到 5~15% 左右。另外多了一个代理层，整个系统架构也会更复杂。</li>
</ul>
<h5 id="Redis-Cluster-分区"><a href="#Redis-Cluster-分区" class="headerlink" title="Redis Cluster 分区"></a><strong>Redis Cluster 分区</strong></h5><p>Redis 社区版在 3.0 后开始引入 Cluster 策略，一般称之为 Redis-Cluster 方案。</p>
<p><strong>Redis-Cluster 按 slot 进行数据的读写和管理，一个 Redis-Cluster 集群包含 16384 个 slot。每个 Redis 分片负责其中一部分 slot。</strong>在集群启动时，<strong>按需将所有 slot 分配到不同节点，在集群系统运行后，按 slot 分配策略，将 key 进行 hash 计算</strong>，并路由到对应节点 访问。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_27.png" alt="Redis-Cluster结构" style="zoom:90%;">

<p><strong>在 Redis-Cluster 集群中，key 的访问需要 smart client 配合。</strong></p>
<ul>
<li>Client 首先发送请求给 Redis 节点，Redis 在接受并解析命令后，会对 key 进行 hash 计算以确定 slot 槽位。计算公式是对 key 做 crc16 哈希，然后对 16383 进行按位与操作。</li>
<li>如果 Redis 发现 key 对应的 slot 在本地，则直接执行后返回结果。</li>
<li>如果 Redis 发现 key 对应的 slot 不在本地，会返回 moved 异常响应，并附带 key 的 slot，以及该 slot 对应的正确 Redis 节点的 host 和 port。</li>
<li>Client 根据响应解析出正确的节点 IP 和端口，然后把请求重定向到正确的 Redis，即可完成请求。为了加速访问，Client 需要缓存 slot 与 Redis 节点的对应关系，这样可以直接访问正确的节点，以加速访问性能。   </li>
</ul>
<p><strong>Redis Cluster 是一个去中心化架构</strong>，每个节点记录全部 slot 的拓扑分布。</p>
<p><strong>Redis Cluster 下的不同 Redis 分片节点通过 gossip 协议进行互联</strong>，使用 gossip 的优势在于，该方案无中心控制节点，这样，更新不会受到中心节点的影响，可以通过通知任意一个节点来进行管理通知。</p>
<p><strong>Redis Cluster 支持还支持slot 迁移</strong>。随着业务访问模型的变化，Redis 部分节点可能会出现压力过大、访问不均衡的现象，此时可以将 slot 在 Redis 分片节点内部进行迁移，以均衡访问。如果业务不断发展，数据量过大、TPS过高，还可以将 Redis 节点的部分 slot 迁移到新节点，增加 Redis-Cluster 的分片，对整个 Redis 资源进行扩容，已提升整个集群的容量及读写能力。</p>
<p><strong>Redis-Cluster 提供了灵活的节点扩缩容方案</strong>，可以在不影响用户访问的情况下，动态为集群增加节点扩容，或下线节点为集群缩容。</p>
<p>对于线上应用，还需要<strong>为slot节点增加从库，以增加读写能力及可用性</strong>。在节点上增加从库，需要注意的是，不能使用非集群模式下的 slaveof 指令，而要使用 cluster replication，才能完成集群分片节点下的 slave 添加。另外，对于集群模式，slave 只能挂在分片 master 上，slave 节点自身不能再挂载 slave。</p>
<p>Redis 社区官方在源代码中也提供了 <strong>redis-trib.rb，作为 Redis Cluster 的管理工具</strong>。该工具用 Ruby 开发，所以在使用前，需要安装相关的依赖环境。redis-trib 工具通过封装前面所述的 Redis 指令，从而支持<strong>创建集群、检查集群、添加删除节点、在线迁移 slot</strong> 等各种功能。</p>
<p><strong>优缺点</strong></p>
<ul>
<li><p><strong>优点</strong>：由社区官方实现，并有 Redis-trib 集群工具，上线和使用起来比较便捷。同时它支持在线扩缩，可以随时通过工具查看集群的状态。</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>数据存储和集群逻辑耦合，代码逻辑复杂，容易出错。</li>
<li>Redis 节点要存储 slot 和 key 的映射关系，需要额外占用较多内存，特别是对 value size 比较小、而key相对较大的业务，影响更是明显。</li>
<li>key 迁移过程是阻塞模式，迁移大 value 会导致服务卡顿。而且，迁移过程，先获取 key，再迁移，效率低。</li>
<li>Cluster 模式下，集群复制的 slave 只能挂载到 master，不支持 slave 嵌套，会导致 master 的压力过大，无法支持那些，需要特别多 slave、读 TPS 特别大的业务场景。</li>
</ul>
</li>
</ul>
<h3 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h3><h4 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h4><p><strong>Redis</strong> 持久化是一个将<strong>内存数据转储到磁盘的过程</strong>。</p>
<p><strong>Redis</strong> 目前支持 <strong>RDB、AOF，以及混合存储三种模式</strong>。</p>
<h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><p><strong>Redis</strong> 的 <strong>RDB</strong> 持久化是以<strong>快照的方式</strong>将内存数据存储到磁盘。</p>
<p>在需要进行 RDB 持久化时，Redis 会将内存中的<strong>所有数据以二进制的格式落地</strong>，每条数据存储的<strong>内容包括过期时间、数据类型、key，以及 value。</strong>当 Redis 重启时，如果 appendonly 关闭，则会读取 RDB 持久化生成的二进制文件进行数据恢复。</p>
<p><strong>触发构建 RDB 的场景：</strong></p>
<ul>
<li>通过 <strong>save 或 bgsave 命令</strong>进行主动 RDB 快照构建。</li>
<li>利用<strong>配置 save m n</strong> 来进行自动快照生成。它是指在 m 秒中，如果插入或变更 n 个 key，则自动触发 bgsave。这个配置可以设置多个配置行，以便组合使用。</li>
<li><strong>主从复制</strong>，如果从库需要进行全量复制，此时主库也会进行 bgsave 生成一个 RDB 快照。</li>
<li><strong>执行 flushall 清空所有数据，或执行 shutdown 关闭服务</strong>时，也会触发 Redis 自动构建 RDB 快照。</li>
</ul>
<p><strong>save 和 bgsave 命令对比：</strong></p>
<ul>
<li><strong>save</strong>：是在主进程中进行 RDB 持久化的，持久化期间 Redis 处于<strong>阻塞</strong>状态，不处理任何客户请求，所以一般使用较少。</li>
<li><strong>bgsave</strong>：是 fork 一个<strong>子进程</strong>，然后在子进程中构建 RDB 快照，构建快照的过程不直接影响用户的访问，但仍然会增加机器负载。线上 Redis 快照备份，一般会选择凌晨低峰时段，通过 bgsave 主动触发进行备份。</li>
</ul>
<p><strong>RDB 快照文件主要由 3 部分组成：</strong></p>
<ul>
<li><p><strong>RDB 头部</strong>，主要包括 RDB 的版本，以及 Redis 版本、创建日期、占用内存等辅助信息。</p>
</li>
<li><p><strong>RedisDB 的数据</strong>。存储每个 RedisDB 时，会首先记录当前 RedisDB 的DBID，然后记录主 dict 和 expire dict 的记录数量，最后再轮询存储每条数据记录。</p>
<p>存储数据记录时，如果数据有过期时间，首先记录过期时间。如果 Redis 的 maxmemory_policy 过期策略采用 LRU 或者 LFU，还会将 key 对应的 LRU、LFU 值进行落地，最后记录数据的类型、key，以及 value。</p>
</li>
<li><p><strong>RDB 的尾部</strong>。RDB 尾部，首先存储 Redis 中的 Lua 脚本等辅助信息。然后存储 EOF 标记，即值为 255 的字符。最后存 RDB 的 cksum。</p>
</li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li><p><strong>优点</strong>：RDB 采用二进制方式存储内存数据，文件小，且启动时恢复速度快。</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><p>二进制存储，可读性差，而且由于格式固定，不同版本之间可能存在兼容性问题。</p>
</li>
<li><p>构建 RDB 时，一个快照文件只能存储，构建时刻的内存数据，无法记录之后的数据变更。构建 RDB 的过程，即便在子进程中进行，但仍然属于 CPU 密集型的操作，而且每次落地全量数据，耗时也比较长，不能随时进行，特别是不能在高峰期进行。</p>
</li>
</ul>
</li>
</ul>
<h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><p>Redis 的 AOF 持久化是<strong>以命令追加的方式进行数据落地</strong>的。</p>
<p>通过打开 appendonly 配置，Redis 将每一个写指令追加到磁盘 AOF 文件，从而及时记录内存数据的最新状态。这样即便 Redis 被 crash 或异常关闭后，再次启动，也可以通过加载 AOF，来恢复最新的全量数据，基本不会丢失数据。</p>
<p>AOF 文件中<strong>存储的协议是写指令的 multibulk 格式</strong>，这是 Redis 的标准协议格式，所以<strong>不同的 Redis 版本均可解析并处理，兼容性很好</strong>。</p>
<p>但是，由于 Redis 会记录所有写指令操作到 AOF，大量的中间状态数据，甚至被删除的过期数据，都会存在 AOF 中，<strong>冗余度很大</strong>，而且每条指令还需通过加载和执行来进行数据恢复，<strong>耗时会比较大</strong>。</p>
<p><strong>AOF 数据的落地流程:</strong></p>
<ul>
<li>Redis 在处理完写指令后，首先将写指令<strong>写入 AOF 缓冲</strong>，</li>
<li>然后通过 server_cron 定期将 AOF 缓冲<strong>写入文件缓冲</strong>。</li>
<li>最后按照配置策略进行 fsync，将文件缓冲的数据真正同步<strong>写入磁盘</strong>。</li>
</ul>
<p><strong>Redis 通过 appendfsync 来设置三种不同的同步文件缓冲策略</strong>：</p>
<ul>
<li>第一种配置策略是 <strong>no</strong>，即 Redis 不主动使用 fsync 进行文件数据同步落地，而是由操作系统的 write 函数去确认同步时间，在 Linux 系统中大概每 30 秒会进行一次同步，如果 Redis 发生 crash，就会造成大量的数据丢失。</li>
<li>第二种配置策略是 <strong>always</strong>，即每次将 AOF 缓冲写入文件，都会调用 fsync 强制将内核数据写入文件，安全性最高，但性能上会比较低效，而且由于频繁的 IO 读写，磁盘的寿命会大大降低。</li>
<li>第三种配置策略是 <strong>everysec</strong>。即每秒通过 BIO 线程进行一次 fsync。这种策略在安全性、性能，以及磁盘寿命之间做较好的权衡，可以较好的满足线上业务需要。</li>
</ul>
<p>随着时间的推移，AOF 持续记录所有的写指令，<strong>AOF 会越来越大</strong>，而且会充斥大量的中间数据、过期数据，为了减少无效数据，提升恢复时间，<strong>可以定期对 AOF 进行 rewrite 操作</strong>。</p>
<ul>
<li>执行 bgrewiretaof 命令来进行</li>
<li>配置重写策略进行</li>
</ul>
<p><strong>AOF 进行 rewrite 流程：</strong></p>
<ul>
<li>首先会 fork 一个子进程。子进程轮询所有 <strong>RedisDB 快照</strong>，<strong>将所有内存数据转为 cmd，并写入临时文件</strong>。</li>
<li>在子进程 rewriteaof 时，主进程可以继续执行用户请求，执行完毕后将<strong>写指令写入旧的 AOF 文件和 rewrite 缓冲（增量数据指令）。</strong></li>
<li>子进程将 <strong>RedisDB 中数据落地完毕后</strong>，通知主进程。主进程从而<strong>将 AOF rewite 缓冲数据写入 AOF 临时文件</strong>，然后用新的 AOF 文件替换旧的 AOF 文件，最后通过 BIO 线程异步关闭旧的 AOF 文件。（<strong>即快照 + 增量数据</strong>）</li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li>可以记录全部的最新内存数据，最多也就是 1-2 秒的数据丢失。</li>
<li>AOF 通过 Redis 协议来追加记录数据，兼容性高，而且可以持续轻量级的保存最新数据。</li>
<li>因为是直接通过 Redis 协议存储，可读性也比较好。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：随着时间的增加，冗余数据增多，文件会持续变大，而且数据恢复需要读取所有命令并执行，恢复速度相对较慢。（定期rewrite）</p>
</li>
</ul>
<h5 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h5><p>Redis 在 4.0 版本之后，引入了混合持久化方式，而且在 5.0 版本后默认开启。</p>
<p>混合模式一体化使用 RDB 和 AOF，综合 RDB 和 AOF 的好处。即可包含全量数据，加载速度也比较快。可以使用 aof-use-rdb-preamble 配置来明确打开混合持久化模式。</p>
<p>混合持久化也是通过 bgrewriteaof 来实现的。当启用混合存储后，进行 bgrewriteaof 时，主进程首先依然是 fork 一个子进程，<strong>子进程首先将内存数据以 RDB 的二进制格式写入 AOF 临时文件中。然后，再将落地期间缓冲的新增写指令，以命令的方式追加到临时文件</strong>。</p>
<p><strong>优缺点</strong></p>
<ul>
<li><p>优点：包含全量数据，加载速度快。</p>
</li>
<li><p>缺点：头部的 RDB 格式兼容性和可读性较差。</p>
</li>
</ul>
<h4 id="Redis-BIO异步处理大任务"><a href="#Redis-BIO异步处理大任务" class="headerlink" title="Redis BIO异步处理大任务"></a><strong>Redis BIO异步处理大任务</strong></h4><p><strong>Redis</strong> 在运行过程中，不可避免的会产生一些运行慢的、容易引发阻塞的任务，而 Redis 的核心处理线程是单进程单线程模型，所有命令的接受与处理、数据淘汰等都在主线程中进行，这些任务处理速度非常快。如果核心单线程还要处理那些慢任务，在处理期间，势必会阻塞用户的正常请求，导致服务卡顿。</p>
<p>为此，<strong>Redis</strong> 引入了 <strong>BIO 后台线程</strong>，专门处理那些慢任务，从而保证和提升主线程的处理能力。</p>
<p><strong>Redis</strong> 的 BIO 线程采用<strong>生产者-消费者模型。主线程是生产者，生产各种慢任务，然后存放到任务队列中。</strong>BIO 线程是消费者，从队列获取任务并进行处理。</p>
<p>Redis 启动时，会创建<strong>三个任务队列，并对应构建 3 个 BIO 线程，三个 BIO 线程与 3 个任务队列之间一一对应</strong>，三个任务分别是：</p>
<ul>
<li><strong>close 关闭文件任务</strong>：rewriteaof 完成后，主线程需要关闭旧的 AOF 文件，就向 close 队列插入一个旧 AOF 文件的关闭任务。由 close 线程来处理。</li>
<li><strong>fysnc 任务</strong>：Redis 将 AOF 数据缓冲写入文件内核缓冲后，需要定期将系统内核缓冲数据写入磁盘，此时可以向 fsync 队列写入一个同步文件缓冲的任务，由 fsync 线程来处理。</li>
<li><strong>lazyfree 任务</strong>：Redis 在需要淘汰元素数大于 64 的聚合类数据类型时，如列表、集合、哈希等，就往延迟清理队列中写入待回收的对象，由 lazyfree 线程后续进行异步回收。</li>
</ul>
<p><strong>BIO 线程的整个处理流程：</strong></p>
<ul>
<li>当主线程有慢任务需要异步处理时。就会向对应的任务队列提交任务。提交任务时，首先申请内存空间，构建 BIO 任务。然后对队列锁进行加锁，在队列尾部追加新的 BIO 任务，最后尝试唤醒正在等待任务的 BIO 线程。</li>
<li>BIO 线程启动时或持续处理完所有任务，发现任务队列为空后，就会阻塞，并等待新任务的到来。当主线程有新任务后，主线程会提交任务，并唤醒 BIO 线程。BIO 线程随后开始轮询获取新任务，并进行处理。当处理完所有 BIO 任务后，则再次进入阻塞，等待下一轮唤醒。</li>
</ul>
<h4 id="Redis-多线程"><a href="#Redis-多线程" class="headerlink" title="Redis 多线程"></a>Redis 多线程</h4><p>Redis 自问世以来，广受好评，应用广泛。但相比， Memcached 单实例压测 TPS 可以高达百万，线上可以稳定跑 20-40 万而言，Redis 的单实例压测 TPS 不过 10-12 万，线上一般最高也就 2-4 万，<strong>仍相差一个数量级</strong>。</p>
<p>Redis 慢的<strong>主要原因是单进程单线程模型。</strong>虽然一些重量级操作也进行了分拆，如 RDB 的构建在子进程中进行，文件关闭、文件缓冲同步，以及大 key 清理都放在 BIO 线程异步处理，但还远远不够。</p>
<p>虽然可以通过<strong>多部署几个 Redis 实例来达到类似多线程的效果</strong>。但多实例部署则<strong>带来了运维复杂的问题</strong>，而且单机多实例部署，会相互影响，进一步增大运维的复杂度。</p>
<p>因此，Redis 即将在 6.0 版本引入多线程模型。Redis 的多线程模型，分为主线程和 IO 线程。</p>
<p>拭目以待….</p>
<blockquote>
<p>笔记来源：陈波 老师的 《300分钟吃透分布式缓存》课程</p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>缓存</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/2021/03/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><ul>
<li>JMS（Java消息服务规范）：特点、消息模型、消费方式、编程模型</li>
<li>使用场景：应用解耦合、服务通信、异步任务、削峰填谷、消息广播</li>
<li>消息协议：JMS、AMQP</li>
<li>常用队列：RabbitMQ、ActiveMQ、RocketMQ、Kafka（优劣对比）</li>
</ul>
<h2 id="Java-消息服务接口（JMS）"><a href="#Java-消息服务接口（JMS）" class="headerlink" title="Java 消息服务接口（JMS）"></a>Java 消息服务接口（JMS）</h2><blockquote>
<p><strong>JMS</strong> 即 <strong>Java消息服务（Java Message Service）应用程序接口</strong>，是一个<a href="https://baike.baidu.com/item/Java平台" target="_blank" rel="noopener">Java平台</a>中关于面向<a href="https://baike.baidu.com/item/消息中间件/5899771" target="_blank" rel="noopener">消息中间件</a>（MOM）的<a href="https://baike.baidu.com/item/API/10154" target="_blank" rel="noopener">API</a>，用于在两个应用程序之间，或<a href="https://baike.baidu.com/item/分布式系统/4905336" target="_blank" rel="noopener">分布式系统</a>中发送消息，进行<a href="https://baike.baidu.com/item/异步通信/2273903" target="_blank" rel="noopener">异步通信</a>。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p>
<p>《百度百科》</p>
</blockquote>
<p><strong>JMS</strong>只是 <strong>Java EE</strong> 中定义的一组标准 <strong>API</strong>，它自身并不是一个消息服务系统，它是消息传送服务的一个<strong>抽象</strong>，也就是说它定义了消息传送的接口而并没有具体实现。</p>
<p>JMS其实就是一个<code>Java</code>业界的<code>标准规范</code>而已，提供了一些编程接口给第三方去实现。包括消息产生、发送、读取、接收等。像<code>ActiveMQ</code>、<code>RocketMQ</code>之类的框架都是针对这个标准去实现的。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>异步</strong>：规范（标准）指出：消息的发送应该是异步的、非阻塞的。也就是说消息的发送者发送完消息后就直接返回了，不需要等待接收者返回后才能返回，发送者和接收者可以说是互不影响，减轻或消除系统瓶颈，实现系统之间去除耦合，提高系统的整体可伸缩性和灵活性。</li>
<li><strong>可靠</strong>：JMS保证消息只会递送一次。</li>
</ul>
<h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><ul>
<li><strong>Point-to-Point(P2P)（点对点）</strong></li>
<li><strong>Publish/Subscribe(Pub/Sub) （发布/订阅模式）</strong></li>
</ul>
<h4 id="Point-to-Point-P2P"><a href="#Point-to-Point-P2P" class="headerlink" title="Point-to-Point(P2P)"></a>Point-to-Point(P2P)</h4><p><img src="/2021/03/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/message_queue_01.png" alt="点对点消息模型"></p>
<p>在<strong>P2P通信模式</strong>中，应用程序由消息队列，发送方，接收方组成。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p>
<ul>
<li>每个消息只有一个消费者；</li>
<li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列；</li>
<li>发送方不管是否在发送消息，接收方都可以从消息队列中去读消息；</li>
<li>接收方在接收完消息之后，需要向消息队列应答成功。</li>
</ul>
<h4 id="Publish-Subscribe-Pub-Sub"><a href="#Publish-Subscribe-Pub-Sub" class="headerlink" title="Publish/Subscribe(Pub/Sub)"></a>Publish/Subscribe(Pub/Sub)</h4><img src="/2021/03/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/message_queue_02.png" alt="订阅发布模型" style="zoom:115%;">



<p>在<strong>发布/订阅消息模型</strong>中，发布者发布一个消息，该消息通过<strong>topic</strong>传递给所有的客户端。</p>
<p>该模式下，发布者与订阅者都是匿名的，即发布者与订阅者都不知道对方是谁。并且可以动态的发布与订阅<strong>Topic</strong>。<strong>Topic</strong>主要用于保存和传递消息，且会一直保存消息直到消息被传递给客户端。</p>
<ul>
<li>一个消息可以传递个多个订阅者；</li>
<li>发布者与订阅者具有时间约束，针对某个主题（<strong>Topic</strong>）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。</li>
<li>为了缓和这样严格的时间相关性，<strong>JMS</strong>允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</li>
</ul>
<h3 id="消息的消费方式"><a href="#消息的消费方式" class="headerlink" title="消息的消费方式"></a>消息的消费方式</h3><ul>
<li><strong>同步</strong>：消费者通过调用<code>receive</code>方法显式地从<code>Destination</code>中获取消息。该<code>receive</code>方法在消息到达之前会一直阻塞，或者如果消息没有在指定的时间限制内到达，则可以超时。</li>
<li><strong>异步</strong>：使用异步方式接收消息的话，消息订阅者需注册一个消息监听者，类似于事件监听器，只要消息到达，JMS服务提供者会通过调用监听器的<code>onMessage()</code>递送消息</li>
</ul>
<h3 id="JMS编程模型"><a href="#JMS编程模型" class="headerlink" title="JMS编程模型"></a>JMS编程模型</h3><p><strong>ConnectionFactory</strong></p>
<p>创建 Connection对象的工厂，针对两种不同的jms消息模型，分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。</p>
<p><strong>Destination</strong></p>
<p>Destination的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。</p>
<p>所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。</p>
<p><strong>Connection</strong></p>
<p>Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。</p>
<p><strong>Session</strong></p>
<p>Session是我们操作消息的接口。可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分QueueSession和TopicSession。</p>
<p><strong>消息的生产者</strong></p>
<p>消息生产者由Session创建，并用于将消息发送到Destination。同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。</p>
<p><strong>消息消费者</strong></p>
<p>消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。</p>
<p><strong>MessageListener</strong></p>
<p>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。EJB中的MDB（Message-Driven Bean）就是一种MessageListener。</p>
<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><p>消息队列中间件是分布式系统中重要的组件，主要解决<strong>应用解耦，异步消息，流量削锋</strong>等问题，实现高性能，高可用，可伸缩和最终一致性架构。目前使用较多的消息队列有ActiveMQ，RabbitMQ，RocketMQ，Kafka等。</p>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ于2007年发布，是一个在<strong>AMQP</strong>(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p>
<h4 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h4><ol>
<li>可靠性：提供了多种技术可以让你在性能和可靠性之间进行权衡。这些技术包括持久性机制、投递确认、发布者证实和高可用性机制；</li>
<li>灵活的路由：消息在到达队列前是通过交换机进行路由的。RabbitMQ为典型的路由逻辑提供了多种内置交换机类型。如果你有更复杂的路由需求，可以将这些交换机组合起来使用，你甚至可以实现自己的交换机类型，并且当做RabbitMQ的插件来使用；</li>
<li>消息集群：在相同局域网中的多个RabbitMQ服务器可以聚合在一起，作为一个独立的逻辑代理来使用；</li>
<li>队列高可用：队列可以在集群中的机器上进行镜像，以确保在硬件问题下还保证消息安全；</li>
<li>支持多种协议：支持多种消息队列协议；</li>
<li>支持多种语言：用Erlang语言编写，支持只要是你能想到的所有编程语言；</li>
<li>管理界面：RabbitMQ有一个易用的用户界面，使得用户可以监控和管理消息Broker的许多方面；</li>
<li>跟踪机制：如果消息异常，RabbitMQ 提供消息跟踪机制，使用者可以找出发生了什么；</li>
<li>插件机制：提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</li>
</ol>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>由于Erlang语言的特性，消息队列性能较好，支持高并发；</li>
<li>健壮、稳定、易用、跨平台、支持多种语言、文档齐全；</li>
<li>有消息确认机制和持久化机制，可靠性高；</li>
<li>高度可定制的路由；</li>
<li>管理界面较丰富，在互联网公司也有较大规模的应用，社区活跃度高。</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>尽管结合 Erlang 语言本身的并发优势，性能较好，但是不利于做二次开发和维护；</li>
<li>实现了代理架构，意味着消息在发送到客户端之前可以在中央节点上排队。此特性使得RabbitMQ易于使用和部署，但是使得其运行速度较慢，因为中央节点 增加了延迟，消息封装后也比较大；需要学习比较复杂的接口和协议，学习和维护成本较高。</li>
</ol>
<h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><p>ActiveMQ是由Apache出品，ActiveMQ是一个完全支持JMS1.1和J2EE 1.4规范的JMS Provider实现。它非常快速，支持多种语言的客户端和协议，而且可以非常容易的嵌入到企业的应用环境中，并有许多高级功能。</p>
<h4 id="主要特性-1"><a href="#主要特性-1" class="headerlink" title="主要特性"></a>主要特性</h4><ol>
<li>服从JMS规范：JMS 规范提供了良好的标准和保证，包括：同步 或 异步 的消息分发，一次和仅一次的消息分发，消息接收和订阅等等。遵从JMS规范的好处在于，不论使用什么JMS实现提供者，这些基础特性都是可用的；</li>
<li>连接灵活性：ActiveMQ提供了广泛的连接协议，支持的协议有：HTTP/S，IP多播，SSL，TCP，UDP等等。对众多协议的支持让ActiveMQ拥有了很好的灵活性；</li>
<li>支持的协议种类多：OpenWire、STOMP、REST、XMPP、AMQP；</li>
<li>持久化插件和安全插件：ActiveMQ提供了多种持久化选择。而且，ActiveMQ的安全性也可以完全依据用户需求进行自定义鉴权和授权；</li>
<li>支持的客户端语言种类多：除了Java之外，还有：C/C++，.NET，Perl，PHP，Python，Ruby；</li>
<li>代理集群：多个ActiveMQ代理可以组成一个集群来提供服务；</li>
<li>异常简单的管理：ActiveMQ是以开发者思维被设计的。所以，它并不需要专门的管理员，因为它提供了简单又使用的管理特性。有很多中方法可以监控ActiveMQ不同层面的数据，包括使用在JConsole或者在ActiveMQ的WebConsole中使用JMX。通过处理JMX的告警消息，通过使用命令行脚本，甚至可以通过监控各种类型的日志。</li>
</ol>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ol>
<li>跨平台(JAVA编写与平台无关，ActiveMQ几乎可以运行在任何的JVM上)；</li>
<li>可以用JDBC：可以将数据持久化到数据库。虽然使用JDBC会降低ActiveMQ的性能，但是数据库一直都是开发人员最熟悉的存储介质；</li>
<li>支持JMS规范：支持JMS规范提供的统一接口;</li>
<li>支持自动重连和错误重试机制；</li>
<li>有安全机制：支持基于shiro，jaas等多种安全配置机制，可以对Queue/Topic进行认证和授权；</li>
<li>监控完善：拥有完善的监控，包括WebConsole，JMX，Shell命令行，Jolokia的RESTful API；</li>
<li>界面友善：提供的WebConsole可以满足大部分情况，还有很多第三方的组件可以使用，比如hawtio；</li>
</ol>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>社区活跃度不及RabbitMQ高；</li>
<li>根据其他用户反馈，会出莫名其妙的问题，会丢失消息；</li>
<li>目前重心放到activemq6.0产品Apollo，对5.x的维护较少；</li>
<li>不适合用于上千个队列的应用场景；</li>
</ol>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>RocketMQ出自阿里的开源产品，用Java语言实现，在设计时参考了Kafka，并做出了自己的一些改进，消息可靠性上比Kafka更好。RocketMQ在阿里内部被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。</p>
<h4 id="主要特性-2"><a href="#主要特性-2" class="headerlink" title="主要特性"></a>主要特性</h4><ol>
<li>基于 队列模型：具有高性能、高可靠、高实时、分布式等特点；</li>
<li>Producer、Consumer、队列都支持分布式；</li>
<li>Producer向一些队列轮流发送消息，队列集合称为Topic。Consumer如果做广播消费，则一个Consumer实例消费这个Topic对应的所有队列；如果做集群消费，则多个Consumer 实例平均消费这个Topic对应的队列集合；</li>
<li>能够保证严格的消息顺序；</li>
<li>提供丰富的消息拉取模式；</li>
<li>高效的订阅者水平扩展能力；</li>
<li>实时的消息订阅机制；</li>
<li>亿级消息堆积 能力；</li>
<li>较少的外部依赖。</li>
</ol>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ol>
<li>单机支持1万以上持久化队列；</li>
<li>RocketMQ的所有消息都是持久化的，先写入系统PAGECACHE，然后刷盘，可以保证内存与磁盘都有一份数据，而访问时，直接从内存读取。</li>
<li>模型简单，接口易用（JMS的接口很多场合并不太实用）；</li>
<li>性能非常好，可以允许大量堆积消息在Broker中；</li>
<li>支持多种消费模式，包括集群消费、广播消费等；</li>
<li>各个环节分布式扩展设计，支持主从和高可用；</li>
<li>开发度较活跃，版本更新很快。</li>
</ol>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>支持的 客户端语言不多，目前是Java及C++，其中C++还不成熟；</li>
<li>RocketMQ社区关注度及成熟度也不及前两者；</li>
<li>没有Web管理界面，提供了一个 CLI (命令行界面) 管理工具带来查询、管理和诊断各种问题；</li>
<li>没有在MQ核心里实现JMS等接口；</li>
</ol>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>Apache Kafka是一个分布式消息发布订阅系统。它最初由LinkedIn公司基于独特的设计实现为一个分布式的日志提交系统(a distributed commit log)，之后成为Apache项目的一部分。Kafka性能高效、可扩展良好并且可持久化。它的分区特性，可复制和可容错都是其不错的特性。</p>
<h4 id="主要特性-3"><a href="#主要特性-3" class="headerlink" title="主要特性"></a>主要特性</h4><ol>
<li>快速持久化：可以在O(1)的系统开销下进行消息持久化；</li>
<li>高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率；</li>
<li>完全的分布式系统：Broker、Producer和Consumer都原生自动支持分布式，自动实现负载均衡；</li>
<li>支持同步和异步复制两种高可用机制；</li>
<li>支持数据批量发送和拉取；</li>
<li>零拷贝技术(zero-copy)：减少IO操作步骤，提高系统吞吐量；</li>
<li>数据迁移、扩容对用户透明；</li>
<li>无需停机即可扩展机器；</li>
<li>其他特性：丰富的消息拉取模型、高效订阅者水平扩展、实时的消息订阅、亿级的消息堆积能力、定期删除机制；</li>
</ol>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ol>
<li>客户端语言丰富：支持Java、.Net、PHP、Ruby、Python、Go等多种语言；</li>
<li>高性能：单机写入TPS约在100万条/秒，消息大小10个字节；</li>
<li>提供完全分布式架构，并有replica机制，拥有较高的可用性和可靠性，理论上支持消息无限堆积；</li>
<li>支持批量操作；</li>
<li>消费者采用Pull方式获取消息。消息有序，通过控制能够保证所有消息被消费且仅被消费一次；</li>
<li>有优秀的第三方KafkaWeb管理界面Kafka-Manager；</li>
<li>在日志领域比较成熟，被多家公司和多个开源项目使用。</li>
</ol>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>Kafka单机超过64个队列/分区时，Load时会发生明显的飙高现象。队列越多，负载越高，发送消息响应时间变长；</li>
<li>使用短轮询方式，实时性取决于轮询间隔时间；</li>
<li>消费失败不支持重试；</li>
<li>支持消息顺序，但是一台代理宕机后，就会产生消息乱序；</li>
<li>社区更新较慢。</li>
</ol>
<p><img src="/2021/03/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/message_queue_03.png" alt="消息中间件对比图"></p>
<blockquote>
<p>笔记来源：</p>
<p><a href="https://www.cnblogs.com/jaycekon/p/6220200.html" target="_blank" rel="noopener">https://www.cnblogs.com/jaycekon/p/6220200.html</a></p>
<p><a href="https://my.oschina.net/blogByRzc/blog/3012251" target="_blank" rel="noopener">https://my.oschina.net/blogByRzc/blog/3012251</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>详解Mysql（二）</title>
    <url>/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="详解Mysql（二）"><a href="#详解Mysql（二）" class="headerlink" title="详解Mysql（二）"></a>详解Mysql（二）</h1><ul>
<li>单库性能优化：硬件优化、Mysql参数优化、Mysql复制原理、经典架构及场景</li>
<li>Mysql高可用</li>
<li>Mysql高扩展</li>
</ul>
<h2 id="单库性能优化"><a href="#单库性能优化" class="headerlink" title="单库性能优化"></a>单库性能优化</h2><p>单库性能优化主要从以下几个方面入手：</p>
<ul>
<li>数据库服务器硬件优化</li>
<li>MYSQL 参数优化</li>
<li>MYSQL 复制</li>
<li>经典架构及应用场景</li>
</ul>
<h3 id="服务器硬件优化"><a href="#服务器硬件优化" class="headerlink" title="服务器硬件优化"></a>服务器硬件优化</h3><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a><strong>CPU</strong></h4><p>MySQL 5.6 版本后多核支持加强，可以支持到 128 核甚至更多。每个连接对应一个线程，每个并发 Query 只能使用一个核，所以要想提升 SQL 执行效率，单个 SQL 执行尽可能快。在考虑 CPU 的时候，我们应该优先选择高主频 CPU 来加速单条 SQL 语句的执行效率。</p>
<p>MySQL 引入了 <strong>Thread Pool</strong> 功能来提升性能。，线程处理的最小单位是 statement（SQL 语句），一个线程可以处理多个连接的请求。这样，在保证充分利用硬件资源情况下（合理设置线程池大小），可以避免瞬间连接数暴增导致的服务器抖动。</p>
<p><strong>优化点：</strong></p>
<ul>
<li>系统配置选择 Performance Per Watt Optimized（DAPC），发挥最大功耗性能，而不是节能模式（高运算节点禁用），节能模式在低高频性能转换时易出现Bug。</li>
<li>CPU优先选择高主频以提高运算能力；其次选择核数多，可以多线程并发处理和多实例部署。</li>
<li>关闭 C1E（增强型空闲电源管理状态转换）和 C states，DB 服务器不需要节能和省电运行，默认是开启状态，DB 服务器建议关闭以提高 CPU 效率。</li>
<li>数据库服务器选择高主频多核数 CPU 类型，同时开启最大性能和关闭 CPU CIE 和 C States。 高频加速 SQL 执行，多核解决并发。</li>
</ul>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a><strong>内存</strong></h4><p>对于数据库服务器而言优先选择大内存，同时开启最大性能并关闭NUMA。</p>
<h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a><strong>磁盘</strong></h4><ul>
<li>RAID 策略选择： Sata SSD、PCIe SSD 无需 RAID，机械硬盘优先选择 RAID10，其次是 RAID5。</li>
<li>RAID CACHE &amp; BBU 选择：购置阵列卡同时配备 CACHE 及 BBU 模块，可提升机械盘 IOPS，定期检查或监控 CACHE 及 BBU 模块的健康状况，确保意外时不至于丢失数据。</li>
<li>磁盘类型选择：优先选择 SSD 或 PCIe SSD，机械盘使用高速硬盘。</li>
<li>读写策略选择：有阵列卡时设置阵列写策略为 WB 或 Force WB with no battery，严禁 WT。同时关闭陈列预读策略，只用作写缓存。</li>
</ul>
<h3 id="MYSQL-参数优化"><a href="#MYSQL-参数优化" class="headerlink" title="MYSQL 参数优化"></a>MYSQL 参数优化</h3><p>分为：</p>
<ul>
<li>系统全局内存参数（<strong>SGA</strong>）</li>
<li>线程全局内存参数（<strong>PGA</strong>）</li>
</ul>
<h4 id="系统全局内存参数（SGA）"><a href="#系统全局内存参数（SGA）" class="headerlink" title="系统全局内存参数（SGA）"></a><strong>系统全局内存参数（SGA）</strong></h4><ul>
<li>innodb_buffer_pool_size ，用于缓存行数据、索引数据，以及事务锁和自适应哈希等。 单机多实例的情况内存建议按实际数据热点数据量的30%规划，单机单实例（独享实例）的情况建议是分配50%～80%。</li>
<li>innodb_buffer_pool_instances，用于提升性能。</li>
<li>innodb_additional_mem_pool_size，用于缓存所有数据字典。</li>
<li>innodb_log_buffer_size ，InnoDB Redo日志缓冲，提高Redo日志写入效率。</li>
<li>key_buffer_size，MyISAM 表索引高速缓冲，提高 MyISAM 表索引读写效率。</li>
<li>query_cache_size，查询缓存，缓存相同SQL查询结果，提高查询结果返回效率，建议禁用。</li>
<li>table_cache &amp;&amp; table_definiton_cache，表空间文件描述符缓存和表定义文件描述符缓存，提供数据表打开效率。</li>
</ul>
<h4 id="线程全局内存参数（PGA）"><a href="#线程全局内存参数（PGA）" class="headerlink" title="线程全局内存参数（PGA）"></a><strong>线程全局内存参数（PGA）</strong></h4><p><img src="/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%BA%8C%EF%BC%89/mysql_11.png" alt="PGA参数"></p>
<h4 id="Log-参数"><a href="#Log-参数" class="headerlink" title="Log 参数"></a><strong>Log 参数</strong></h4><ul>
<li><p>第一个是控制 Redo Log 刷盘策略的 <strong>innodb_flush_log_at_trx_commit</strong>，它有三个取值策略：</p>
<ul>
<li>当取值为 0 ，表示事务提交时，MySQL 不会去处理日志缓存区（Log Buffer）的内容，也不会去处理日志文件的刷盘操作，由 MySQL 的后台 Master 线程每隔 1s 将缓存区的文件刷新到日志文件中。</li>
<li>当取值为 1 ，表示事务提交时，会将日志缓冲区的日志写入文件中，同时会刷新到磁盘中，保证数据库事务完全不会丢失。这种设置影响数据库性能。</li>
<li>当取值为 2，表示事务提交时，会将日志缓存区日志写入到文件中，但是不会刷新到磁盘中。由 MySQL 的后台 Master 线程每隔 1s 将系统缓存的日志文件刷新到磁盘中。</li>
</ul>
</li>
<li><p>第二个参数是控制 Binlog 刷盘策略的 <strong>sync_binlog</strong>，其取值分为 0、1、N（N&gt;1）三类：</p>
<ul>
<li>当取值为 0 时，事务提交时，MySQL 将 Binlog 信息写入 Binlog 文件（OS Cache）中，但是 MySQL不控制 Binlog 的刷磁盘操作，由文件系统自己控制其缓存的刷新。这是最危险的，一旦操作系统宕机，在 Binlog cache 中的所有 Binlog 都会丢失。如果只是数据库宕机，而操作系统未宕机，那么数据库所生成的 Binlog 都不会丢失。</li>
<li>当取值为 1 时，每一个事务提交时，MySQL 都会把 Binlog 刷新到磁盘中。这样，数据库安全性最高，但是性能损耗也是最大的。如果这样设置的话，在数据库或操作系统宕机的情况下，二进制日志中缺少的任何事务也只能处于准备阶段，那么导致服务器自动恢复时，会回滚这些事务，保证无数据丢失。虽然 Binlog 是顺序 IO，但是多个事务同时提交，同样会对 MySQL 和 IO 的性能带来很大影响，不过 MySQL 可以通过 Group Commit 来缓解这种压力。</li>
<li>当取值为 N 时，表示每 N 次事务提交，MySQL 调用文件系统的刷新操作将缓存刷新到磁盘中。如果数据库或操作系统在这个时候宕机，数据库可能会丢失一些事务。</li>
</ul>
</li>
<li><p>innodb_flush_log_at_timeout：每隔 N 秒写入并刷新日志，默认为 1 即每秒 flush一次,可选 [1-2700]。该参数值允许增加 flush 之间的间隔以减少刷新，避免影响二进制日志组提交的性能。</p>
</li>
<li><p>innodb_log_file_size：日志文件大小，建议设置1～2GB。</p>
</li>
<li><p>innodb_log_files_in_group：日志文件组个数。</p>
</li>
</ul>
<h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><p><img src="/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%BA%8C%EF%BC%89/mysql_12.png" alt="Mysql参数"></p>
<p><img src="/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%BA%8C%EF%BC%89/mysql_13.png" alt="Mysql参数"></p>
<h3 id="MYSQL复制"><a href="#MYSQL复制" class="headerlink" title="MYSQL复制"></a>MYSQL复制</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>异步复制<ul>
<li>主从异步复制</li>
<li>半同步复制</li>
</ul>
</li>
<li>同步复制<ul>
<li>Galera Cluster</li>
<li>MySQL Group Replication</li>
</ul>
</li>
</ul>
<h4 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h4><h5 id="主从异步复制"><a href="#主从异步复制" class="headerlink" title="主从异步复制"></a>主从异步复制</h5><p><img src="/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%BA%8C%EF%BC%89/mysql_14.png" alt="MYSQL复制原理图"></p>
<p>涉及三个 Thread</p>
<ul>
<li>Master 的 Binlog Dump Thred</li>
<li>Slave 的 I/O Thread </li>
<li>Slave 的 SQL Thread。</li>
</ul>
<p>数据同步过程：</p>
<ul>
<li>master提交完事务后，写入binlog</li>
<li>slave连接到master，获取binlog</li>
<li>master创建dump线程，推送binglog到slave</li>
<li>slave启动一个IO线程读取同步过来的master的binlog，记录到relay log中继日志中</li>
<li>slave再开启一个sql线程读取relay log事件并在slave执行，完成同步</li>
<li>slave记录自己的binglog</li>
</ul>
<p>以上整个复制过程都是异步操作，所以主从复制俗称<strong>异步复制</strong>，存在数据延迟。</p>
<h5 id="半同步复制（after-commit）"><a href="#半同步复制（after-commit）" class="headerlink" title="半同步复制（after commit）"></a>半同步复制（after commit）</h5><p>考虑到一个场景，主库正常写入数据并提交事务 T1，但是 Slave1 和 Slave2 由于某种原因（例如网络原因）一直无法接受到 Binlog Dump Thread Event 的推送请求，如果这时候 Master Crash，Slave 提升为 Master 后导致事务 T1 数据丢失。为了提升数据安全，MySQL 让 Master 在某一个时间点等待 Slave 节点的 ACK 消息后才进行事务提交，这就是<strong>半同步复制</strong>的基础。</p>
<p><strong>MySQL Master 将事务写入 Binlog（sync_binlog=1）并推送给 Slave 后主库将事务提交到存储引擎（此时未返回客户端但是其他会话可以访问到事务提交信息），Slave  I/O Thread 将读取的 Binlog 写入到本地 relay log 文件（sync_relay=1）后向 Master 返回 ACK 消息，当主库 Master 等到 Slave 返回的 ACK 消息后 Master 将事务提交成功的结果返回给客户端。</strong></p>
<h5 id="增强半同步-after-sync"><a href="#增强半同步-after-sync" class="headerlink" title="增强半同步 after-sync"></a>增强半同步 after-sync</h5><p>为了提升数据的安全性，MySQL 5.7 引入了<strong>增强半同步 after_sync（无损复制）</strong>，并将其设置为默认的半同步方式来解决数据丢失的问题。</p>
<p><strong>after-sync 是将 Master 等待 ACK 消息放到了 存储引擎提交事务之前，这样就可以保证数据不会丢失，因为 Slave 接受到 event 并写入自身 relay log，之后给Master 回复ACK, 这时Master 引擎才会提交事务，然后返回结果给客户端。</strong></p>
<h4 id="同步复制（准同步）"><a href="#同步复制（准同步）" class="headerlink" title="同步复制（准同步）"></a>同步复制（准同步）</h4><h5 id="Galera-Cluster"><a href="#Galera-Cluster" class="headerlink" title="Galera Cluster"></a><strong>Galera Cluster</strong></h5><p><strong>Galera Cluster</strong>是一个强一致性集群，当集群节点有数据写入时，Group communication 会向组内所有成员广播写集（初步可简单理解为写入的Binlog），所有节点验证通过之后写节点开始提交，其他节点执行写集应用和提交，当出现数据冲突时则写节点执行回滚，其他节点丢弃该写集。</p>
<h5 id="MySQL-Group-Replication-组复制"><a href="#MySQL-Group-Replication-组复制" class="headerlink" title="MySQL Group Replication 组复制"></a><strong>MySQL Group Replication</strong> 组复制</h5><p>MySQL 在 5.7 版本参考 Galera Cluster 的技术实现推出了 MySQL Group Replication（简称 <strong>MGR</strong>）。</p>
<p>MGR 同样是一个<strong>支持多点写入的多主复制架构</strong>，它<strong>基于原生 MySQL 主从复制的基础上</strong>构建组通信层，由 Group Replication 提供一组原子消息并且按照全局顺序进行消息传递，集群任何节点均可写入，但所有写入事务只有在获得<strong>复制组认证</strong>通过（多数派协议 Paxos）后才能进行提交。例如由若干个节点共同组成一个复制组，一个事务的提交必须经过组内大多数节点（N / 2 + 1）决议并通过，才能得以提交。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><strong>主从复制</strong>：通常适合于轻量级程序、高可用要求不高的业务场景。这类架构中应用程序直连访问 Master 和 Slave 进行读写分离，当 Master 出现故障时由于无法自动切换导致服务受损。因此通常会基于此架构加上 VIP/DNS + Keepalived 及双主复制来做一个简单的高可用切换。</li>
<li><strong>双主复制</strong>：通常为其中一个 Master 提供线上服务，另一个 Master 作为 Standby 供高可用切换（这里的原理为互为主从，通过<strong>keepalived</strong>监控主库状态，做故障切换），Master 下游挂载 Slave 承担读请求。</li>
<li><strong>树形复制</strong>：这类架构通常适用于数据访问策略分层，例如 MySQL Master 和 MySQL Slave 参与线上业务访问及高可用切换，MySQL Statistic 节点提供离线查询、报表慢查和非线上业务访问。</li>
</ul>
<h3 id="海量数据架构设计"><a href="#海量数据架构设计" class="headerlink" title="海量数据架构设计"></a>海量数据架构设计</h3><h4 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h4><ul>
<li><strong>响应时间</strong>：系统对请求做出响应的时间，一般取平均响应时间。</li>
<li><strong>吞吐量</strong>：单位时间内处理的请求数量。</li>
<li><strong>QPS</strong>：每秒处理的查询次数。</li>
<li><strong>TPS</strong>：每秒处理的事务数。</li>
<li><strong>并发用户数</strong>：同时承载正常使用系统功能的用户数量。</li>
</ul>
<p><strong>基本方法：</strong></p>
<ul>
<li>垂直扩展</li>
<li>水平扩展</li>
<li>分布式</li>
</ul>
<h4 id="垂直扩展-Scale-Up"><a href="#垂直扩展-Scale-Up" class="headerlink" title="垂直扩展 Scale-Up"></a>垂直扩展 Scale-Up</h4><p>纵向扩展：也叫垂直扩展，扩展一个点的能力以支撑更多的请求。</p>
<p>主要分为一下4个方向：</p>
<ul>
<li>增强单机硬件性能：CPU、内存、硬盘、网络等</li>
<li>提升单机架构性能：例如增加缓存、增加队列</li>
<li>无锁数据结构：例如业务解耦</li>
<li>分区：分区是指按照一定的规则，把数据库中的一个表分解成多个更小的、更容易管理的部分，分区有利于管理非常大的表。<ul>
<li>分区可以把数据打散存储到不同的文件系统上，和单个磁盘或者文件系统相比，可以存储更多的数据。</li>
<li>优化查询。where 子句包含分区条件时，可以只扫描对应分区，缩小了查询范围。</li>
<li>同时在涉及 count() 和 sum() 等聚合函数时，可以在多个分区上并行处理。</li>
<li>对于已经过期或不需要的数据，可以通过删除分区快速删除。跨多个磁盘来分散数据查询，以获得更大的查询吞吐量。</li>
</ul>
</li>
</ul>
<p>关于分区的问题：</p>
<ul>
<li>一个表最多只能有 1024 个分区，MySQL 5.6 之后支持 8192 个分区。</li>
<li>如果分区字段中有主键或者唯一索引列，那么所有主键列和唯一索引列都必须包含进来，如果表中有主键或唯一索引，那么分区键必须是主键或唯一索引。</li>
<li>MySQL 分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对一个表的部分数据进行分区。</li>
<li>无论使用何种分区类型，不能使用主键/唯一键之外的其他字段进行分区。</li>
<li>分区表中无法使用外键约束。</li>
<li>MySQL 数据库支持的分区类型为水平分区，并不支持垂直分区，因此，MySQL 数据库的分区中索引是局部分区索引，一个分区中既存放了数据又存放了索引，而全局分区是指数据库放在各个分区中，但是所有的数据的索引放在另外一个对象中。</li>
<li>目前 MySQL 不支持对空间类型和临时表类型进行分区。不支持全文索引。</li>
</ul>
<h4 id="水平扩展-Scale-Out"><a href="#水平扩展-Scale-Out" class="headerlink" title="水平扩展 Scale-Out"></a>水平扩展 Scale-Out</h4><p>横向扩展：也叫水平扩展，用更多的节点支撑更大量的请求，达到线性扩充系统的能力。</p>
<ul>
<li><p>主从复制。通过主从复制来扩展从库，从而提升读性能。</p>
</li>
<li><p>分库分表。这个又可以称之为 “ 数据分片（Sharding）”</p>
</li>
<li><p>数据库中间件。例如：使用中间件来达到读写分离的目的。</p>
</li>
<li><p>集群。例如：使用 PXC 或者 MGR 集群来弥补单机性能的不足。</p>
</li>
</ul>
<h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>分布式关系型数据库发展到今天，主要分为两个阵营：</p>
<ul>
<li>基于分布式事务的数据库，以 Google Cloud Spanner 和 PingCAP 的 TiDB 为代表。</li>
<li>基于分布式存储的数据库，以 AWS 的 Aurora 和极数云舟的 ArkDB 为代表。</li>
</ul>
<h4 id="常用数据库架构方案对比"><a href="#常用数据库架构方案对比" class="headerlink" title="常用数据库架构方案对比"></a>常用数据库架构方案对比</h4><p><img src="/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%BA%8C%EF%BC%89/mysql_15.png" alt="常用数据库架构方案对比"></p>
<blockquote>
<p>笔记来源：</p>
<p>周彦伟 老师的 《高性能Mysql实战》课程</p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>Mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>详解Mysql（一）</title>
    <url>/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="详解Mysql（一）"><a href="#详解Mysql（一）" class="headerlink" title="详解Mysql（一）"></a>详解Mysql（一）</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Mysql 是一个优秀的开源关系型数据库，目前已成为一线互联网公司通用数据库。</p>
<p><img src="/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%B8%80%EF%BC%89/mysql_01.png" alt="Mysql演变图"></p>
<p>MySQL 从最初的 1.0、3.1 到后来的 5.0，发生了各种各样的变化。被 Oracle 收购后，MySQL 的版本其实主要有几个分支，除了需要付费的 MySQL 企业版本，还有很多 MySQL 社区版本。</p>
<p>目前主流分支已经更新到8.0 的 MySQL 官方版本。</p>
<p>Percona Server 是 MySQL 的技术支持公司 Percona 推出的非常流行的开源分支版本，其在官方版本的基础上做了一些补丁和优化，同时推出了一些工具。</p>
<p>MariaDB 也是 Mysql的一个分支。</p>
<p>本课学习版本为 mysql 5.7</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>体积小、速度快，可以在不占用太多资源的情况下提供数据库服务；</li>
<li>开源免费，工具生态完善，用起来没有经济门槛；</li>
<li>简单易用，维护成本低，用起来没有技术门槛；</li>
<li>兼容性好，支持多种操作系统，用起来没有平台门槛；</li>
<li>提供多种 API 接口；支持多种开发语言，用起来没有编程语言门槛；</li>
<li>社区及用户活跃，用起来没有技术支持门槛；</li>
<li>MySQL 支持事务、MVCC、4 种隔离级别等，同时易扩展、集群、高可用等也可以满足一般需求。</li>
</ul>
<h3 id="体系结构与存储引擎"><a href="#体系结构与存储引擎" class="headerlink" title="体系结构与存储引擎"></a>体系结构与存储引擎</h3><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><img src="/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%B8%80%EF%BC%89/mysql_02.png" alt="Mysql体系结构" style="zoom:57%;">

<p><strong>MySQL</strong> 体系结构由 <strong>Client Connectors 层</strong>、<strong>MySQL Server 层</strong>及<strong>存储引擎层</strong>、<strong>物理存储层</strong>四个部分组成。</p>
<ul>
<li><p><strong>Client Connectors层</strong></p>
<p>负责处理客户端的连接请求，与客户端创建连接。目前 MySQL 几乎支持所有的连接类型，例如常见的 JDBC、Python、Go 等。</p>
</li>
<li><p><strong>MySQL Server 层</strong></p>
<p><strong>MySQL Server</strong> 层主要包括 <strong>Connection Pool、Service &amp; utilities、SQL interface、Parser解析器、Optimizer 查询优化器、Caches 缓存等模块</strong>。</p>
<ul>
<li><strong>Connection Pool</strong>：负责处理和存储数据库与客户端创建的连接，一个线程负责管理一个连接。Connection Pool 包括了用户认证模块，就是用户登录身份的认证和鉴权及安全管理，也就是用户执行操作权限校验。</li>
<li><strong>Service &amp; utilities</strong>：是管理服务&amp;工具集，包括备份恢复、安全管理、集群管理服务和工具。</li>
<li><strong>SQL interface</strong>：负责接收客户端发送的各种 SQL 语句，比如 DML、DDL 和存储过程等。</li>
<li><strong>Parser 解析器</strong>：对 SQL 语句进行语法解析生成解析树。</li>
<li><strong>Optimizer 查询优化器</strong>：根据解析树生成执行计划，并选择合适的索引，然后按照执行计划执行 SQL 语言并与各个存储引擎交互。</li>
<li><strong>Caches 缓存</strong>：包括各个存储引擎的缓存部分，比如：InnoDB 存储的 Buffer Pool、MyISAM 存储引擎的 key buffer 等，Caches 中也会缓存一些权限，也包括一些 Session 级别的缓存。</li>
</ul>
</li>
<li><p><strong>存储引擎层</strong></p>
<p>存储引擎包括 <strong>MyISAM</strong>、<strong>InnoDB</strong>，以及支持归档的 Archive 和内存的 Memory 等。MySQL是<strong>插件式的存储引擎</strong>，只要正确定义与 MySQL Server 交互的接口，任何引擎都可以访问MySQL。</p>
</li>
<li><p><strong>物理层存储层</strong></p>
<p>文件的物理存储层，包括二进制日志、数据文件、错误日志、慢查询日志、全日志、redo/undo 日志等。</p>
</li>
</ul>
<h4 id="查询交互过程"><a href="#查询交互过程" class="headerlink" title="查询交互过程"></a>查询交互过程</h4><p>我们用一条 SQL SELECT 语句的执行轨迹来说明客户端与 MySQL 的交互过程</p>
<img src="/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%B8%80%EF%BC%89/mysql_03.png" alt="Mysql交互过程" style="zoom:67%;">

<p>① 通过客户端/服务器通信协议与 MySQL <strong>建立连接</strong>。</p>
<p>② <strong>查询缓存</strong>，这是 MySQL 的一个可优化查询的地方，如果开启了 Query Cache 且在查询缓存过程中查询到完全相同的 SQL 语句，则将查询结果直接返回给客户端；如果没有开启Query Cache 或者没有查询到完全相同的 SQL 语句则会由解析器进行语法语义解析，并生成解析树。</p>
<p>③ 预处理器<strong>生成新的解析树</strong>。</p>
<p>④ 查询优化器<strong>生成执行计划</strong>。</p>
<p>⑤ 查询执行引擎执行 SQL 语句，此时查询执行引擎会根据 SQL 语句中表的存储引擎类型，以及对应的 API 接口与底层存储引擎缓存或者物理文件的交互情况，<strong>得到查询结果</strong>，由MySQL Server 过滤后将查询结果缓存并返回给客户端。若开启了 Query Cache，这时也会将SQL 语句和结果完整地保存到 Query Cache 中，以后若有相同的 SQL 语句执行则直接返回结果。</p>
<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>存储引擎是 MySQL 中具体与文件打交道的子系统，它是根据 MySQL AB 公司提供的<strong>文件访问层抽象接口定制的一种文件访问机制</strong>，这种机制就叫作<strong>存储引擎</strong>。</p>
<p>前面说到Mysql 是插件式的存储引擎，只要正确定义与 MySQL Server 交互的接口，任何引擎都可以访问MySQL。所以Mysql支持很多种存储引擎，常用的为 MyISAM、支持事务的 InnoDB、内存类型的 Memory、归档类型的 Archive、列式存储的 Infobright，以及一些新兴的存储引擎等。</p>
<p><strong>在 MySQL 5.6 版本之前，默认的存储引擎都是 MyISAM，但 5.6 版本以后默认的存储引擎就是 InnoDB 了。</strong></p>
<p>我们主要<strong>对比</strong> 这俩种存储引擎的功能。</p>
<img src="/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%B8%80%EF%BC%89/mysql_05.png" alt="InnoDB和MyISAM对比" style="zoom:67%;">

<blockquote>
<p>图片来自网络</p>
</blockquote>
<ul>
<li>InnoDB 支持 ACID 的事务 4 个特性，而 MyISAM 不支持；</li>
<li>InnoDB 支持 4 种事务隔离级别，默认是可重复读 Repeatable Read 的，MyISAM 不支持；</li>
<li>InnoDB 支持 crash 安全恢复，MyISAM 不支持；InnoDB 支持外键，MyISAM 不支持；</li>
<li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度；</li>
<li>InnoDB 支持 MVCC，MyISAM 不支持；</li>
<li>InnoDB 表最大还可以支持 64TB，支持聚簇索引、支持压缩数据存储，支持数据加密，支持查询/索引/数据高速缓存，支持自适应hash索引、空间索引，支持热备份和恢复等</li>
</ul>
<p><strong>如何选择？</strong></p>
<p>需要事务操作，选InnoDB；</p>
<p>如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果有读，写也挺频繁，请使用InnoDB。</p>
<p>MyISAM适合：(1) 做很多count 的计算；(2) 插入不频繁，查询非常频繁；(3) 没有事务。</p>
<p>InnoDB适合：(1) 可靠性要求比较高，或者要求事务；(2) 表更新和查询都相当的频繁，并且行锁定的机会比较大的情况。</p>
<h3 id="知识点扫盲"><a href="#知识点扫盲" class="headerlink" title="知识点扫盲"></a>知识点扫盲</h3><h4 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h4><p><strong>范式</strong>是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法。数据库的设计范式是数据库设计所需要满足的规范。只有理解数据库的设计范式，才能设计出高效率、优雅的数据库。</p>
<p>目前关系数据库有<strong>六种范式</strong>：<strong>第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）和第五范式（5NF，还又称完美范式）</strong>。</p>
<p>满足最低要求的叫第一范式，简称 1NF。在第一范式基础上进一步满足一些要求的为第二范式，简称 2NF。其余依此类推。各种<strong>范式呈递次规范</strong>，越高的范式数据库冗余越小。通常所用到的只是前三个范式，即：第一范式（1NF），第二范式（2NF），第三范式（3NF）。</p>
<p><strong>第一范式</strong></p>
<p>第一范式无重复的列，表中的每一列都是拆分的基本数据项，即<strong>列不能够再拆分成其他几列</strong>，强调的是列的原子性.。</p>
<p><strong>第二范式</strong></p>
<p>第二范式属性完全依赖于主键，首先要满足它符合 1NF，另外还需要包含两部分内容：</p>
<ul>
<li>表必须有一个主键；</li>
<li>没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。</li>
</ul>
<p><strong>第三范式</strong></p>
<p>第三范式属性不传递依赖于其他非主属性，首先需要满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</p>
<p>第二范式：非主键列是否依赖主键（包括一列通过某一列间接依赖主键），要是有依赖关系就是第二范式；</p>
<p>第三范式：非主键列是否直接依赖主键，不能是那种通过传递关系的依赖。要是符合这种依赖关系就是第三范式。</p>
<p><strong>优缺点</strong></p>
<p>优点：</p>
<ul>
<li>避免数据冗余，减少维护数据完整性的麻烦；</li>
<li>减少数据库的空间；数据变更速度快。</li>
</ul>
<p>缺点：</p>
<p>按照范式的规范设计的表，等级越高的范式设计出来的表数量越多。获取数据时，表关联过多，性能较差。表的数量越多，查询所需要的时间越多。也就是说所用的范式越高，对数据操作的性能越低。</p>
<p><strong>反范式</strong></p>
<p>范式是普适的规则，满足大多数的业务场景的需求。对于一些特殊的业务场景，范式设计的表，无法满足性能的需求。此时，就需要根据业务场景，在范式的基础之上进行灵活设计，也就是<strong>反范式设计</strong>。</p>
<p>反范式设计主要从三方面考虑：<strong>业务场景；相应时间；字段冗余</strong>。</p>
<p>反范式设计就是用空间来换取时间，提高业务场景的响应时间，减少多表关联。</p>
<h4 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h4><p><strong>ARIES 三原则</strong>，是指 <strong>Write Ahead Logging</strong>（WAL）。</p>
<ul>
<li><p>先写日志后写磁盘，日志成功写入后事务就不会丢失，后续由 checkpoint 机制来保证磁盘物理文件与 Redo 日志达到一致性；</p>
</li>
<li><p>利用 Redo 记录变更后的数据，即 Redo 记录事务数据变更后的值；</p>
</li>
<li><p>利用 Undo 记录变更前的数据，即 Undo 记录事务数据变更前的值，用于回滚和其他事务多版本读。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql &gt;show engine innodb status\G;</span><br></pre></td></tr></table></figure>

<p>该命令的结果里面有详细的 InnoDB 运行态信息，分段记录的，包括内存、线程、信号、锁、事务等，出现问题时从中能分析出具体原因和解决方案。</p>
<h4 id="★-单版本控制-锁"><a href="#★-单版本控制-锁" class="headerlink" title="★     单版本控制 - 锁"></a>★     单版本控制 - 锁</h4><p><strong>锁</strong>用独占的方式来保证在只有一个版本的情况下事务之间相互隔离，所以锁可以理解为单版本控制。</p>
<p>在 MySQL 事务中，锁的实现与隔离级别有关系，在 RR（Repeatable Read）隔离级别下，MySQL 为<strong>了解决幻读的问题，以牺牲并行度为代价，通过 Gap 锁（间隙锁）来防止数据的写入</strong>，而这种锁，因为其并行度不够，冲突很多，经常会引起死锁。现在流行的 Row 模式可以避免很多冲突甚至死锁问题，所以推荐默认使用 Row + RC（Read Committed）模式的隔离级别，可以很大程度上提高数据库的读写并行度。</p>
<p><strong>间隙锁</strong>，即对于不在区间范围内的数据也加锁，例如满足某一条数据的条数是100条，哪些满足条件，但是不存在的数据称为<strong>间隙</strong>，对其加锁叫<strong>间隙锁</strong>，用于防止事务区间内，其他事务插入数据，造成幻读。</p>
<p><strong>共享锁与排他锁</strong></p>
<ul>
<li>共享锁（读锁）：其他事务可以读，但不能写。</li>
<li>排他锁（写锁） ：其他事务不能读取，也不能写。</li>
</ul>
<p><strong>粒度锁</strong></p>
<ul>
<li><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
<ul>
<li><p>这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。</p>
</li>
<li><p>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用</p>
</li>
</ul>
</li>
<li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<ul>
<li>最大程度的支持并发，同时也带来了最大的锁开销。</li>
<li>在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li>
<li>行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</li>
</ul>
</li>
<li><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>
</li>
</ul>
<p><strong>Mysql 中锁粒度对比</strong></p>
<ul>
<li><p>MyISAM 和 MEMORY 存储引擎采用的是<strong>表级锁</strong>（table-level locking）；</p>
</li>
<li><p>BDB 存储引擎采用的是<strong>页面锁</strong>（page-level locking），但也支持表级锁；</p>
</li>
<li><p>InnoDB 存储引擎既支持<strong>行级锁</strong>（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</p>
</li>
</ul>
<p><strong>默认情况下，表锁和行锁都是自动获得的</strong>， 不需要额外的命令。</p>
<p>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p>
<p><strong>InnoDB 引擎中的锁实现</strong></p>
<p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p>
<ul>
<li><strong>共享锁</strong>（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li><strong>排他锁</strong>（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li>
</ul>
<p>为了允许<strong>行锁和表锁共存</strong>，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p>
<ul>
<li><strong>意向共享锁</strong>（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>
<li><strong>意向排他锁</strong>（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>
</ul>
<p><strong>InnoDB加锁方法：</strong></p>
<ul>
<li><p><strong>意向锁</strong>是 InnoDB 自动加的， 不需用户干预。</p>
</li>
<li><p>对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB会自动给涉及数据集加<strong>排他锁</strong>（X)；</p>
</li>
<li><p>对于普通 SELECT 语句，InnoDB 不会加任何锁；事务可以通过以下语句显式给记录集加共享锁或排他锁：</p>
</li>
<li><ul>
<li>共享锁（S）：SELECT * FROM table_name WHERE … <strong>LOCK IN SHARE MODE</strong>。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>排他锁（X)：SELECT * FROM table_name WHERE … <strong>FOR UPDATE</strong>。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li>
</ul>
</li>
</ul>
<p><strong>InnoDB 行锁实现方式：</strong></p>
<ul>
<li>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</li>
<li>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。</li>
<li>只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。</li>
<li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。</li>
</ul>
<p><strong>死锁（Deadlock Free）</strong></p>
<ul>
<li><p><strong>死锁产生：</strong></p>
</li>
<li><ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</li>
<li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。</li>
<li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li>
</ul>
</li>
<li><p><strong>检测死锁：</strong>数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p>
</li>
<li><p><strong>死锁恢复：</strong>死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p>
</li>
<li><p><strong>外部锁的死锁检测：</strong>发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 <strong>innodb_lock_wait_timeout</strong> 来解决</p>
</li>
<li><p><strong>死锁影响性能：</strong>死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。</p>
</li>
</ul>
<p><strong>优化锁性能的建议</strong></p>
<ul>
<li>尽量使用较低的隔离级别；</li>
<li>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会</li>
<li>选择合理的事务大小，小事务发生锁冲突的几率也更小</li>
<li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁</li>
<li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会</li>
<li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</li>
<li>不要申请超过实际需要的锁级别。</li>
<li>除非必须，查询时不要显示加锁。 MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能；MVCC只在COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</li>
<li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li>
</ul>
<p><strong>乐观锁、悲观锁</strong></p>
<ul>
<li><p><strong>乐观锁(Optimistic Lock)</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。</p>
</li>
<li><p><strong>悲观锁(Pessimistic Lock)</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<p>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
</li>
</ul>
<h4 id="多版本控制-MVVC"><a href="#多版本控制-MVVC" class="headerlink" title="多版本控制 - MVVC"></a>多版本控制 - MVVC</h4><p><strong>MVCC (Multi-Version Concurrency Control)</strong>是一种基于多版本的<strong>并发控制协议</strong>，只有在<strong>InnoDB</strong>引擎下存在。MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，你可以把它当成基于多版本号的一种乐观锁。MVCC最大的好处就是：<strong>读不加锁，读写不冲突</strong>。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。</p>
<p><strong>注意</strong>：MVCC 只在 <strong>读提交（RC，Read Committed）</strong> 和 <strong>可重复读（RR，Repeatable Read）</strong> 两种隔离级别下工作。</p>
<p><strong>实现机制</strong></p>
<p><strong>InnoDB</strong>在每行数据都增加两个隐藏字段，一个记录<strong>创建的版本号</strong>，一个记录<strong>删除的版本号</strong>。</p>
<p>简单来说,是通过在每行记录后面保存<strong>两个隐藏的列</strong>来实现的,这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID.</p>
<ul>
<li>InnoDB只会查找版本早于当前事务版本的数据行(也就是,行的系统版本号小于或等于事务的系统版本号)，<strong>这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的.</strong></li>
<li>行的删除版本要么未定义,要么大于当前事务版本号,<strong>这可以确保事务读取到的行，在事务开始之前未被删除.</strong></li>
</ul>
<p>在多版本并发控制中，为了保证数据操作在多线程过程中，保证事务隔离的机制，降低锁竞争的压力，保证较高的并发量。在每开启一个事务时，会生成一个事务的版本号，被操作的数据会生成一条新的数据行（临时），但是在提交前对其他事务是不可见的，对于数据的更新（包括增删改）操作成功，会将这个版本号更新到数据的行中，事务提交成功，将新的版本号更新到此数据行中，这样保证了每个事务操作的数据，都是互不影响的，也不存在锁的问题。</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p><strong>事务</strong>是指作为单个逻辑工作单元执行的一系列操作，这些操作要么全做，要么全不做，是一个不可分割的工作单元。</p>
<p>一个逻辑工作单元要成为事务，在关系型数据库管理系统中，必须满足 4 个特性，即所谓的 <strong>ACID</strong>：</p>
<ul>
<li><strong>一致性</strong>：事务开始之前和事务结束之后，数据库的完整性限制未被破坏。</li>
<li><strong>原子性</strong>：事务的所有操作，要么全部完成，要么全部不完成，不会结束在某个中间环节。</li>
<li><strong>持久性</strong>：事务完成之后，事务所做的修改进行持久化保存，不会丢失。</li>
<li><strong>隔离性</strong>：当多个事务并发访问数据库中的同一数据时，所表现出来的相互关系。</li>
</ul>
<p>ACID 及它们之间的关系如下图所示，比如 4 个特性中有 3 个与 WAL 有关系，都需要通过 Redo、Undo 日志来保证等。</p>
<img src="/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%B8%80%EF%BC%89/mysql_06.png" alt="ACID关系" style="zoom:75%;">

<p><strong>原子性</strong></p>
<p><strong>MySQL</strong> 是通过 <strong>WAL</strong>（Write Ahead Log）技术来实现。</p>
<p>每一个写事务，都会修改 Buffer Pool，从而产生相应的 Redo 日志，这些日志信息会被记录到 ib_logfiles 文件中。因为 Redo 日志是遵循 Write Ahead Log 的方式写的，所以事务是顺序被记录的。</p>
<p>任何 Buffer Pool 中的页被刷到磁盘之前，都会先写入到日志文件中。</p>
<ul>
<li>如果事务提交了，Buffer Pool 的脏页没有刷盘（刷到磁盘），如何保证改了的数据生效？可使用 Redo 日志恢复出来的数据。</li>
<li>如果事务没有提交，且 Buffer Pool 的脏页被刷盘了，那这个本不应该存在的数据如何消失？需要通过 Undo 来实现，Undo 又是通过 Redo 来保证的，所以最终原子性的保证还是靠 Redo 的 WAL 机制实现的。</li>
</ul>
<p><strong>持久性</strong></p>
<p>是指一个事务一旦提交，它对数据库中数据的改变就应该是永久性。</p>
<p>通过原子性可以保证逻辑上的持久性，通过存储引擎的数据刷盘可以保证物理上的持久性。</p>
<p><strong>隔离性</strong></p>
<p>指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并发事务是隔离的。</p>
<p><strong>InnoDB</strong> 支持的隔离性有 4 种，隔离性从低到高分别为：<strong>读未提交、读提交、可重复读、可串行化</strong>。</p>
<ul>
<li><strong>读未提交</strong>（RU，Read Uncommitted）。它能读到一个事务的中间过程，违背了 ACID 特性，存在脏读的问题，所以基本不会用到，可以忽略。</li>
<li><strong>读提交</strong>（RC，Read Committed）。它表示如果其他事务已经提交，那么我们就可以看到，这也是一种最普遍适用的级别。但由于一些历史原因，可能 RC 在生产环境中用的并不多。</li>
<li><strong>可重复读</strong>（RR，Repeatable Read），是目前被使用得最多的一种级别。其特点是有 Gap 锁、目前还是默认的级别、在这种级别下会经常发生死锁、低并发等问题。</li>
<li><strong>可串行化</strong>，这种实现方式，其实已经并不是多版本了，又回到了单版本的状态，因为它所有的实现都是通过锁来实现的。</li>
</ul>
<p><strong>一致性</strong></p>
<ul>
<li><strong>约束一致性</strong>：创建表结构时所指定的外键、Check（Mysql不支持）、唯一索引等约束。</li>
<li><strong>数据一致性</strong>：由原子性、持久性、隔离性共同保证。</li>
</ul>
<h4 id="并发事务问题及解决方案"><a href="#并发事务问题及解决方案" class="headerlink" title="并发事务问题及解决方案"></a><strong>并发事务问题及解决方案</strong></h4><p>前面说过通过<strong>单版本控制-锁</strong>以及<strong>多版本控制-MVVC</strong>实现并发事务，同时并发事务处理也会带来一些问题，如：<strong>脏读、不可重复读、幻读。</strong></p>
<ul>
<li><strong>脏读</strong>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫作”脏读”（Dirty Reads）。</li>
<li><strong>不可重复读</strong>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫作“ 不可重复读”（Non-Repeatable Reads）。</li>
<li><strong>幻读</strong>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”（Phantom Reads）。</li>
</ul>
<p>MySQL 数据库是通过<strong>事务隔离级别</strong>来解决上述问题的：</p>
<img src="/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%B8%80%EF%BC%89/mysql_07.png" alt="事务隔离级别解决并发事务问题" style="zoom:67%;">



<h3 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h3><p><strong>基本使用原则：</strong></p>
<ul>
<li>MySQL 数据库只用于数据的存储，不进行数据的复杂计算，不承载业务逻辑，确保存储和计算分离；</li>
<li>查询数据时，尽量单表查询，减少跨库查询和多表关联；</li>
<li>杜绝大事务、大 SQL、大批量、大字段等一系列性能杀手。<ul>
<li>大事务，运行步骤较多，涉及的表和字段较多，容易造成资源的争抢，甚至形成死锁。一旦事务回滚，会导致资源占用时间过长。</li>
<li>大 SQL，复杂的 SQL 意味着过多的表的关联，MySQL 数据库处理关联超过 3 张表以上的 SQL 时，占用资源多，性能低下。</li>
<li>大批量，意味着多条 SQL 一次性执行完成，必须确保进行充分的测试，并且在业务低峰时段或者非业务时段执行。大字段，blob、text 等大字段，尽量少用。必须要用时，尽量与主业务表分离，减少对这类字段的检索和更新。</li>
</ul>
</li>
</ul>
<p><strong>基础规范：</strong></p>
<ul>
<li>必须指定默认存储引擎为 InnoDB，并且禁用 MyISAM 存储引擎。</li>
<li>默认字符集 <code>UTF8mb4</code>，以前版本的 UTF8 是 <code>UTF8mb3</code>，未包含个别特殊字符，新版本的 UTF8mb4 包含所有字符，官方强烈建议使用此字符集。</li>
<li>关闭区分大小写功能。设置<code>lower_case_tables_name=1</code>，即可关闭区分大小写功能，即大写字母 T 和小写字母 t 一样。</li>
<li>存储过程、触发器、视图、event。为了存储计算分离，这类功能尽量在程序中实现。这些功能非常不完整，调试、排错、监控都非常困难，相关数据字典也不完善，存在潜在的风险。一般在生产数据库中，禁止使用。</li>
<li>lob、text、enum、set。这些字段类型，在 MySQL 数据库的检索性能不高，很难使用索引进行优化。如果必须使用这些功能，一般采取特殊的结构设计，或者与程序结合使用其他的字段类型替代。比如：set 可以使用整型（0，1，2，3）、注释功能和程序的检查功能集合替代。</li>
</ul>
<p><strong>命名规范：</strong></p>
<ul>
<li>命名时的字符取值范围为：<code>a~z</code>，<code>0~9</code>和<code>_（下画线）</code></li>
<li>所有表名小写，不允许驼峰式命名；</li>
<li>允许使用 <code>-（横线）</code>和 <code>（空格）</code>；不允许使用其他特殊字符作为名称，减少潜在风险。</li>
<li>数据库库名的命名规则必须遵循“见名知意”的原则，即库名规则为<code>数据库类型代码 + 项目简称 + 识别代码 + 序号</code>。只有一个数据库，则不加序号，否则末尾增加序号；生产库不加识别代码，否则需要增加识别代码 DEV 或 TEST；如果只作历史库，则只需要<code>项目简称 + H + 序号</code>；</li>
<li>单表仅使用 <code>a~z、_</code>；分表名称为<code>表名_编号</code>；</li>
<li>业务表名代表用途、内容：子系统简称_业务含义_后缀。常见业务表类型有：临时表，<code>tmp</code>；备份表，<code>bak</code>；字典表，<code>dic</code>；日志表，<code>log</code>。</li>
<li>字段名精确，遵循“见名知意”的原则，格式：<code>名称_后缀</code>。避免普遍简单、有歧义的名称。用户表中，用户名的字段为 UserName 比 Name 更好。布尔型的字段，以助动词<code>（has/is）</code>开头。用户是否有留言 hasmessage，用户是否通过检查 ischecked 等。</li>
<li>常见后缀：流水号/无意义主键，后缀为 id，比如 task_id；时间，后缀为 time，insert_time。程序账号与数据库名称保持一致。如果所有的程序账号都是 root@‘%’，密码也一样，很容易错连到其他的数据库，造成误操作。</li>
<li>索引命名格式：主要为了区分哪些对象是索引：<code>前缀_表名（或缩写）_字段名（或缩写）</code>；主键必须使用前缀<code>pk_</code>；UNIQUE 约束必须使用前缀<code>uk_</code>；普通索引必须使用前缀<code>idx_</code>。</li>
<li>创建表时显示指定<code>字符集、存储引擎、注释信息</code>等。  不同系统之间，统一规范；不同表之间的相同字段或者关联字段，字段类型/命名要保持一致；库表字符集和前端程序、中间件必须保持一致的 <code>UTF8mb4</code>。</li>
<li>InnoDB表的注意事项：<ul>
<li>主键列，UNSIGNED 整数，使用 auto_increment；禁止手动更新 auto_increment，可以删除。</li>
<li>必须添加 comment 注释。</li>
<li>必须显示指定的 engine。</li>
<li>表必备三字段：id、 xxx_create、 xxx_modified。id 为主键，类型为 unsigned bigint 等数字类型；xxx_create、xxx_modified 的类型均为 datetime 类型，分别记录该条数据的创建时间、修改时间。</li>
</ul>
</li>
</ul>
<p><strong>不同类型表设计规范：</strong></p>
<ul>
<li>备份表，表名必须添加 bak 和日期，主要用于系统版本上线时，存储原始数据，上线完成后，必须及时删除。</li>
<li>临时表，用于存储中间业务数据，定期优化，及时降低表碎片。</li>
<li>日志类表，首先考虑不入库，保存成文件，其次如果入库，明确其生命周期，保留业务需求的数据，定期清理。</li>
<li>大字段表，把主键字段和大字段，单独拆分成表，并且保持与主表主键同步，尽量减少大字段的检索和更新。</li>
<li>大表，根据业务需求，从垂直和水平两个维度进行拆分。<ul>
<li>垂直拆分：按列关联度。</li>
<li>水平拆分：按照时间、地域、范围等；冷热数据（历史数据归档）。</li>
</ul>
</li>
</ul>
<p><strong>字段设计要求：</strong></p>
<ul>
<li>根据业务场景需求，选择合适的类型，最短的长度；确保字段的宽度足够用，但也不要过宽。</li>
<li>尽量所有字段必须为 NOT NULL，空值则指定 default 值，空值难以优化，查询效率低。</li>
<li>表字段数少而精，尽量不加冗余列。</li>
<li>单实例表个数必须控制在 2000 个以内。</li>
<li>单表分表个数必须控制在 1024 个以内。</li>
<li>单表字段数上限控制在 20~50 个。</li>
<li>禁用 ENUM、SET 类型。兼容性不好，性能差。解决方案：使用 TINYINT，在 COMMENT 信息中标明被枚举的含义。<code>is_disable</code> TINYINT UNSIGNED DEFAULT ‘0’ COMMENT ‘0:启用 1:禁用 2:异常’。</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>数据库索引是一种数据结构，它以额外的写入和存储空间为代价来提高数据库表上数据检索操作的速度。</p>
<p>MySQL 官方对索引（Index）的定义是存储引擎用于快速查找记录的一种数据结构。</p>
<p>索引是物理数据页，数据库页大小（Page Size）决定了一个页可以存储多少个索引行，以及需要多少页来存储指定大小的索引。</p>
<p>索引可以加快检索速度，但同时也降低索引列插入、删除、更新的速度，索引维护需要代价。索引涉及的理论知识有<strong>二分查找法、哈希表及 B+Tree</strong>。</p>
<p><strong>二分查找法</strong></p>
<p>二分查找法也叫作<strong>折半查找法</strong>，它是在有序数组中查找指定数据的搜索算法。</p>
<ul>
<li>优点：等值查询、范围查询性能优秀</li>
<li>缺点：更新数据、新增数据、删除数据维护成本高</li>
</ul>
<p>哈希表 和 B+Tree 在《数据结构与算法》中已有介绍，这里不再赘述。</p>
<h4 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h4><p>对于索引数据结构的选择其本质是贴合当前数据读写的硬件环境选择一个优秀的数据结构进行数据存储及遍历，在数据库中大部分索引都是通过 <strong>B+Tree</strong> 来实现的。当然也涉及其他数据结构，<strong>在 MySQL 中除了 B+Tree 索引外我们还需要关注下 Hash 索引。</strong></p>
<h5 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h5><p><strong>哈希表是数据库中哈希索引的基础，是根据键值 &lt;key,value&gt; 存储数据的结构</strong>。简单说，哈希表是使用哈希函数将索引列计算到桶或槽的数组，实际存储是根据哈希函数将 key 换算成确定的存储位置，并将 value 存放到该数组位置上。访问时，只需要输入待查找的 key，即可通过哈希函数计算得出确定的存储位置并读取数据。</p>
<p>例如：姓名作为 key，通过哈希函数对姓名字段数据进行计算，得到<strong>哈希码</strong>并存放到桶或槽的数组中，同时存放指向真实数据行的<strong>指针</strong>作为 value，形成哈希表。哈希索引只存储哈希值和行指针，不存储实际字段值，所以其结构紧凑，查询速度也非常快。</p>
<p><strong>哈希索引的应用场景是只在对哈希索引列的等值查询才有效。</strong>包括 =、IN()、&lt;=&gt; （安全等于， select null &lt;=&gt; null 和 select null=null 是不一样的结果) ，不支持范围查询。</p>
<p><strong>Hash碰撞</strong></p>
<p><strong>Hash 碰撞</strong>是指不同索引列值计算出相同的哈希码。</p>
<p>对于 Hash 碰撞通用的处理方法是使用链表，将 Hash 冲突碰撞的元素形成一个链表，发生冲突时在链表上进行二次遍历找到数据。这类似于<strong>HashMap</strong> 实现原理。</p>
<p>在 MySQL 中主要有下列三种Hash索引：</p>
<ul>
<li>Memory 存储引擎原生支持的 Hash 索引</li>
<li>InnoDB 自适应哈希索引。</li>
<li>NDB 集群的哈希索引。</li>
</ul>
<p><strong>InnoDB 自适应哈希索引</strong></p>
<p>InnoDB 自适应哈希索引是为了提升查询效率，InnoDB 存储引擎会监控表上各个索引页的查询，<strong>当 InnoDB 注意到某些索引值访问非常频繁时，会在内存中基于 B+Tree 索引再创建一个哈希索引，使得内存中的 B+Tree 索引具备哈希索引的功能，即能够快速定值访问频繁访问的索引页。</strong></p>
<p><strong>为什么要为 B+Tree 索引页二次创建自适应哈希索引？</strong></p>
<p>因为 B+Tree 索引的查询效率取决于 B+Tree 的高度，在数据库系统中通常 B+Tree 的高度为 3～4 层，所以访问数据需要做 3～4 次的查询。而 Hash 索引访问通常一次查找就能定位数据（无 Hash 碰撞的情况），其等值查询场景 Hash 索引的查询效率要优于 B+Tree。</p>
<p>自适应哈希索引的建立使得 InnoDB 存储引擎能自动根据索引页访问的频率和模式自动地为某些热点页建立哈希索引来加速访问。 InnoDB 自适应哈希索引的功能，用户只能选择开启或关闭功能，无法进行人工干涉。</p>
<h5 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+Tree 索引"></a><strong>B+Tree 索引</strong></h5><p>MySQL 数据库中讨论索引时，如果没有明确指定类型，则默认是指使用 B+Tree 数据结构进行存储，其说法等价于 B+Tree、B-Tree、BTREE（看到创建索引语句为 BTREE 也不要惊讶，等同于 B+Tree）。</p>
<img src="/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%B8%80%EF%BC%89/mysql_08.png" alt="B+Tree索引" style="zoom:67%;">

<p>B+Tree 索引能够快速访问数据，就是因为存储引擎可以不再需要通过全表扫描来获取数据，而是从索引的根结点（通常在内存中）开始进行二分查找，根节点的槽中都存放了指向子节点的指针，存储引擎根据这些指针能够快速遍历数据。例如，通过页面号为 20 的根节点可以快速得知 Key&lt;10 的数据在 pageno 33 的页面，key在 [10,16) 范围的数据在 pageno 56 的页面。 叶子节点存放的 &lt;key+data&gt; ，对于真正要存放哪些数据还得取决于该 B+Tree 是<strong>聚簇索引（Clustered Index）</strong>还是<strong>辅助索引（Secondary Index）</strong>。</p>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p><strong>在 MySQL 中，索引是在存储引擎层而非服务器层实现</strong>。</p>
<p>在 MySQL 中不同存储引擎间支持的常见索引类型有：</p>
<ul>
<li>哈希索引（Memory/InnoDB adaptive Hash index/NDB）   —  InnoDB 支持</li>
<li>B+Tree 索引（MyISAM/InnoDB）—  InnoDB 支持</li>
<li>全文索引（MyISAM/InnoDB）—  InnoDB 支持</li>
<li>空间索引（MyISAM R-Tree）</li>
<li>分形树索引（TokuDB Fractal Tree Index）</li>
</ul>
<p>索引<strong>通常可以分为两大类</strong>：</p>
<ul>
<li><p><strong>主键索引（聚簇索引）</strong>：<strong>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式</strong>，它表示表中的数据按照主键顺序存储，是索引组织表。InnoDB 的聚簇索引就是按照主键顺序构建 B+Tree，B+Tree 的叶子节点就是行记录，<strong>数据行和主键值紧凑地存储在一起。 这也意味着 InnoDB 的主键索引就是数据表本身，它按主键顺序存放了整张表的数据。</strong></p>
<p>对于没有指定主键的表，InnoDB 会自己<strong>选择合适字段为主键</strong>，<strong>顺序为：显式主键，第一个唯一索引（要求唯一索引所有列都非 NULL）；内置的 6 字节 ROWID（隐藏列）。</strong></p>
</li>
<li><p><strong>辅助索引（非聚簇索引）</strong>：也叫作二级索引，只是根据索引列构建 B+Tree，但在 B+Tree 的每一行都存了主键信息，加速回表操作。 聚簇索引占用的空间就是整个表数据量的大小，而二级索引会比聚簇索引小很多， 通常创建辅助索引就是为了提升查询效率。</p>
</li>
</ul>
<p>根据索引<strong>列个数和功能描述不同</strong>索引也可以分为：</p>
<ul>
<li><strong>联合索引</strong>：联合索引是指在多个字段联合组建索引的。</li>
<li><strong>覆盖索引</strong>：<strong>一个索引包含了所有需要查询的字段的值，就称为覆盖索引</strong>。当通过索引即可查询到所有记录，不需要回表到聚簇索引时，这类索引也叫作覆盖索引。主键查询是天然的覆盖索引，联合索引可以是覆盖索引。通常在查看执行计划时， Extra 列为 Using index 则表示优化器使用了覆盖索引。</li>
</ul>
<p><strong>通常建议优先考虑使用覆盖索引，这是因为如果 SQL 需要查询辅助索引中不包含的数据列时，就需要先通过辅助索引查找到主键值，然后再回表通过主键查询到其他数据列（即回表查询），需要查询两次。而覆盖索引能从索引中直接获取查询需要的所有数据，从⽽避免回表进行二次查找，节省IO，效率较⾼。</strong></p>
<h4 id="索引基础知识"><a href="#索引基础知识" class="headerlink" title="索引基础知识"></a>索引基础知识</h4><ul>
<li><p><strong>谓词</strong>：谓词本身就是条件表达式，通俗讲就是过滤字段，例如：select * from user where user_name=’zhangsan’ and age = 18;  </p>
<ul>
<li>简单谓词：user_name 和 age。</li>
<li>组合谓词：user_name and age</li>
</ul>
</li>
<li><p><strong>过滤因子</strong>：过滤因子直接描述了谓词的选择性，表示满足谓词条件的记录行数所占比例，过滤因子越小意味着能过滤越多数据，你需要在这类谓词字段上创建索引。</p>
<ul>
<li><strong>简单谓词的过滤因子 = 谓词结果集的数量 / 表总行数</strong></li>
<li><strong>组合谓词的过滤因子 = 谓词 1 的过滤因子 × 谓词 2 的过滤因子</strong> </li>
</ul>
</li>
<li><p><strong>基数（Cardinality）</strong>：基数是<strong>某个键值去重后的行数</strong>， 索引列不重复记录数量的预估值，MySQL 优化器会依赖于它。</p>
</li>
<li><p><strong>选择率</strong>：<strong>= 基数 / 表总行数</strong>，选择率越接近 1 则越适合创建索引，例如主键和唯一键的选择率都是 1。</p>
</li>
<li><p><strong>回表</strong>：回表是指无法通过索引扫描访问所有数据，需要回到主表进行数据扫描并返回。</p>
</li>
<li><p><strong>Cardinality</strong>：Cardinality 能快速告知字段的选择性，高选择性字段有利于创建索引。优化器在选择执行计划时会依赖该信息，通常这类信息也叫作统计信息，数据库中对于统计信息的采集是在存储引擎层进行的。</p>
<p>执行 <code>show index from table_name</code> 会看到 Cardinality，同时也会触发 MySQL 数据库对 Cardinaltiy 值的统计。</p>
</li>
</ul>
<h4 id="索引使用细节"><a href="#索引使用细节" class="headerlink" title="索引使用细节"></a>索引使用细节</h4><ul>
<li><p>创建索引后通过查看执行 SQL 语句的执行计划即可知道 SQL 语句是否走索引。执行计划重点关注跟索引相关的关键项，有 type、possible_keys、key、key_len、ref、Extra 等。</p>
<img src="/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%B8%80%EF%BC%89/mysql_09.png" alt="查看执行计划" style="zoom:67%;">

<ul>
<li><strong>possible_keys</strong> 表示查询可能使用的索引</li>
<li><strong>key</strong>表示真正实际使用的索引</li>
<li><strong>key_len</strong> 表示使用索引字段的长度</li>
</ul>
</li>
<li><p>当索引选择联合索引时，通过<strong>计算 key_len 来了解有效索引长度对索引优化非常重要</strong>，key_len 表示得到结果集所使用的选择索引的长度[字节数]，不包括 order by。key_len 计算规则从两个方面考虑：</p>
<ul>
<li>索引字段的<strong>数据类型</strong>：根据索引字段的定义可以分为<strong>变长</strong>（比如 Varchar，除了是否为空的标记外，还需要有长度信息，需要占用 2 个字节）和<strong>定长</strong>（比如 char、int、datetime，需要有是否为空的标记，这个标记需要占用 1 个字节）两种数据类型；</li>
<li>字段所使用的<strong>字符集</strong>：表所使用的字符集，不同的字符集计算的 key_len 不一样，例如，GBK 编码的是一个占用 2 个字节大小的字符，UTF8 编码的是一个占用 3 个字节大小的字符。</li>
</ul>
</li>
</ul>
<p>举例：</p>
<ul>
<li><strong>Varchr(10) 变长字段且允许 NULL</strong>：10*(Character Set：utf8=3，gbk=2，latin1=1) + 1（标记是否为 NULL 需要 1 个字节）+ 2（变长字段存储长度信息需要 2 个字节）。</li>
<li><strong>Varchr(10) 变长字段且不允许 NULL</strong>：10*(Character Set：utf8=3，gbk=2，latin1=1) + 2（变长字段存储长度信息需要2个字节），非空不再需要占用字节来标记是否为空。</li>
<li><strong>Char(10) 固定字段且允许 NULL</strong>：10*(Character Set：utf8=3，gbk=2，latin1=1) + 1（标记是否为 NULL 需要 1 个字节）。 *</li>
<li><strong>Char(10) 固定字段且不允许 NULL</strong>：10*(Character Set：utf8=3，gbk=2，latin1=1)，非空不再需要占用字节来标记是否为空。</li>
</ul>
<p><strong>最左前缀匹配原则</strong></p>
<p>通过 key_len 计算也帮助我们了解索引的最左前缀匹配原则。</p>
<p>最左前缀匹配原则是指在使用 B+Tree 联合索引进行数据检索时，MySQL 优化器会读取谓词（过滤条件）并按照联合索引字段创建顺序一直向右匹配直到遇到范围查询或非等值查询后停止匹配，此字段之后的索引列不会被使用，这时计算 key_len 可以分析出联合索引实际使用了哪些索引列。</p>
<h4 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h4><ul>
<li><p>首先<strong>定位由于索引不合适或缺少索引而导致的慢查询</strong>。慢查询日志分析，抓出运行慢的 SQL 进行分析，也可以借助第三方工具例如 Arkcontrol 慢查询分析系统进行慢查询采集和分析。在分析慢查询时进行参数最差输入，同时，对 SQL 语句的谓词进行过滤因子、基数、选择率和 SQL 查询回表情况的分析。</p>
</li>
<li><p><strong>设计索引</strong>。创建索引规范：</p>
<ul>
<li>单张表的索引数量不超过 5 个，单个索引中的字段数不超过 5 个。</li>
<li>表必需有主键，推荐使⽤ UNSIGNED 自增列作为主键。</li>
<li>唯一键由 3 个以下字段组成，并且在字段都是整形时，可使用唯一键作为主键。</li>
<li>禁止冗余索引、禁止重复索引，索引维护需要成本，新增索引时优先考虑基于现有索引进行 rebuild。</li>
<li>联表查询时，JOIN 列的数据类型必须相同，并且要建⽴索引。</li>
<li>不在低基数列上建⽴索引。</li>
</ul>
</li>
<li><p>创建<strong>索引策略</strong>：</p>
<ul>
<li>优先为搜索列、排序列、分组列创建索引，必要时加入查询列创建覆盖索引；</li>
<li>计算字段列基数和选择率，选择率越接近于 1 越适合创建索引；</li>
<li>索引选用较小的数据类型（整型优于字符型），字符串可以考虑前缀索引；</li>
<li>不要建立过多索引，优先基于现有索引调整顺序；</li>
<li>参与比较的字段类型保持匹配并创建索引。例如“性别”。 在低基数列上创建的索引查询相比全表扫描不一定有性能优势，特别是当存在回表成本时。</li>
<li>选择区分度（选择率）大的列建立索引。组合索引中，区分度（选择率）大的字段放在最前面。</li>
<li>对过长的 Varchar 段建立索引。建议优先考虑前缀索引，或添加 CRC32 或 MD5 伪列并建⽴索引。 </li>
<li>合理创建联合索引，(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)。 </li>
<li>合理使用覆盖索引减少IO，避免排序。</li>
</ul>
</li>
<li><p><strong>调优索引</strong></p>
<p>分析执行计划；更新统计信息（Analyze Table）；Hint优化，方便调优（FORCE INDEX、USE INDEX、IGNORE INDEX、STRAIGHT_JOIN）；检查连接字段数据类型、字符集；避免使用类型转换；关注 optimizer_switch，重点关注索引优化特性 MRR（Multi-Range Read）和 ICP（Index Condition Pushdown）。</p>
</li>
</ul>
<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>首先需要了解查询优化器处理 SQL 的全过程。以 SELECT 的 SQL 的执行过程为例：</p>
<img src="/2021/03/15/%E8%AF%A6%E8%A7%A3Mysql%EF%BC%88%E4%B8%80%EF%BC%89/mysql_10.png" alt="Mysql SQL执行过程" style="zoom:80%;">

<ul>
<li>客户端发送一条 SELECT 查询给服务器；</li>
<li>服务器先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段；</li>
<li>服务器进行 SQL 解析、预处理、再由查询优化器生成对应的执行计划；</li>
<li>MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询；</li>
<li>将结果返回给客户端，同时也会放入查询缓存中。</li>
</ul>
<p><strong>MySQL</strong> 采用<strong>基于开销的优化器</strong>，以确定处理查询的最佳方式，也就是说<strong>执行查询之前，都会先选择一条自以为最优的方案。</strong></p>
<h4 id="执行计划分析"><a href="#执行计划分析" class="headerlink" title="执行计划分析"></a><strong>执行计划分析</strong></h4><ul>
<li><strong>查看 SQL 执行计划</strong>：<ul>
<li>explain SQL；</li>
<li>desc 表名；</li>
<li>show create table 表名。</li>
</ul>
</li>
<li><strong>通过 Profile 定位 QUERY 代价消耗</strong>：<ul>
<li>set profiling=1；</li>
<li>执行 SQL；</li>
<li>show profiles; </li>
<li>获取 Query_ID。</li>
<li>show profile for query Query_ID; </li>
<li>查看详细的 profile 信息。</li>
</ul>
</li>
<li><strong>通过 Optimizer Trace 表查看 SQL 执行计划树</strong>：<ul>
<li>set session optimizer_trace=’enabled=on’；</li>
<li>执行 SQL；</li>
<li>查询 information_schema.optimizer_trace 表，获取 SQL 查询计划树；</li>
<li>set session optimizer_trace=‘enabled=off’；开启此项影响性能，记得用后关闭。</li>
</ul>
</li>
</ul>
<p><strong>MySQL</strong> 可以通过设置一些参数，将<strong>运行时间长或者非索引查找的 SQL 记录到慢查询文件</strong>中。可以分析慢查询文件中的 SQL，有针对性的进行优化。</p>
<ul>
<li>参数 slow_query_log，表示是否开启慢查询日志，ON 或者 1 表示开启，OFF 或者 0 表示关闭。</li>
<li>参数 long_query_time，设置慢查询的阈值，MySQL 5.7 版本支持微秒级。</li>
<li>参数 slow_query_log_file，慢查询文件的存放路径。</li>
<li>参数 log_queries_not_using_indexes，表示是否将非索引查找的 SQL 也记录到慢查询文件中。</li>
<li>参数 log_throttle_queries_not_using_indexes，表示每分钟记录到慢查询文件中未使用索引的 SQL 语句上限，0 表示没限制。</li>
<li>参数 max_execution_time，用来控制 SELECT 语句的最大执行时间，单位毫秒，超过此值MySQL 自动 kill 掉该查询。</li>
</ul>
<p>分析慢查询常用的工具有：</p>
<ul>
<li>explain；</li>
<li>Mysqldumpslow，官方慢查询分析工具；</li>
<li><strong>pt-query-digest</strong>，Percona 公司开源的慢查询分析工具；</li>
<li>vc-mysql-sniffer，第三方的慢查询抓取工具；</li>
<li>pt-kill，Percona 公司开源的慢查询 kill 工具，常用于生产环境的过载保护。</li>
</ul>
<h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><p>考虑因素：</p>
<ul>
<li><strong>全表扫描还是索引扫描</strong>。对于小表来说，二者 IO 调用次数和返回时间相差不大；但对于大表，如果全表扫描，那么查询返回的时间就会很长，就需要使用索引扫描加快查询速度。但同时应该考虑索引数量不宜过多。</li>
<li>如何创建索引，在哪些列上建立索引。</li>
<li>创建索引以后，尽量不要过频修改。</li>
<li>SQL 中关联列字段类型不一致或者传入的参数类型与字段类型不匹配的情况，这样就会导致无法使用索引；</li>
<li>索引列上使用函数也不会涉及索引。</li>
<li>全模糊匹配的查询无法使用索引。</li>
<li>order by/group by 的 SQL 涉及排序，尽量在索引中包含排序字段，并让排序字段的排序顺序与索引列中的顺序相同，这样可以避免排序或减少排序次数。</li>
<li>复杂查询还是简单查询。</li>
</ul>
<blockquote>
<p>笔记来源：</p>
<p>Mysql锁总结：<a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29150809</a></p>
<p>周彦伟 老师的 《高性能Mysql实战》课程</p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>面试复习</tag>
        <tag>Mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中一致性hash的实现</title>
    <url>/2021/04/12/Java%E4%B8%AD%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>前面在《缓存-基础概念》的学习中，关于<a href="http://blogsea.cn/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/#%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener"><strong>数据分布设计</strong></a>一节，提到关于数据分布算法，通常采用<strong>取模</strong>或者<strong>一致性hash分布</strong>。随后在  <strong>Memcached</strong> 和 <strong>Redis</strong> 章节，也确切提到 例如<strong>Memcached 分拆缓存池</strong>采用一致性<strong>hash</strong>，<strong>Redis</strong> Client 分区方案数据分布方案 采用一致性hash算法等。</p>
<p>那么 一致性hash 算法是如何实现的呢，一起来学习一下。</p>
<h3 id="常规取模哈希"><a href="#常规取模哈希" class="headerlink" title="常规取模哈希"></a>常规取模哈希</h3><p>通常我们所说的最简单的hash算法即为 取模hash （或者 HashMap 中位运算）。</p>
<ul>
<li>第一步通过jdk内置hash方法对请求参数hash运算，得到一个整数</li>
<li>第二步将该整数 i 对服务器台数 n 取模，将请求分散到不同的服务器上</li>
</ul>
<p><strong>缺点</strong>：</p>
<p>当<strong>增减</strong>服务器时，会造成部分数据丢失。例如作为缓存场景来说，新增一台服务器导致变更后取模与变更前取模命中服务器不一致，降低缓存命中率。</p>
<h3 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><p>为了解决以上问题，前辈们设计了一致性哈希算法。</p>
<p>hash算法出来的整数有个范围，我们在这个范围内布置三台服务器（范围具体是多少看前面的hash算法）。假设hash的范围是1~300，每台负责一段范围内的请求，比如一台负责(1-100]，一台负责(100-200]，一台负责(200-1]。<strong>这三台server收尾相接覆盖/闭环了所有请求，称为哈希环</strong>。</p>
<p><img src="/2021/04/12/Java%E4%B8%AD%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%9A%84%E5%AE%9E%E7%8E%B0/hash_01.png" alt="哈希环"></p>
<p>如何实现一台服务器接收一个范围的请求？这个时候不用取模了，而是将server也按照hash算法计算一个id值，比如按照他们的ip+port+name拼成的串计算，假设正好分别是 1，100，200，将他们放进一个treeMap里，</p>
<p>Map&lt;Inetger,Node&gt; ，其中Node代表server节点，是自定义的数据结构，比如是一个类，包含ip，port，name等属性。</p>
<p>一个请求过来hash得到的值必属于这三个server的范围，比如一个请求id=N，那么从map里get(N)去找server，</p>
<ul>
<li><p>找到直接转发，</p>
</li>
<li><p>找不到进行如下运算：treemap里有个关键的api，tailMap()，这个接口能够<strong>返回id比N大的map的子集</strong>，然后取子集的第一个节点，就是id=100的节点，通常称为顺时针查找。</p>
<p>当然如果子集为空，这意味着N&gt;200，就取整个map的第一个节点，完成闭环。</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<p>从实现可以看出，如果一个节点挂了，他的流量会顺时针（逆时针实现也是一样的）“导流”到下一个节点，其他节点不受影响。</p>
<p><strong>缺点：</strong></p>
<p>假设各台服务器性能差不多，此时流量突增，一台server由于流量过载而挂掉，那么它的下一台因为承载了2倍的流量，很有可能也会挂掉，依此类推，最后所有的节点都会挂掉，造成“雪崩”！</p>
<h3 id="虚拟节点改进"><a href="#虚拟节点改进" class="headerlink" title="虚拟节点改进"></a>虚拟节点改进</h3><p>如何解决上述问题，可<strong>在其基础上使用hash算法将每台服务器节点分散分布环中</strong>。即每台机器虚拟出多个节点，分散分布于闭环中。</p>
<p><img src="/2021/04/12/Java%E4%B8%AD%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%9A%84%E5%AE%9E%E7%8E%B0/hash_02.png" alt="虚节点改进"></p>
<p>如图，那么当一台服务器挂掉时，其流量将分摊到下一台机器上，（理论上下一台机器存在为同一台机器的可能，但是概率非常小，可将分片数扩大），有效的降低节点雪崩的风险。</p>
<p>综上，一致性哈希算法并不是强一致性，也不是高可用方案，如果server挂了数据丢了就是丢了，除非有恢复手段，它只是一种减少由扩缩容引起的命中率下降的手段。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>通常分布式缓存中使用一致性hash做数据分布。</p>
<p>相对于 普通hash ，一致性hash的用处在于<strong>缓存集群扩容（缩容）时，一致性hash 可以降低缓存命中率下降问题</strong>。(当服务器节点数据较多时，失效部分可以忽略)</p>
<p>举例：缓存服务器有三个节点，现因业务需要新增加一个 节点，分析普通hash 和 一致性hash 缓存命中率变动幅度。</p>
<ul>
<li><p>普通hash，缓存命中率为 1/4, 失效率为 3/4，计算方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">假设 N*(N+<span class="number">1</span>) 个key ，则只有N个节点 缓存命中，命中率为  N/(N*(N+<span class="number">1</span>)) = <span class="number">1</span>/(N+<span class="number">1</span>)</span><br><span class="line">失效率为：N/(N+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>一致性hash ，因为 环周长没有变，只新增了 一个节点部分缓存失效，所以 一致性哈希 的缓存命中率为：<code>N/(N+1)</code> ,失效率为： <code>1/(N+1)</code></p>
</li>
</ul>
<blockquote>
<p>笔记参考：<a href="https://blog.csdn.net/flyfeifei66/article/details/82458618" target="_blank" rel="noopener">https://blog.csdn.net/flyfeifei66/article/details/82458618</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>一致性hash</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2021/04/13/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p><strong>布隆过滤器</strong>本质上是一种<strong>数据结构</strong>，比较巧妙的<strong>概率型数据结构（probabilistic data structure）</strong></p>
<ul>
<li><p><strong>优点</strong>：高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。</p>
<p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少。</p>
</li>
<li><p><strong>缺点</strong>：是其返回的<strong>结果是概率性</strong>的，而不是确切的。</p>
</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>通常判断某个元素是否存在的方式：</p>
<p>可以将值映射到 <strong>HashMap</strong> 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率高。但是 HashMap 的实现也有缺点，例如<strong>存储容量占比高</strong>，考虑到负载因子的存在，通常<strong>空间是不能被用满</strong>的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很大了。</p>
<p>即：<strong>内存占用大，利用率低。</strong></p>
<p><strong>布隆过滤器数据结构</strong></p>
<p><strong>布隆过滤器</strong>是一个 bit 向量或者说 bit 数组：</p>
<p><img src="/2021/04/13/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/bulong_filter_01.jpg" alt="布隆过滤器"></p>
<p>如果我们要映射一个值到布隆过滤器中，我们需要使用<strong>多个不同的哈希函数</strong>生成<strong>多个哈希值，</strong>并对每个生成的哈希值指向的 bit 位置置成 1。</p>
<p><strong>例如：</strong></p>
<p>针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则在1、4、7 位置置成1。</p>
<p>这时，我们再存一个值 “tencent”，假如哈希函数返回 3、4、8 的话，3、4、8 位置置成1。值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。</p>
<p>现在我们如果想查询 “ali” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，<strong>说明没有任何一个值映射到这个 bit 位上</strong>，因此我们可以<strong>很确定</strong>地说 “ali” 这个值不存在。</p>
<p>但是，如果现在有一个值经过n次哈希函数后，得到的值的位置都为1，那么该值一定存在吗？不一定。</p>
<p><strong>综上：</strong></p>
<p><strong>布隆过滤器可以判断某一个值一定不存在，不一定能判断某一个值一定存在，只能说可能存在。</strong></p>
<p>这个可能的准确性，取决于<strong>哈希函数的个数</strong> 和 <strong>布隆过滤器的长度</strong>。</p>
<p><strong>扩展</strong>：传统的布隆过滤器并不支持删除操作。但是名为 Counting Bloom filter 的变种可以用来<strong>测试元素计数个数是否绝对小于某个阈值</strong>，它支持元素删除。</p>
<h3 id="如何选择哈希函数个数和布隆过滤器长度"><a href="#如何选择哈希函数个数和布隆过滤器长度" class="headerlink" title="如何选择哈希函数个数和布隆过滤器长度"></a>如何选择哈希函数个数和布隆过滤器长度</h3><p><img src="/2021/04/13/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/bulong_filter_02.jpg" alt="布隆过滤器参数选择"></p>
<p>k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率。</p>
<p>由图可见，<strong>哈希函数个数越多，布隆过滤器越长，误报率越低。</strong></p>
<p>如何选择适合业务的 k 和 m 值，这里直接贴一个公式：</p>
<p><img src="/2021/04/13/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/bulong_filter_03.jpg" alt="参数计算公式"></p>
<p>具体公式推导过程，可自行上网查询。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul>
<li><p>利用布隆过滤器减少磁盘 IO 或者网络请求，<strong>一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。</strong></p>
</li>
<li><p>使用布隆过滤器来加速查找和判断是否存在，那么性能很低的哈希函数不是个好选择，推荐 MurmurHash、Fnv 这些。</p>
</li>
<li><p>Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。</p>
</li>
</ul>
<blockquote>
<p>笔记来源：</p>
<p><a href="https://zhuanlan.zhihu.com/p/43263751" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43263751</a></p>
<p><a href="https://www.cnblogs.com/liyulong1982/p/6013002.html" target="_blank" rel="noopener">https://www.cnblogs.com/liyulong1982/p/6013002.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>布隆过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>限流方案</title>
    <url>/2021/05/25/%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>在大数据量高并发访问时，经常会出现服务或接口面对暴涨的请求而<strong>不可用</strong>的情况，甚至引发连锁反映导致整个系统崩溃。此时你需要使用的技术手段之一就是限流，当请求达到一定的并发数或速率，就进行等待、排队、降级、拒绝服务等。</p>
<p>限流一般分为俩个维度：</p>
<ul>
<li><strong>时间：</strong> 限流基于某段时间范围或者某个时间点，也就是我们常说的“时间窗口”，比如对每分钟、每秒钟的时间窗口做限定。</li>
<li><strong>资源：</strong> 基于可用资源的限制，比如设定最大访问次数，或最高可用连接数。</li>
</ul>
<p><strong>分类：</strong></p>
<ul>
<li><strong>合法性验证限流</strong>：比如验证码、IP 黑名单等，这些手段可以有效的防止恶意攻击和爬虫采集；</li>
<li><strong>容器限流</strong>：比如 Tomcat、Nginx 等限流手段，其中 Tomcat 可以设置最大线程数（maxThreads），当并发超过最大线程数会排队等待执行；而Nginx提供了两种限流手段：一是控制速率，二是控制并发连接数；</li>
<li><strong>服务端限流</strong>：比如我们在服务器端通过限流算法实现限流，常用的有漏桶算法、令牌桶算法、滑动时间窗口算法等。</li>
</ul>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="Tomcat限流"><a href="#Tomcat限流" class="headerlink" title="Tomcat限流"></a>Tomcat限流</h2><p>Tomcat 8.5 版本的最大线程数在 conf/server.xml 配置中，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;connector</span> <span class="string">port="8080" protocol="HTTP/1.1"</span></span><br><span class="line">	<span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span><br><span class="line">	<span class="attr">maxThreads</span>=<span class="string">"150"/&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 maxThreads 就是 Tomcat 的最大线程数，当请求的并发大于此值（maxThreads）时，请求就会排队执行，这样就完成了限流的目的。</p>
<p>注意：</p>
<p>maxThreads 的值可以适当的调大一些，Tomcat默认为 150（Tomcat 版本 8.5），但这个值也不是越大越好，要看具体的服务器配置，需要注意的是每开启一个线程需要耗用 1MB 的 JVM 内存空间用于作为线程栈之用，并且线程越多 GC 的负担也越重。</p>
<p>最后需要注意一下，操作系统对于进程中的线程数有一定的限制，Windows 每个进程中的线程数不允许超过 2000，Linux 每个进程中的线程数不允许超过 1000。</p>
<h2 id="Nginx-限流"><a href="#Nginx-限流" class="headerlink" title="Nginx 限流"></a>Nginx 限流</h2><p>Nginx官方版本<strong>限制IP的连接</strong>和<strong>并发</strong>分别有两个模块：</p>
<ul>
<li><code>limit_req_zone</code> 用来限制单位时间内的请求数，即速率限制,采用的漏桶算法 “leaky bucket”。</li>
<li><code>limit_req_conn</code> 用来限制同一时间连接数，即并发限制。</li>
</ul>
<h5 id="限制速率"><a href="#限制速率" class="headerlink" title="限制速率"></a>限制速率</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">http</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">limit_req_zone</span> <span class="string">$binary_remote_addr zone=one:10m rate=1r/s;</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">location</span> <span class="string">/search/ &#123;</span></span><br><span class="line">            <span class="attr">limit_req</span> <span class="string">zone=one burst=5 nodelay;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">limit_req_zone</span> <span class="string">$binary_remote_addr zone=one:10m rate=1r/s;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数：<code>$binary_remote_addr</code> 表示通过<code>remote_addr</code>这个标识来做限制，“binary_”的目的是缩写内存占用量，是限制同一客户端ip地址。</li>
<li>第二个参数：<code>zone=one:10m</code>表示生成一个大小为10M，名字为one的内存区域，用来存储访问的频次信息。</li>
<li>第三个参数：<code>rate=1r/s</code>表示允许相同标识的客户端的访问频次，这里限制的是每秒1次，还可以有比如30r/m的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">limit_req zone&#x3D;one burst&#x3D;5 nodelay;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数：<code>zone=one</code> 设置使用哪个配置区域来做限制，与上面<code>limit_req_zone</code> 里的name对应。</li>
<li>第二个参数：<code>burst=5</code>，重点说明一下这个配置，burst爆发的意思，这个配置的意思是设置一个大小为5的缓冲区当有大量请求（爆发）过来时，超过了访问频次限制的请求可以先放到这个缓冲区内。</li>
<li>第三个参数：<code>nodelay</code>，如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回503，如果没有设置，则所有请求会等待排队。</li>
</ul>
<h5 id="限制并发数"><a href="#限制并发数" class="headerlink" title="限制并发数"></a>限制并发数</h5><p>nginx 利用 <code>limit_conn_zone</code> 和<code>limit_conn</code> 两个指令即可控制并发数.</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">limit_conn_zone</span> <span class="string">$binary_remote_addr zone=perip:10m;</span></span><br><span class="line"><span class="attr">limit_conn_zone</span> <span class="string">$server_name zone=perserver:10m;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">...</span></span><br><span class="line">    <span class="attr">limit_conn</span> <span class="string">perip 10;</span></span><br><span class="line">    <span class="attr">limit_conn</span> <span class="string">perserver 100;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以配置多个<code>limit_conn</code>指令。例如，以上配置将限制每个客户端IP连接到服务器的数量，同时限制连接到虚拟服务器的总数。</p>
<h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><ul>
<li>固定时间窗口限流</li>
<li>滑动时间窗口限流</li>
<li>漏桶算法</li>
<li>令牌桶算法</li>
<li>滑动日志</li>
</ul>
<h4 id="固定时间窗口算法"><a href="#固定时间窗口算法" class="headerlink" title="固定时间窗口算法"></a>固定时间窗口算法</h4><p>维护一个计数器，将单位时间段当做一个窗口，计数器记录这个窗口接受请求的次数。</p>
<ul>
<li>当次数小于限流阀值，就允许访问，并且计数器+1</li>
<li>当次数大于限流阀值，就拒绝访问。</li>
<li>当前时间窗口过去后，计数器清零。</li>
</ul>
<p><strong>临界问题</strong>：假设限流阀值为5，单位时间窗口是1s，如果在单位时间内的前 <strong>0.8-1s</strong> 和 <strong>1-1.2s ** 分别并发 5个请求。虽然 前一秒和后一秒的时间窗口内都没有超过阀值。但是如果算 **0.8-1.2s</strong> ，则并发达到10，已经超过单位时间1s内不超过5个请求的阀值定义了。</p>
<h4 id="滑动时间窗口算法"><a href="#滑动时间窗口算法" class="headerlink" title="滑动时间窗口算法"></a>滑动时间窗口算法</h4><p>滑动时间窗口算法可以解决固定时间窗口限流算法的临界值问题。</p>
<p>它将单位时间周期分为n个小周期，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。</p>
<p>例如单位时间还是1s，滑动窗口算法把其划分成5个小周期，也就是滑动窗口（单位时间）被分成5个小格子。每格表示0.2s。每过0.2s，时间窗口就会往右滑动一格。每个小周期都有一个计数器。</p>
<p>滑动时间窗口算法虽然解决了临界值问题，但是一旦请求达到规则限流值，请求会被直接暴力拒绝。这样我们会损失一部分请求，对于部分场景来说并不合理。</p>
<h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>漏铜算法面对限流更加柔和，并不会直接粗暴的拒绝。</p>
<p>漏桶(Leaky Bucket)算法：请求先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大或者漏桶已满会直接溢，然后就拒绝请求，可以看出漏桶算法能强行限制数据的传输速率。</p>
<ul>
<li><p>定义一个桶的最大量；</p>
</li>
<li><p>记录上次桶刷新的时间和水量，以便后续计算当前桶里面的水；</p>
</li>
<li><p>定义水的流出速率，速率越小，限制流量越小；</p>
</li>
<li><p>每次请求，先检查桶的水量，如果没有达到最大值，往桶里面加水。如果达到最大值则按照相应的拒绝策略拒绝。</p>
</li>
</ul>
<p>在正常流量时，按照固定的速率处理请求是我们想要的，但是应用系统设置限流值并不是按照系统实际可承载最大吞吐量来设定的，系统允许在突发流量时，处理速度加快，只不过系统不应长时间保持高负载，这样才能尽可能的利用系统资源，保证请求尽快被处理。</p>
<h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>面对突发流量时，我们可以使用令牌桶算法限流。</p>
<ul>
<li>有一个令牌管理员，根据限流大小，定速往令牌桶里放令牌。</li>
<li>如果令牌数量满了，超过令牌容量的限制，那就丢弃。</li>
<li>系统在接受到一个用户请求时，都会先去令牌桶请求一个令牌，如果拿到令牌则处理这个请求业务。</li>
<li>如果拿不到则直接拒绝这个请求。</li>
</ul>
<blockquote>
<p>笔记来源：<a href="https://blog.csdn.net/wangxy_job/article/details/106313398" target="_blank" rel="noopener">https://blog.csdn.net/wangxy_job/article/details/106313398</a></p>
<p><a href="https://www.cnblogs.com/biglittleant/p/8979915.html" target="_blank" rel="noopener">https://www.cnblogs.com/biglittleant/p/8979915.html</a></p>
<p><a href="https://blog.csdn.net/wangxy_job/article/details/106313383" target="_blank" rel="noopener">https://blog.csdn.net/wangxy_job/article/details/106313383</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式ID生成方案</title>
    <url>/2021/05/25/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>分布式系统中需要全局唯一的ID，就叫 分布式ID。</p>
<ul>
<li>全局唯一</li>
<li>高性能：id生成响应要快，否则会影响系统性能</li>
<li>高可用</li>
<li>好接入：系统设计简单，好接入</li>
<li>趋势递增</li>
</ul>
<h3 id="常用方案"><a href="#常用方案" class="headerlink" title="常用方案"></a>常用方案</h3><ul>
<li><p>UUID</p>
</li>
<li><p>数据库自增ID</p>
</li>
<li><p>分布式数据库自增ID</p>
</li>
<li><p>号段模式</p>
</li>
<li><p>Redis 自增特性</p>
</li>
<li><p>雪花算法（SnowFlake）</p>
</li>
</ul>
<h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">       String uuid = UUID.randomUUID().toString().replaceAll(<span class="string">"-"</span>,<span class="string">""</span>);</span><br><span class="line">       System.out.println(uuid);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>生成简单，本地生成无网络消耗，具有唯一性</li>
</ul>
<p>缺点：</p>
<ul>
<li>无序字符串，不能递增</li>
<li>无具体业务含义</li>
<li>长度过长</li>
</ul>
<h4 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h4><p>基于数据库的<code>auto_increment</code>自增ID完全可以充当<code>分布式ID</code>，具体实现：需要一个单独的MySQL实例用来生成ID，建表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`SEQ_ID`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SEQID.SEQUENCE_ID (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment, </span><br><span class="line">    <span class="keyword">value</span> <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>实现简单，ID单调自增，数值类型查询速度快</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>DB单点存在宕机风险，无法扛住高并发场景</li>
</ul>
<h4 id="基于数据库集群自增ID"><a href="#基于数据库集群自增ID" class="headerlink" title="基于数据库集群自增ID"></a>基于数据库集群自增ID</h4><p>前边说了单点数据库方式不可取，那对上边的方式做一些高可用优化，换成主从模式集群。害怕一个主节点挂掉没法用，那就做双主模式集群，也就是两个Mysql实例都能单独的生产自增ID。</p>
<p><strong>问题：多个实例都生成ID，会产生重复ID 的问题，不满足唯一性。</strong></p>
<p><strong>解决方法：设置起始值和自增步长。</strong></p>
<p>MySQL_1 配置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @@auto_increment_offset = <span class="number">1</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_increment = <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br></pre></td></tr></table></figure>

<p>MySQL_2 配置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @@auto_increment_offset = <span class="number">2</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @@auto_increment_increment = <span class="number">2</span>;  <span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>解决DB单点问题。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不利于后续扩容（扩容需要修改已有实例的起始值和步长），而且实际上单个数据库自身压力还是大，依旧无法满足高并发场景。</li>
</ul>
<h4 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h4><p>号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> id_generator (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  max_id <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'当前最大id'</span>,</span><br><span class="line">  step <span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'号段的布长'</span>,</span><br><span class="line">  biz_type	<span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'业务类型'</span>,</span><br><span class="line">  <span class="keyword">version</span> <span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'版本号'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>biz_type</strong> ：代表不同业务类型</p>
<p><strong>max_id</strong> ：当前最大的可用id</p>
<p><strong>step</strong> ：代表号段的长度</p>
<p><strong>version</strong> ：是一个乐观锁，每次都更新version，保证并发时数据的正确性</p>
<p>等这批号段ID用完，再次向数据库申请新号段，对<code>max_id</code>字段做一次<code>update</code>操作，<code>update max_id= max_id + step</code>，update成功则说明新号段获取成功，新的号段范围是<code>(max_id ,max_id +step]</code>。</p>
<h4 id="基于Redis自增ID"><a href="#基于Redis自增ID" class="headerlink" title="基于Redis自增ID"></a>基于Redis自增ID</h4><p><code>Redis</code>也同样可以实现，原理就是利用<code>redis</code>的 <code>incr</code>命令实现ID的原子性自增。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set seq_id <span class="number">1</span>     <span class="comment">// 初始化自增ID为1</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; incr seq_id      <span class="comment">// 增加1，并返回递增后的数值</span></span><br><span class="line">(integer) <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>用<code>redis</code>实现需要注意一点，要考虑到redis持久化的问题。<code>redis</code>有两种持久化方式<code>RDB</code>和<code>AOF</code></p>
<ul>
<li><code>RDB</code>会定时打一个快照进行持久化，假如连续自增但<code>redis</code>没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li>
<li><code>AOF</code>会对每条写命令进行持久化，即使<code>Redis</code>挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致<code>Redis</code>重启恢复的数据时间过长。</li>
</ul>
<h4 id="雪花算法（Snowflake）"><a href="#雪花算法（Snowflake）" class="headerlink" title="雪花算法（Snowflake）"></a>雪花算法（Snowflake）</h4><p><img src="/2021/05/25/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/incr_id.jpg" alt="雪花算法组成结构"></p>
<p><code>Snowflake</code>生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。</p>
<p>Snowflake ID组成结构：<code>正数位</code>（占1比特）+ <code>时间戳</code>（占41比特）+ <code>机器ID</code>（占5比特）+ <code>数据中心</code>（占5比特）+ <code>自增值</code>（占12比特），总共64比特组成的一个Long类型。</p>
<ul>
<li>第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。</li>
<li>时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li>
<li>工作机器id（10bit）：也被叫做<code>workId</code>，这个可以灵活配置，机房或者机器号组合都可以。</li>
<li>序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID</li>
</ul>
<p><strong>Java版本的<code>Snowflake</code>算法实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Twitter的SnowFlake算法,使用SnowFlake算法生成一个整数，然后转化为62进制变成一个短地址URL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://github.com/beyondfengyu/SnowFlake</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowFlakeShortUrl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始的时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> START_TIMESTAMP = <span class="number">1480166465631L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分占用的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> SEQUENCE_BIT = <span class="number">12</span>;   <span class="comment">//序列号占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_BIT = <span class="number">5</span>;     <span class="comment">//机器标识占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATA_CENTER_BIT = <span class="number">5</span>; <span class="comment">//数据中心占用的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_SEQUENCE = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; SEQUENCE_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_MACHINE_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; MACHINE_BIT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_DATA_CENTER_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; DATA_CENTER_BIT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一部分向左的位移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> TIMESTAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> dataCenterId;  <span class="comment">//数据中心</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> machineId;     <span class="comment">//机器标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>; <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimeStamp = -<span class="number">1L</span>;  <span class="comment">//上一次时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextMill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mill = getNewTimeStamp();</span><br><span class="line">        <span class="keyword">while</span> (mill &lt;= lastTimeStamp) &#123;</span><br><span class="line">            mill = getNewTimeStamp();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNewTimeStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定的数据中心ID和机器标志ID生成指定的序列号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataCenterId 数据中心ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> machineId    机器标志ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowFlakeShortUrl</span><span class="params">(<span class="keyword">long</span> dataCenterId, <span class="keyword">long</span> machineId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataCenterId &gt; MAX_DATA_CENTER_NUM || dataCenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"DtaCenterId can't be greater than MAX_DATA_CENTER_NUM or less than 0！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (machineId &gt; MAX_MACHINE_NUM || machineId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"MachineId can't be greater than MAX_MACHINE_NUM or less than 0！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.dataCenterId = dataCenterId;</span><br><span class="line">        <span class="keyword">this</span>.machineId = machineId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产生下一个ID</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currTimeStamp = getNewTimeStamp();</span><br><span class="line">        <span class="keyword">if</span> (currTimeStamp &lt; lastTimeStamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Clock moved backwards.  Refusing to generate id"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currTimeStamp == lastTimeStamp) &#123;</span><br><span class="line">            <span class="comment">//相同毫秒内，序列号自增</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; MAX_SEQUENCE;</span><br><span class="line">            <span class="comment">//同一毫秒的序列数已经达到最大</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0L</span>) &#123;</span><br><span class="line">                currTimeStamp = getNextMill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不同毫秒内，序列号置为0</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastTimeStamp = currTimeStamp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (currTimeStamp - START_TIMESTAMP) &lt;&lt; TIMESTAMP_LEFT <span class="comment">//时间戳部分</span></span><br><span class="line">                | dataCenterId &lt;&lt; DATA_CENTER_LEFT       <span class="comment">//数据中心部分</span></span><br><span class="line">                | machineId &lt;&lt; MACHINE_LEFT             <span class="comment">//机器标识部分</span></span><br><span class="line">                | sequence;                             <span class="comment">//序列号部分</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SnowFlakeShortUrl snowFlake = <span class="keyword">new</span> SnowFlakeShortUrl(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">4</span>); i++) &#123;</span><br><span class="line">            <span class="comment">//10进制</span></span><br><span class="line">            System.out.println(snowFlake.nextId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>笔记来源：<a href="https://zhuanlan.zhihu.com/p/107939861" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/107939861</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>ID</tag>
      </tags>
  </entry>
</search>
