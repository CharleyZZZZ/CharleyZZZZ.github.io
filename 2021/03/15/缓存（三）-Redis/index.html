<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    缓存（三）- Redis |  Hello World !
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      <section class="outer">
  <article id="post-缓存（三）-Redis" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  缓存（三）- Redis
</h1>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/" class="article-date">
  <time datetime="2021-03-15T07:49:36.000Z" itemprop="datePublished">2021-03-15</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/">技术学习</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">13.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">48 min</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="缓存之Redis（三）"><a href="#缓存之Redis（三）" class="headerlink" title="缓存之Redis（三）"></a>缓存之Redis（三）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C语言" target="_blank" rel="noopener">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/数据库/103728" target="_blank" rel="noopener">数据库</a>，并提供多种语言的API。它的所有数据结构都存在内存中，可以用作缓存、数据库和消息中间件。</p>
<p>一个 Redis 实例可以有多个存储数据的字典，客户端可以通过 select 来选择字典即 DB 进行数据存储。</p>
<p>– 百度百科</p>
</blockquote>
<p><strong>特性</strong>：</p>
<ul>
<li><p>同为 key-value 存储组件，Memcached 只能支持<strong>二进制字节块</strong>这一种数据类型。而 Redis 的数据类型却丰富的多，它具有 <strong>8 种核心数据类型</strong>，每种数据类型都有一系列操作指令对应。</p>
</li>
<li><p>Redis <strong>性能很高</strong>，单线程压测可以达到 10~11w 的 QPS。单线程性能高是因为没有线程切换，线程间通信，线程竞争，不需要加锁，没有上下文切换开销，所有数据操作都是在内存中操作，所以 Redis 的性能很高。</p>
</li>
<li><p><strong>可持久化</strong>，提供俩种持久化方式：</p>
<ul>
<li>快照方式：将某时刻所有数据都写入硬盘的 <strong>RDB</strong> 文件</li>
<li>追加文件方式：即将所有写命令都以追加的方式写入硬盘的 <strong>AOF</strong> 文件，AOF 文件会随时间流逝变得越来越大，此时，可以通过 bgrewriteaof 指令，对 AOF 进行重写，只保留数据的最后内容，来大大缩减 AOF 的内容。</li>
</ul>
<p>线上 Redis 一般会<strong>同时使用</strong>两种方式，通过开启 appendonly 及关联配置项，将写命令及时追加到 AOF 文件，同时在每日流量低峰时，通过 bgsave 保存当时所有内存数据快照。 </p>
</li>
<li><p>Redis <strong>支持复制</strong>特性：master-多slave，读写分离，把所有写操作落在 Redis 的 master，所有读操作随机落在 Redis 的多个 slave 。</p>
</li>
<li><p>Redis <strong>支持支持 Lua脚本</strong>：Redis 自 2.6 版本开始支持 Lua，通过支持 client 端自定义的 Lua 脚本，Redis 可以减少网络开销，提升处理性能，还可以把脚本中的多个操作作为一个整体来操作，实现原子性更新。</p>
</li>
<li><p>Redis 还<strong>支持事务</strong>，在 multi 指令后，指定多个操作，然后通过 exec 指令一次性执行，中途如果出现异常，则不执行所有命令操作，否则，按顺序一次性执行所有操作，执行过程中不会执行任何其他指令。</p>
</li>
<li><p>Redis 还<strong>支持 Cluster 特性</strong>，可以通过自动或手动方式，将所有 key 按哈希分散到不同节点，在容量不足时，还可以通过 Redis 的迁移指令，把其中一部分 key 迁移到其他节点。</p>
</li>
</ul>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_20.png" alt="Redis特性" style="zoom:47%;">

<h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><p> 8 种核心数据类型：</p>
<ul>
<li><strong>string 字符串类型；</strong></li>
<li><strong>list 列表类型；</strong></li>
<li><strong>set 集合类型；</strong></li>
<li><strong>sorted set 有序集合类型；</strong></li>
<li><strong>hash 类型；</strong></li>
<li>bitmap 位图类型； </li>
<li>geo 地理位置类型；</li>
<li>HyperLogLog 基数统计类型。</li>
</ul>
<h3 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a><strong>string 字符串</strong></h3><p><strong>string</strong> 是 <strong>Redis</strong> 的最<strong>基本数据类型</strong>。可以把它理解为 Mc 中 key 对应的 value 类型。</p>
<ul>
<li><p>string 类型是二进制安全的，即 string 中可以包含任何数据。</p>
</li>
<li><p>Redis 中的普通 string 采用 <strong>raw encoding</strong> 即原始编码方式，该编码方式会<strong>动态扩容</strong>，并通过<strong>提前预分配</strong>冗余空间，来减少内存频繁分配的开销。</p>
</li>
<li><p>在字符串长度小于 1MB 时，按所需长度的 2 倍来分配，超过 1MB，则按照每次额外增加 1MB 的容量来预分配。</p>
</li>
<li><p>Redis 中的<strong>数字也存为 string 类型</strong>，但编码方式跟普通 string 不同，数字<strong>采用整型编码</strong>，字符串内容直接设为整数值的二进制字节序列。</p>
</li>
<li><p>在存储普通字符串，序列化对象，以及计数器等场景时，都可以使用 Redis 的字符串类型，字符串数据类型对应使用的指令包括 set、get、mset、incr、decr 等。</p>
</li>
</ul>
<h3 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a><strong>list 列表</strong></h3><p>Redis 的 list 列表，是一个<strong>快速双向链表</strong>，存储了一系列的 string 类型的字串值。</p>
<ul>
<li><p>list 中的元素<strong>按照插入顺序排列</strong>。</p>
</li>
<li><p>插入元素的方式，可以通过 <strong>lpush</strong> 将一个或多个元素插入到列表的<strong>头部</strong>，也可以通过 <strong>rpush</strong> 将一个或多个元素插入到队列<strong>尾部</strong>，还可以通过 <strong>lset、linsert</strong> 将元素插入到<strong>指定位置或指定元素的前后</strong>。</p>
</li>
<li><p>list 列表的获取，可以通过 lpop、rpop 从对头或队尾弹出元素，如果队列为空，则返回 nil。</p>
<p>还可以通过 Blpop、Brpop 从队头/队尾阻塞式弹出元素，如果 list 列表为空，没有元素可供弹出，则持续阻塞，直到有其他 client 插入新的元素。这里阻塞弹出元素，可以设置过期时间，避免无限期等待。</p>
<p>list 列表还可以通过 LrangeR 获取队列内指定范围内的所有元素。Redis 中，list 列表的偏移位置都是基于 0 的下标，偏移量也可以是负数。</p>
</li>
<li><p>对于<strong>常规的 pop、push 元素，性能很高，时间复杂度为 O(1)</strong>，因为是列表直接追加或弹出。但对于通过<strong>随机插入、随机删除，以及随机范围获取</strong>，需要轮询列表确定位置，<strong>性能就比较低下</strong>了。</p>
</li>
<li><p>feed timeline（是一种把信息根据时间顺序排序呈现给订阅用户进行消费的形式） 存储时，由于 feed id 一般是递增的，可以直接存为 list，用户发表新 feed，就直接追加到队尾。另外消息队列、热门 feed 等业务场景，都可以使用 list 数据结构。</p>
</li>
</ul>
<h3 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a><strong>set 集合</strong></h3><p>set 是 string 类型的<strong>无序集合</strong>，set 中的元素是唯一的，即 set 中<strong>不会出现重复的元素</strong>。Redis 中的集合一般是通过 <strong>dict 哈希表实现</strong>的，所以插入、删除，以及查询元素，可以根据元素 hash 值直接定位，时间复杂度为 O(1)。</p>
<p>除了常规的添加、删除、查找元素外，常用 set 指令：</p>
<ul>
<li><p><strong>sismember</strong> 指令判断该 key 对应的 set 数据结构中，是否存在某个元素，如果存在返回 1，否则返回 0；</p>
</li>
<li><p><strong>sdiff</strong> 指令来对多个 set 集合执行差集；</p>
</li>
<li><p><strong>sinter</strong> 指令对多个集合执行交集；</p>
</li>
<li><p><strong>sunion</strong> 指令对多个集合执行并集；</p>
</li>
<li><p><strong>spop</strong> 指令弹出一个随机元素；</p>
</li>
<li><p><strong>srandmember</strong> 指令返回一个或多个随机元素。</p>
</li>
</ul>
<p>set 集合的特点是查找、插入、删除特别高效，时间复杂度为 O(1)，所以在社交系统中，可以用于存储关注的好友列表，用来判断是否关注，还可以用来做好友推荐使用。另外，还可以利用 set 的唯一性，来对服务的来源业务、来源 IP 进行精确统计。</p>
<h3 id="sorted-set-zset-有序集合"><a href="#sorted-set-zset-有序集合" class="headerlink" title="sorted set (zset) 有序集合"></a><strong>sorted set (zset) 有序集合</strong></h3><p>Redis 中的 sorted set <strong>有序集合</strong>也称为 <strong>zset</strong>，有序集合同 set 集合类似，也是 string 类型元素的集合，且所有元素不允许重复。</p>
<p>有序集合中，每个元素都会关联一个 double 类型的 score 分数值。<strong>有序集合通过这个 score 值进行由小到大的排序</strong>。有序集合中，元素不允许重复，但 score 分数值却允许重复。</p>
<p>除了常规的添加、删除、查找元素外，还可以通过以下指令对 sorted set 进行操作：</p>
<ul>
<li>zscan 指令：按顺序获取有序集合中的元素；</li>
<li>zscore 指令：获取元素的 score 值；</li>
<li>zrange指令：通过指定 score 返回指定 score 范围内的元素；</li>
<li>在某个元素的 score 值发生变更时，还可以通过 zincrby 指令对该元素的 score 值进行加减。</li>
<li>通过 zinterstore、zunionstore 指令对多个有序集合进行取交集和并集，然后将新的有序集合存到一个新的 key 中，如果有重复元素，重复元素的 score 进行相加，然后作为新集合中该元素的 score 值。</li>
</ul>
<p>zset 有序集合的特点是：<strong>所有元素按 score 排序，而且不重复；查找、插入、删除非常高效，时间复杂度为 O(1)。</strong></p>
<p>因此，可以用有序集合来统计排行榜，实时刷新榜单，还可以用来记录学生成绩，从而轻松获取某个成绩范围内的学生名单，还可以用来对系统统计增加权重值，从而在 dashboard 实时展示。</p>
<h3 id="hash-哈希"><a href="#hash-哈希" class="headerlink" title="hash 哈希"></a><strong>hash 哈希</strong></h3><p>Redis 中的哈希实际是 <strong>field 和 value 的一个映射表</strong>。</p>
<p>hash 数据结构的特点是在单个 key 对应的哈希结构内部，可以记录多个键值对，即 field 和 value 对，value 可以是任何字符串。而且<strong>这些键值对查询和修改很高效</strong>。</p>
<p>所以可以用 hash 来存储具有多个元素的复杂对象，然后分别修改或获取这些元素。</p>
<p>hash 结构中的一些重要指令:</p>
<ul>
<li>hmset 指令批量插入多个 field、value 映射；</li>
<li>hmget 指令获取多个 field 对应的 value 值；</li>
<li>hexists 指令判断某个 field 是否存在；</li>
<li>如果 field 对应的 value 是整数，还可以用 hincrby 来对该 value 进行修改。</li>
</ul>
<p>最后了解一下 Redis 中剩下的三个数据类型：<strong>bitmap 位图</strong>、<strong>GEO 地理位置</strong>、<strong>hyperLogLog 基数统计</strong></p>
<ul>
<li><p><strong>bitmap 位图</strong>：Redis 中的 bitmap 位图是一串连续的二进制数字，底层实际是基于 string 进行封装存储的，按 bit 位进行指令操作的。</p>
<p>bitmap 位图的特点是按位设置、求与、求或等操作很高效，而且存储成本非常低，用来存对象标签属性的话，一个 bit 即可存一个标签。</p>
<p>可以用 bitmap，存用户最近 N 天的登录情况，每天用 1 bit，登录则置 1。个性推荐在社交应用中非常重要，可以对新闻、feed 设置一系列标签，如军事、娱乐、视频、图片、文字等，用 bitmap 来存储这些标签，在对应标签 bit 位上置 1。对用户，也可以采用类似方式，记录用户的多种属性，并可以很方便的根据标签来进行多维度统计。bitmap 位图的重要指令包括：setbit、 getbit、bitcount、bitfield、 bitop、bitpos 等。</p>
</li>
<li><p><strong>GEO 地理位置</strong>：Redis 在 3.2 版本之后增加了对 GEO 地理位置的处理功能。Redis 的 GEO 地理位置本质上是基于 sorted set 封装实现的。在存储分类 key 下的地理位置信息时，需要对该分类 key 构建一个 sorted set 作为内部存储结构，用于存储一系列位置点。</p>
<p>Redis 的 GEO 地理位置数据结构，应用场景很多，比如查询某个地方的具体位置，查当前位置到目的地的距离，查附近的人、餐厅、电影院等。GEO 地理位置数据结构中，重要指令包括 geoadd、geopos、geodist、georadius、georadiusbymember 等。</p>
</li>
<li><p><strong>hyperLogLog 基数统计</strong>：Redis 的 hyperLogLog 是用来做基数统计的数据类型，当输入巨大数量的元素做统计时，只需要很小的内存即可完成。HyperLogLog 不保存元数据，只记录待统计元素的估算数量，这个估算数量是一个带有 0.81% 标准差的近似值，在大多数业务场景，对海量数据，不足 1% 的误差是可以接受的。</p>
<p>在大中型系统中，统计每日、每月的 UV 即独立访客数，或者统计海量用户搜索的独立词条数，都可以用 hyperLogLog 数据类型来进行处理。</p>
</li>
</ul>
<h2 id="Redis的设计原则"><a href="#Redis的设计原则" class="headerlink" title="Redis的设计原则"></a>Redis的设计原则</h2><h3 id="Redis-协议"><a href="#Redis-协议" class="headerlink" title="Redis 协议"></a><strong>Redis 协议</strong></h3><p><strong>RESP</strong>（Redis Serialization Protocol）<strong>Redis 序列化协议</strong>， 是一种二进制安全协议，<strong>可以供 Redis 或其他任何 Client-Server 使用</strong>。在 Redis 内部，还会基于 RESP 进一步扩展细节。该协议的设计是为了方便以一种统一的风格和原则来设计和使用Redis指令。</p>
<h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p><strong>Redis 序列化协议的设计原则有三个</strong>：</p>
<ul>
<li>第一是实现简单；</li>
<li>第二是可快速解析；</li>
<li>第三是便于阅读。</li>
</ul>
<p><strong>Redis 协议的请求响应模型有三种：</strong> </p>
<ul>
<li><strong>ping-pong 模式</strong>：即 client 发送一个请求，server 回复一个响应，一问一答的访问模式。</li>
<li><strong>pipeline 模式</strong>：即 client 一次连续发送多个请求，然后等待 server 响应，server 处理完请求后，把响应返回给 client。</li>
<li><strong>pub/sub 模式</strong>：即发布订阅模式，client 通过 subscribe 订阅一个 channel，然后 client 进入订阅状态，静静等待。当有消息产生时，server 会持续自动推送消息给 client，不需要 client 的额外请求。而且客户端在进入订阅状态后，只可接受订阅相关的命令如 SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE 和 PUNSUBSCRIBE，除了这些命令，其他命令一律失效。</li>
</ul>
<p><strong>Redis 请求指令格式类型有 2 种：</strong></p>
<ul>
<li><strong>inline cmd 内联命令格式</strong>：使用 inline cmd 内联格式，只需要用空格分隔请求指令及参数，简单快速，一个简单的例子如 mget key1 key2\r\n。</li>
<li><strong>Array 数组格式</strong>：以 * 开头，随后跟一个数组长度 N，然后以回车换行结尾；然后后面跟随 N 个数组元素。</li>
</ul>
<p><strong>Redis 协议的响应格式有 5 种：</strong></p>
<ul>
<li><strong>simple strings 简单字符串类型</strong>：以 + 开头，后面跟字符串，以 CRLF（即 \r\n）结尾。这种类型不是二进制安全类型，字符串中不能包含 \r 或者 \n。例如：+OK\r\n 。</li>
<li><strong>错误响应</strong>：Redis 协议将错误作为一种专门的类型，格式同简单字符串类型，唯一不同的是以 -（减号）开头。Redis 内部实现对 Redis 协议做了进一步规范，减号后面一般先跟 ERR 或者 WRONGTYPE，然后再跟其他简单字符串，最后以 CRLF（回车换行）结束。</li>
<li><strong>Integer 整数类型</strong>：整数类型以 ：开头，后面跟字符串表示的数字，最后以回车换行结尾。Redis 中许多命令都返回整数，但整数的含义要由具体命令来确定。比如，对于 incr 指令，：后的整数表示变更后的数值；</li>
<li><strong>bulk strings 字符串块类型</strong>：字符串块分<strong>头部和真正字符串内容</strong>两部分。字符串块用于表示二进制安全的字符串，最大长度可以支持 512MB。<ul>
<li>字符串块类型的头部， 为 $ 开头，随后跟真正字符串内容的字节长度，然后以 CRLF 结尾。</li>
<li>字符串块的头部之后，跟随真正的字符串内容，最后以 CRLF 结束字符串块。</li>
</ul>
</li>
<li><strong>Arrays 数组类型</strong>：如果一个命令需要返回多条数据就需要用数组格式类型，另外，前面提到 client 的请求命令也是主要采用这种格式。以 * 开头，随后跟一个数组长度 N，然后以回车换行结尾；然后后面跟随 N 个数组元素，每个数组元素的类型，可以是 Redis 协议中除内联格式外的任何一种类型。</li>
</ul>
<h4 id="协议分类"><a href="#协议分类" class="headerlink" title="协议分类"></a><strong>协议分类</strong></h4><p>Redis 协议主要分为 16 种，<strong>其中 8 种协议对应前面我们讲到的 8 种数据类型</strong>，你选择了使用什么数据类型，就使用对应的响应操作指令即可。</p>
<p>剩下 8 种协议如下：</p>
<ul>
<li><strong>pub-sub 发布订阅协议</strong>，client 可以订阅 channel，持续等待 server 推送消息。</li>
<li><strong>事务协议</strong>，事务协议可以用 multi 和 exec 封装一些列指令，来一次性执行。</li>
<li><strong>脚本协议</strong>，关键指令是 eval、evalsha 和 script等。</li>
<li><strong>连接协议</strong>，主要包括权限控制，切换 DB，关闭连接等。</li>
<li><strong>复制协议</strong>，包括 slaveof、role、psync 等。</li>
<li><strong>配置协议</strong>，config set/get 等，可以在线修改/获取配置。</li>
<li><strong>调试统计协议</strong>，如 slowlog，monitor，info 等。</li>
<li><strong>其他内部命令</strong>，如 migrate，dump，restore 等。</li>
</ul>
<h3 id="Redis-client-的使用及改进"><a href="#Redis-client-的使用及改进" class="headerlink" title="Redis client 的使用及改进"></a><strong>Redis client 的使用及改进</strong></h3><p>由于 Redis 使用广泛，几乎所有主流语言都有对 Redis 开发了对应的 client。 Java 语言中，广泛使用的有 Jedis、Redisson 等。</p>
<ul>
<li><strong>Jedis</strong>：它的优势是轻量，简洁，便于集成和改造，它支持连接池，提供指令维度的操作，几乎支持 Redis 的所有指令，但它不支持读写分离。</li>
<li><strong>Redisson</strong>： 基于 Netty 实现，非阻塞 IO，性能较高，而且支持异步请求和连接池，还支持读写分离、读负载均衡，它内建了 tomcat Session ，支持 spring session 集成，但 redisson 实现相对复杂。</li>
</ul>
<p>在新项目启动时，如果只是简单的 Redis 访问业务场景，可以直接用 Jedis，甚至可以简单封装 Jedis，实现 master-slave 的读写分离方案。如果想直接使用读写分离，想集成 spring session 等这些高级特性，也可以采用 redisson。 </p>
<p>Redis client 在使用中，需要根据业务及运维的需要，进行相关改进。在 client 访问异常时，可以增加<strong>重试策略</strong>，在访问某个 slave 异常时，需要重试其他 slave 节点。需要增加对 <strong>Redis 主从切换、slave 扩展</strong>的支持，比如采用守护线程定期扫描 master、slave 域名，发现 IP 变更，及时切换连接。</p>
<p>对于多个 slave 的访问，还需要增加<strong>负载均衡</strong>策略。最后，Redis client 还可以与配置中心、Redis 集群管理平台整合，从而实时感知及协调 Redis 服务的访问。</p>
<h2 id="Redis-系统架构"><a href="#Redis-系统架构" class="headerlink" title="Redis 系统架构"></a>Redis 系统架构</h2><img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_21.png" alt="Redis系统架构" style="zoom:80%;">

<p>Redis 组件的系统架构如图所示，主要包括：</p>
<ul>
<li><strong>事件处理模块</strong>：Redis 中的事件处理模块，采用的是作者自己开发的 ae 事件驱动模型，可以进行<strong>高效的网络 IO 读写、命令执行，以及时间事件处理</strong>。    </li>
<li><strong>数据存储及管理模块</strong>：Redis 的内存数据都存在 redisDB 中。</li>
<li><strong>用于系统扩展的主从复制/集群管理模块</strong>：主从复制，Redis cluster 集群。</li>
<li><strong>为插件化功能扩展的 Module System 模块</strong>：Redis 在 4.0 版本之后引入了 Module System 模块，可以方便使用者，在不修改核心功能的同时，进行插件化功能开发。使用者可以将新的 feature 封装成动态链接库，Redis 可以在启动时加载，也可以在运行过程中随时按需加载和启用。</li>
</ul>
<h3 id="Redis-事件驱动模型"><a href="#Redis-事件驱动模型" class="headerlink" title="Redis 事件驱动模型"></a><strong>Redis 事件驱动模型</strong></h3><p>Redis 是一个事件驱动程序，但和 Memcached 不同的是，Redis 并没有采用 libevent 或 libev 这些开源库，而是<strong>直接开发了一个新的事件循环组件</strong>。Redis 作者给出的理由是，尽量减少外部依赖，而自己开发的事件模型也足够简洁、轻便、高效，也更易控制。</p>
<p>Redis 的事件驱动模型机制封装在 aeEventLoop 等相关的结构体中，网络连接、命令读取执行回复，数据的持久化、淘汰回收 key 等，几乎所有的核心操作都通过 ae 事件模型进行处理。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_22.png" alt="Redis事件驱动模型" style="zoom:80%;">

<p><strong>Redis 的事件驱动模型处理 2 类事件：</strong></p>
<ul>
<li><strong>文件事件</strong>，如连接建立、接受请求命令、发送响应等；</li>
<li><strong>时间事件</strong>，如 Redis 中定期要执行的统计、key 淘汰、缓冲数据写出、rehash等。</li>
</ul>
<h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p>Redis 的文件事件采用典型的 <strong>Reactor 模式</strong>进行处理。    </p>
<p><strong>处理机制分为 4 部分：</strong></p>
<ul>
<li><p><strong>连接 socket</strong>；</p>
</li>
<li><p><strong>IO 多路复用程序</strong>：Redis 封装了 4 种多路复用程序；每种封装实现都提供了相同的 API 实现。<strong>编译时，会按照性能和系统平台，选择最佳的 IO 多路复用函数作为底层实现</strong>，选择顺序是，首先尝试选择 Solaries 中的 evport，如果没有，就尝试选择 Linux 中的 epoll，否则就选择大多 UNIX 系统都支持的 kqueue，最终就会选择 select 作为底层实现方案。</p>
</li>
<li><p><strong>文件事件分派器</strong>：Redis 中的文件事件分派器是 aeProcessEvents 函数。<strong>它会首先计算最大可以等待的时间，然后利用 aeApiPoll 等待文件事件的发生。</strong>如果在等待时间内，一旦 IO 多路复用程序产生了事件通知，则会立即轮询所有已产生的文件事件，并将文件事件放入 aeEventLoop 中的 aeFiredEvents 结构数组中。</p>
<p>这里会涉及将多路复用中的事件类型，转换为 Redis 的 ae 事件驱动模型中的事件类型。</p>
<p>aeProcessEvents 在获取到触发的事件后，会根据事件类型，将文件事件 dispatch 派发给对应事件处理函数。如果同一个 socket，同时有读事件和写事件，Redis 派发器会首先派发处理读事件，然后再派发处理写事件。</p>
</li>
<li><p><strong>事件处理器</strong>；Redis 中文件事件函数的注册和处理主要分为 3 种。</p>
<ul>
<li><strong>连接处理器 acceptTcpHandler</strong>：Redis 在启动时，在 initServer 中对监听的 socket 注册读事件，事件处理器为 acceptTcpHandler，该函数在有新连接进入时，会被派发器派发读任务。</li>
<li><strong>请求处理器 readQueryFromClient</strong>：连接函数在创建 client 时，会对新连接 socket 注册一个读事件，该读事件的事件处理器就是 readQueryFromClient。</li>
<li><strong>命令回复处理器 sendReplyToClient</strong>：当 redis需要发送响应给client时，Redis 事件循环中会对client的连接socket注册写事件，这个写事件的处理函数就是sendReplyToClient。</li>
</ul>
</li>
</ul>
<p><strong>协议命令解析及处理：</strong></p>
<ul>
<li><p>请求命令进入，触发 IO 读事件后。client 会从连接文件描述符读取请求，并存入 client 的 query buffer 中。</p>
</li>
<li><p>client 读取完请求命令后，则根据 query buff 进行协议解析。协议解析时，首先查看协议的首字符。</p>
<ul>
<li>如果是 *，则解析为字符块数组类型，即 MULTIBULK。</li>
<li>否则请求解析为 INLINE 类型。INLINE 类型是以 CRLF 结尾的单行字符串，协议命令及参数以空格分隔。</li>
</ul>
</li>
<li><p>协议解析完毕后，将请求参数个数存入 client 的 argc 中，将请求的具体参数存入 client 的 argv 中。</p>
</li>
</ul>
<p><strong>对于 quit 指令</strong>，直接返回 OK，设置 flag 为回复后关闭连接。</p>
<p><strong>对于非 quit 指令</strong>，以 client 中 argv[0] 作为命令，从 server 中的命令表中找到对应的 redisCommand。如果没有找到 redisCommand，则返回未知 cmd 异常。如果找到 cmd，则开始执行 redisCommand 中的 proc 函数，进行具体命令的执行。在命令执行完毕后，将响应写入 client 的写缓冲。并按配置和部署，将写指令分发给 aof 和 slaves。同时更新相关的统计数值。</p>
<h4 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h4><p><strong>Redis 中的时间事件分为 2 类：</strong></p>
<ul>
<li><strong>单次时间事件</strong>，即执行完毕后，该时间事件就结束了。</li>
<li><strong>周期性事件</strong>，在事件执行完毕后，会继续设置下一次执行的事件，从而在时间到达后继续执行，并不断重复。</li>
</ul>
<p><strong>时间事件主要有 5 个属性：</strong></p>
<ul>
<li><p><strong>事件 ID</strong>：Redis 为时间事件创建全局唯一 ID，该 ID 按从小到大的顺序进行递增。</p>
</li>
<li><p><strong>执行时间 when_sec 和 when_ms</strong>：精确到毫秒，记录该事件的到达可执行时间。</p>
</li>
<li><p><strong>时间事件处理器 timeProc</strong>：在时间事件到达时，Redis 会调用相应的 timeProc 处理事件。</p>
</li>
<li><p><strong>关联数据 clientData</strong>：在调用 timeProc 时，需要使用该关联数据作为参数。</p>
</li>
<li><p><strong>链表指针 prev 和 next</strong>：它用来将时间事件维护为双向链表，便于插入及查找所要执行的时间事件。</p>
</li>
</ul>
<p>时间事件的处理是在事件循环中的 aeProcessEvents 中进行。</p>
<p><strong>执行过程</strong>：</p>
<ul>
<li>首先<strong>遍历所有的时间事件</strong>。比较事件的时间和当前时间，找出可执行的时间事件。</li>
<li>然后执行时间事件的 <strong>timeProc 函数</strong>。</li>
<li>执行完毕后，对于周期性时间，设置时间新的执行时间；对于单次性时间，设置事件的 ID为 -1，后续在事件循环中，下一次执行 aeProcessEvents 的时候从链表中删除。</li>
</ul>
<h3 id="数据存储及管理模块"><a href="#数据存储及管理模块" class="headerlink" title="数据存储及管理模块"></a>数据存储及管理模块</h3><p>Redis 中所有数据都保存在 DB 中，<strong>一个 Redis 默认最多支持 16 个 DB</strong>。Redis 中的每个 DB 都对应一个 redisDb 结构，即每个 Redis 实例，默认有 16 个 redisDb。用户访问时，<strong>默认使用的是 0 号 DB</strong>，可以通过 select $dbID 在不同 DB 之间切换。</p>
<h4 id="redisDb"><a href="#redisDb" class="headerlink" title="redisDb"></a>redisDb</h4><p>redisDb 结构分为五个部分：</p>
<ul>
<li><strong>dict 主字典</strong>：用来存储当前 DB 中的所有数据，它将 key 和各种数据类型的 value 关联起来，该 dict 也称 key space。</li>
<li><strong>expires 过期字典</strong>：用来存储过期时间 key，存的是 key 与过期时间的映射。</li>
<li><strong>blocking_keys 阻塞字典</strong>：存储的是处于阻塞状态的 key 及 client 列表。例如：在执行 Redis 中 list 的阻塞命令 blpop、brpop 或者 brpoplpush 时，如果对应的 list 列表为空，Redis 就会将对应的 client 设为阻塞状态，同时将该 client 添加到 DB 中 blocking_keys 这个阻塞 dict。</li>
<li><strong>ready_keys 解除阻塞字典</strong>：当有其他调用方在向某个 key 对应的 list 中增加元素时，Redis 会检测是否有 client 阻塞在这个 key 上，即检查 blocking_keys 中是否包含这个 key，如果有则会将这个 key 加入 read_keys 这个 dict 中。</li>
<li><strong>watched_keys 监控字典</strong>：当 client 使用 watch 指令来监控 key 时，这个 key 和 client 就会被保存到 watched_keys 这个 dict 中。</li>
</ul>
<p>redisDb 中可以保存所有的数据类型，而 Redis 中所有数据类型都是存放在一个叫 <strong>redisObject</strong> 的结构中。</p>
<h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a><strong>dict</strong></h4><p><strong>Redis 中的数据实际是存在 DB 中的 2 个核心 dict 字典中的</strong>。实际上 dict 也是 Redis 的一种使用广泛的内部数据结构。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_24.png" alt="dict数据结构" style="zoom:90%;">

<p><strong>Redis 中的 dict，类似于 Memcached 中 hashtable。</strong>都可以用于 key 或元素的快速插入、更新和定位。</p>
<p>dict 字典中，有一个长度为 2 的哈希表数组，日常访问用 0 号哈希表，如果 0 号哈希表元素过多，则分配一个 2 倍 0 号哈希表大小的空间给 1 号哈希表，然后进行逐步迁移，rehashidx 这个字段就是专门用来做标志迁移位置的。</p>
<p>在哈希表操作中，<strong>采用单向链表来解决 hash 冲突问题</strong>。dict 中还有一个重要字段是 type，它用于保存 hash 函数及 key/value 赋值、比较函数。</p>
<p>dictht 中的 table 是一个 hash 表数组，每个桶指向一个 dictEntry 结构。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_25.png" alt="dictht结构" style="zoom:67%;">

<p>其中 <strong>key 是 sds 字符串</strong>（简单动态字符串，本质是一个 char<em>，内部通过 sdshdr 进行管理。），v*</em>alue 为存储各种数据类型的 redisObject 结构**。</p>
<h4 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h4><img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_23.png" alt="redisObject结构" style="zoom:80%;">

<p><strong>redisObject 由 5 个字段组成：</strong></p>
<ul>
<li><strong>type</strong>：即 Redis 对象的数据类型，目前支持 7 种 type 类型，如上图；</li>
<li><strong>encoding</strong>：Redis 对象的内部编码方式，即内部数据结构类型，目前支持 10 种编码方式，如图；</li>
<li><strong>LRU</strong>：存储的是淘汰数据用的 LRU 时间或 LFU 频率及时间的数据。</li>
<li><strong>refcount</strong>：记录 Redis 对象的引用计数，用来表示对象被共享的次数，共享使用时加 1，不再使用时减 1，当计数为 0 时表明该对象没有被使用，就会被释放，回收内存。</li>
<li><strong>ptr</strong>：它指向对象的内部数据结构。比如一个代表 string 的对象，它的 ptr 可能指向一个 sds 或者一个 long 型整数。</li>
</ul>
<h4 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a><strong>ziplist</strong></h4><p>为了<strong>节约内存，并减少内存碎片</strong>，Redis 设计了 ziplist 压缩列表内部数据结构。</p>
<p>压缩列表是<strong>一块连续的内存空间</strong>，可以连续存储多个元素，没有冗余空间，是一种连续内存数据块组成的<strong>顺序型内存结构</strong>。</p>
<p>由于 ziplist 是连续紧凑存储，没有冗余空间，所以插入新的元素需要 realloc 扩展内存，所以如果 ziplist 占用空间太大，realloc 重新分配内存和拷贝的开销就会很大，所以 ziplist <strong>不适合存储过多元素，也不适合存储过大的字符串。</strong> </p>
<p>因此只有在元素数和 value 数都不大的时候，ziplist 才作为 hash 和 zset 的内部数据结构。其中 ：</p>
<ul>
<li><strong>hash</strong> 使用 ziplist 作为内部数据结构的限制时，元素数默认不超过 512 个，value 值默认不超过 64 字节。可以通过修改配置来调整 hash_max_ziplist_entries 、hash_max_ziplist_value 这两个阀值的大小。</li>
<li><strong>zset 有序集合</strong>，使用 ziplist 作为内部数据结构的限制元素数默认不超过 128 个，value 值默认不超过 64 字节。可以通过修改配置来调整 zset_max_ziplist_entries 和 zset_max_ziplist_value 这两个阀值的大小。</li>
</ul>
<h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a><strong>quicklist</strong></h4><p>Redis 在 3.2 版本之后引入 quicklist，用以替换 linkedlist。</p>
<p>因为 linkedlist 每个节点有前后指针，要占用 16 字节，而且每个节点独立分配内存，很容易加剧内存的碎片化。而 ziplist 由于紧凑型存储，增加元素需要 realloc，删除元素需要内存拷贝，天然不适合元素太多、value 太大的存储。</p>
<p>而 quicklist 快速列表应运而生，它是一个<strong>基于 ziplist 的双向链表</strong>。将数据分段存储到 ziplist，然后将这些 ziplist 用双向指针连接。</p>
<p><strong>快速列表从头尾读写数据很快，时间复杂度为 O(1)。也支持从中间任意位置插入或读写元素，但速度较慢，时间复杂度为 O(n)。</strong>快速列表当前主要作为 <strong>list 列表的内部数据结构</strong>。</p>
<h4 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a><strong>zskiplist</strong></h4><p>跳跃表 zskiplist 是一种<strong>有序数据结构，它通过在每个节点维持多个指向其他节点的指针，从而可以加速访问</strong>。（联想到Java中的SkipList）</p>
<p>跳跃表支持平均 O(logN) 和最差 O(n) 复杂度的节点查找。</p>
<p>在大部分场景，跳跃表的效率和平衡树接近，但跳跃表的实现比平衡树要简单，所以不少程序都用跳跃表来替换平衡树。</p>
<p>如果 <strong>sorted set（zset） 类型</strong>的元素数比较多或者元素比较大，Redis 就会选择跳跃表来作为 sorted set有序集合的内部数据结构。</p>
<p><strong>总结：8种数据类型对应哪些内部数据结构？</strong></p>
<ul>
<li>string 字符串，Redis 主要采用 sds 来进行存储。</li>
<li>list 列表，Redis 采用 quicklist 进行存储。</li>
<li>set 集合类型，Redis 采用 dict 来进行存储。</li>
<li>sorted set 有序集合类型<ul>
<li>如果元素数小于 128 且元素长度小于 64，则使用 ziplist 存储，</li>
<li>否则使用 zskiplist 存储。</li>
</ul>
</li>
<li>哈希类型<ul>
<li>如果元素数小于 512，并且元素长度小于 64，则用 ziplist 存储，</li>
<li>否则使用 dict 字典存储。</li>
</ul>
</li>
<li>hyperloglog，采用 sds 简单动态字符串存储。</li>
<li>geo<ul>
<li>如果位置数小于 128，则使用 ziplist 存储，</li>
<li>否则使用 zskiplist 存储。</li>
</ul>
</li>
<li>bitmap，采用 sds 简单动态字符串存储。</li>
</ul>
<h3 id="主从复制-集群管理模块"><a href="#主从复制-集群管理模块" class="headerlink" title="主从复制\集群管理模块"></a>主从复制\集群管理模块</h3><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>为了避免单点故障，数据存储需要进行多副本构建。同时由于 Redis 的核心操作是单线程模型的，单个 Redis 实例能处理的请求 TPS 有限。因此 Redis 自面世起，基本就提供了复制功能，而且对复制策略不断进行优化。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_26.png" alt="主从复制架构图" style="zoom:75%;">

<ul>
<li>Redis 的一个 master 可以挂载多个 slave，而 slave 下还可以挂载多个 slave，形成<strong>多层嵌套结构</strong>。</li>
<li>所有写操作都在 master 实例中进行，master 执行完毕后，将写指令分发给挂在自己下面的 slave 节点。实现同步。</li>
<li>主库 master 和从库 slave 之间通过复制 id 进行匹配，避免 slave 挂到错误的 master。</li>
<li>写操作在master，读操作可以分摊到所有slave节点，<strong>读写分离</strong>，这样整个 master-slave 组合，读写能力都可以得到大幅提升。</li>
<li>master 在分发写请求时，同时会将写指令复制一份存入<strong>复制积压缓冲</strong>，这样当 slave 短时间断开重连时，只要 slave 的<strong>复制位置点</strong>仍然在复制积压缓冲，则可以从之前的复制位置点之后继续进行复制，提升复制效率。</li>
</ul>
<p><strong>Redis复制分为2类：</strong></p>
<ul>
<li><p><strong>全量复制（同步）</strong>：master 会将内存数据通过 bgsave 落地到 <strong>rdb</strong>，同时，将构建 内存快照期间 的写指令，存放到复制缓冲中，当 rdb 快照构建完毕后，master 将 <strong>rdb 和复制缓冲队列中的数据</strong>全部发送给 slave，slave 完全重新创建一份数据。</p>
<p>这个过程，耗时，耗性能，耗带宽，对系统性能和资源资源的访问都影响比较大。在 Redis 2.8 之前，Redis 基本只支持全量复制。</p>
</li>
<li><p><strong>增量复制（同步）</strong>：master 只发送 slave 上次复制位置之后的写指令，不用构建 rdb，而且传输内容非常有限，对 master、slave 的负荷影响很小，对带宽的影响可以忽略，整个系统受影响非常小。</p>
</li>
</ul>
<h4 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h4><p>通过上面的学习，我们知道<strong>复制功能可以 N 倍提升 Redis 节点的读性能</strong>，而集群则可以通过<strong>分布式方案来 N 倍提升 Redis 的写性能</strong>。除了提升性能之外，Redis 集群还可以提供更大的容量，提升资源系统的可用性。</p>
<p><strong>Redis 集群的分布式方案主要有 3 种</strong>：</p>
<ul>
<li><strong>Client 端分区方案</strong></li>
<li><strong>Proxy 分区方案</strong></li>
<li><strong>Redis Cluster 分区方案</strong></li>
</ul>
<h5 id="Client-端分区"><a href="#Client-端分区" class="headerlink" title="Client 端分区"></a>Client 端分区</h5><p><strong>Client 端分区方案</strong>就是由 Client 决定数据被存储到哪个 Redis 分片，或者由哪个 Redis 分片来获取数据。它的核心思想是<strong>通过哈希算法将不同的 key 映射到固定的 Redis 分片节点上</strong>。</p>
<ul>
<li>对于单个 key 请求，Client 直接对 key 进行哈希后，确定 Redis 分片，然后进行请求。</li>
<li>而对于一个请求附带多个 key 的场景，Client 会首先将这些 key 按哈希分片进行分类，从而将一个请求分拆为多个请求，然后再分别请求不同的哈希分片节点。</li>
</ul>
<p>Client 通过哈希算法将数据进行分布,<strong>一般采用的哈希算法是:</strong></p>
<ul>
<li><strong>取模哈希;</strong></li>
<li><strong>一致性哈希</strong>;</li>
<li><strong>区间分布哈希</strong>：实际是一种取模哈希的变种，取模哈希是哈希并取模计算后，按哈希值来分配存储节点，而区间哈希是在哈希计算后，将哈希划分为多个区间，然后将这些区间分配给存储节点。如哈希后分 1024 个哈希点，然后将 0-511 作为分片 1，将 512-1023 作为分片 2。</li>
</ul>
<p><strong>问题：</strong>对于 Client 端分区，由于 Redis 集群有多个 master 分片，同时每个 master 下挂载多个 slave，每个 Redis 节点都有独立的 IP 和端口。如果 master 异常需要切换 master，或读压力过大需要扩展新的 slave，这些都会涉及集群存储节点的变更，需要 Client 端做连接切换。</p>
<p><strong>解决方案</strong>：为了避免 Client 频繁变更 IP 列表，可以采用 DNS 的方式来管理集群的主从。对 Redis 集群的每个分片的主和从均采用不同 DNS 域名。Client 通过域名解析的方式获取域名下的所有 IP，然后来访问集群节点。</p>
<p>在 DNS 访问模式下，Client 需要异步定时探测主从域名，如果发现 IP 变更，及时与新节点建立连接，并关闭老连接。</p>
<p><strong>优缺点</strong></p>
<ul>
<li><strong>优点</strong>：Client 端分区方案的优点在于分区逻辑简单，配置简单，Client 节点之间和 Redis 节点之间均无需协调，灵活性强。而且 Client 直接访问对应 Redis 节点，没有额外环节，性能高效。</li>
<li><strong>缺点</strong>：但该方案扩展不便。在 Redis 端，只能成倍扩展，或者预先分配足够多的分片。在 Client 端，每次分片后，业务端需要修改分发逻辑，并进行重启。</li>
</ul>
<h5 id="Proxy-端分区"><a href="#Proxy-端分区" class="headerlink" title="Proxy 端分区"></a>Proxy 端分区</h5><p>Proxy 端分区方案是指 Client 发送请求给 Proxy 请求代理组件，Proxy 解析 Client 请求，并将请求分发到正确的 Redis 节点，然后等待 Redis 响应，最后再将结果返回给 Client 端。</p>
<ul>
<li>对于单个 key 请求，Proxy 直接对 key 进行哈希后，确定 请求路由，然后进行请求。</li>
<li>如果一个请求包含多个 key，Proxy 需要将请求的多个 key，按分片逻辑分拆为多个请求，然后分别请求不同的 Redis 分片，接下来等待Redis响应，在所有的分拆响应到达后，再进行聚合组装，最后返回给 Client。</li>
</ul>
<p><strong>如果系统运行中，主从变更或发生扩缩容，也只需由 Proxy 变更完成，业务 Client 端基本不受影响。</strong></p>
<p><strong>常见的 Proxy 端分区方案有2种：</strong></p>
<ul>
<li>基于 Twemproxy 的简单分区方案：Twitter 开源的一个组件，支持 Redis 和 Memcached 协议访问的代理组件。Twemproxy 实现简单、稳定性高，在一些访问量不大且很少发生扩缩的业务场景中，可以很好的满足需要。但由于 Twemproxy 是单进程单线程模型的，对包含多个 key 的 mutli 请求，由于需要分拆请求，然后再等待聚合，处理性能较低。可单独详细了解。</li>
<li>基于Codis 的可平滑数据迁移的分区方案：Codis 是一个较为成熟的分布式 Redis 解决方案。对于业务 Client 访问，连接 Codis-proxy 和连接单个 Redis 几乎没有区别。Codis 底层除了会自动解析分发请求之外，还可以在线进行数据迁移，使用非常方便。</li>
</ul>
<p>以上俩种方案可自行了解。</p>
<p><strong>优缺点</strong></p>
<ul>
<li><strong>优点</strong>：使 Client 访问逻辑和 Redis 分布逻辑解耦，业务访问便捷简单。在资源发生变更或扩缩容时，只用修改数量有限的 Proxy 即可，数量庞大的业务 Client 端不用做调整。</li>
<li><strong>缺点</strong>：访问时请求需要经过 Proxy 中转，访问多跳了一级，性能会存在损耗，一般损耗会达到 5~15% 左右。另外多了一个代理层，整个系统架构也会更复杂。</li>
</ul>
<h5 id="Redis-Cluster-分区"><a href="#Redis-Cluster-分区" class="headerlink" title="Redis Cluster 分区"></a><strong>Redis Cluster 分区</strong></h5><p>Redis 社区版在 3.0 后开始引入 Cluster 策略，一般称之为 Redis-Cluster 方案。</p>
<p><strong>Redis-Cluster 按 slot 进行数据的读写和管理，一个 Redis-Cluster 集群包含 16384 个 slot。每个 Redis 分片负责其中一部分 slot。</strong>在集群启动时，<strong>按需将所有 slot 分配到不同节点，在集群系统运行后，按 slot 分配策略，将 key 进行 hash 计算</strong>，并路由到对应节点 访问。</p>
<img src="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/cache_27.png" alt="Redis-Cluster结构" style="zoom:90%;">

<p><strong>在 Redis-Cluster 集群中，key 的访问需要 smart client 配合。</strong></p>
<ul>
<li>Client 首先发送请求给 Redis 节点，Redis 在接受并解析命令后，会对 key 进行 hash 计算以确定 slot 槽位。计算公式是对 key 做 crc16 哈希，然后对 16383 进行按位与操作。</li>
<li>如果 Redis 发现 key 对应的 slot 在本地，则直接执行后返回结果。</li>
<li>如果 Redis 发现 key 对应的 slot 不在本地，会返回 moved 异常响应，并附带 key 的 slot，以及该 slot 对应的正确 Redis 节点的 host 和 port。</li>
<li>Client 根据响应解析出正确的节点 IP 和端口，然后把请求重定向到正确的 Redis，即可完成请求。为了加速访问，Client 需要缓存 slot 与 Redis 节点的对应关系，这样可以直接访问正确的节点，以加速访问性能。   </li>
</ul>
<p><strong>Redis Cluster 是一个去中心化架构</strong>，每个节点记录全部 slot 的拓扑分布。</p>
<p><strong>Redis Cluster 下的不同 Redis 分片节点通过 gossip 协议进行互联</strong>，使用 gossip 的优势在于，该方案无中心控制节点，这样，更新不会受到中心节点的影响，可以通过通知任意一个节点来进行管理通知。</p>
<p><strong>Redis Cluster 支持还支持slot 迁移</strong>。随着业务访问模型的变化，Redis 部分节点可能会出现压力过大、访问不均衡的现象，此时可以将 slot 在 Redis 分片节点内部进行迁移，以均衡访问。如果业务不断发展，数据量过大、TPS过高，还可以将 Redis 节点的部分 slot 迁移到新节点，增加 Redis-Cluster 的分片，对整个 Redis 资源进行扩容，已提升整个集群的容量及读写能力。</p>
<p><strong>Redis-Cluster 提供了灵活的节点扩缩容方案</strong>，可以在不影响用户访问的情况下，动态为集群增加节点扩容，或下线节点为集群缩容。</p>
<p>对于线上应用，还需要<strong>为slot节点增加从库，以增加读写能力及可用性</strong>。在节点上增加从库，需要注意的是，不能使用非集群模式下的 slaveof 指令，而要使用 cluster replication，才能完成集群分片节点下的 slave 添加。另外，对于集群模式，slave 只能挂在分片 master 上，slave 节点自身不能再挂载 slave。</p>
<p>Redis 社区官方在源代码中也提供了 <strong>redis-trib.rb，作为 Redis Cluster 的管理工具</strong>。该工具用 Ruby 开发，所以在使用前，需要安装相关的依赖环境。redis-trib 工具通过封装前面所述的 Redis 指令，从而支持<strong>创建集群、检查集群、添加删除节点、在线迁移 slot</strong> 等各种功能。</p>
<p><strong>优缺点</strong></p>
<ul>
<li><p><strong>优点</strong>：由社区官方实现，并有 Redis-trib 集群工具，上线和使用起来比较便捷。同时它支持在线扩缩，可以随时通过工具查看集群的状态。</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>数据存储和集群逻辑耦合，代码逻辑复杂，容易出错。</li>
<li>Redis 节点要存储 slot 和 key 的映射关系，需要额外占用较多内存，特别是对 value size 比较小、而key相对较大的业务，影响更是明显。</li>
<li>key 迁移过程是阻塞模式，迁移大 value 会导致服务卡顿。而且，迁移过程，先获取 key，再迁移，效率低。</li>
<li>Cluster 模式下，集群复制的 slave 只能挂载到 master，不支持 slave 嵌套，会导致 master 的压力过大，无法支持那些，需要特别多 slave、读 TPS 特别大的业务场景。</li>
</ul>
</li>
</ul>
<h3 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h3><h4 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h4><p><strong>Redis</strong> 持久化是一个将<strong>内存数据转储到磁盘的过程</strong>。</p>
<p><strong>Redis</strong> 目前支持 <strong>RDB、AOF，以及混合存储三种模式</strong>。</p>
<h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><p><strong>Redis</strong> 的 <strong>RDB</strong> 持久化是以<strong>快照的方式</strong>将内存数据存储到磁盘。</p>
<p>在需要进行 RDB 持久化时，Redis 会将内存中的<strong>所有数据以二进制的格式落地</strong>，每条数据存储的<strong>内容包括过期时间、数据类型、key，以及 value。</strong>当 Redis 重启时，如果 appendonly 关闭，则会读取 RDB 持久化生成的二进制文件进行数据恢复。</p>
<p><strong>触发构建 RDB 的场景：</strong></p>
<ul>
<li>通过 <strong>save 或 bgsave 命令</strong>进行主动 RDB 快照构建。</li>
<li>利用<strong>配置 save m n</strong> 来进行自动快照生成。它是指在 m 秒中，如果插入或变更 n 个 key，则自动触发 bgsave。这个配置可以设置多个配置行，以便组合使用。</li>
<li><strong>主从复制</strong>，如果从库需要进行全量复制，此时主库也会进行 bgsave 生成一个 RDB 快照。</li>
<li><strong>执行 flushall 清空所有数据，或执行 shutdown 关闭服务</strong>时，也会触发 Redis 自动构建 RDB 快照。</li>
</ul>
<p><strong>save 和 bgsave 命令对比：</strong></p>
<ul>
<li><strong>save</strong>：是在主进程中进行 RDB 持久化的，持久化期间 Redis 处于<strong>阻塞</strong>状态，不处理任何客户请求，所以一般使用较少。</li>
<li><strong>bgsave</strong>：是 fork 一个<strong>子进程</strong>，然后在子进程中构建 RDB 快照，构建快照的过程不直接影响用户的访问，但仍然会增加机器负载。线上 Redis 快照备份，一般会选择凌晨低峰时段，通过 bgsave 主动触发进行备份。</li>
</ul>
<p><strong>RDB 快照文件主要由 3 部分组成：</strong></p>
<ul>
<li><p><strong>RDB 头部</strong>，主要包括 RDB 的版本，以及 Redis 版本、创建日期、占用内存等辅助信息。</p>
</li>
<li><p><strong>RedisDB 的数据</strong>。存储每个 RedisDB 时，会首先记录当前 RedisDB 的DBID，然后记录主 dict 和 expire dict 的记录数量，最后再轮询存储每条数据记录。</p>
<p>存储数据记录时，如果数据有过期时间，首先记录过期时间。如果 Redis 的 maxmemory_policy 过期策略采用 LRU 或者 LFU，还会将 key 对应的 LRU、LFU 值进行落地，最后记录数据的类型、key，以及 value。</p>
</li>
<li><p><strong>RDB 的尾部</strong>。RDB 尾部，首先存储 Redis 中的 Lua 脚本等辅助信息。然后存储 EOF 标记，即值为 255 的字符。最后存 RDB 的 cksum。</p>
</li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li><p><strong>优点</strong>：RDB 采用二进制方式存储内存数据，文件小，且启动时恢复速度快。</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><p>二进制存储，可读性差，而且由于格式固定，不同版本之间可能存在兼容性问题。</p>
</li>
<li><p>构建 RDB 时，一个快照文件只能存储，构建时刻的内存数据，无法记录之后的数据变更。构建 RDB 的过程，即便在子进程中进行，但仍然属于 CPU 密集型的操作，而且每次落地全量数据，耗时也比较长，不能随时进行，特别是不能在高峰期进行。</p>
</li>
</ul>
</li>
</ul>
<h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><p>Redis 的 AOF 持久化是<strong>以命令追加的方式进行数据落地</strong>的。</p>
<p>通过打开 appendonly 配置，Redis 将每一个写指令追加到磁盘 AOF 文件，从而及时记录内存数据的最新状态。这样即便 Redis 被 crash 或异常关闭后，再次启动，也可以通过加载 AOF，来恢复最新的全量数据，基本不会丢失数据。</p>
<p>AOF 文件中<strong>存储的协议是写指令的 multibulk 格式</strong>，这是 Redis 的标准协议格式，所以<strong>不同的 Redis 版本均可解析并处理，兼容性很好</strong>。</p>
<p>但是，由于 Redis 会记录所有写指令操作到 AOF，大量的中间状态数据，甚至被删除的过期数据，都会存在 AOF 中，<strong>冗余度很大</strong>，而且每条指令还需通过加载和执行来进行数据恢复，<strong>耗时会比较大</strong>。</p>
<p><strong>AOF 数据的落地流程:</strong></p>
<ul>
<li>Redis 在处理完写指令后，首先将写指令<strong>写入 AOF 缓冲</strong>，</li>
<li>然后通过 server_cron 定期将 AOF 缓冲<strong>写入文件缓冲</strong>。</li>
<li>最后按照配置策略进行 fsync，将文件缓冲的数据真正同步<strong>写入磁盘</strong>。</li>
</ul>
<p><strong>Redis 通过 appendfsync 来设置三种不同的同步文件缓冲策略</strong>：</p>
<ul>
<li>第一种配置策略是 <strong>no</strong>，即 Redis 不主动使用 fsync 进行文件数据同步落地，而是由操作系统的 write 函数去确认同步时间，在 Linux 系统中大概每 30 秒会进行一次同步，如果 Redis 发生 crash，就会造成大量的数据丢失。</li>
<li>第二种配置策略是 <strong>always</strong>，即每次将 AOF 缓冲写入文件，都会调用 fsync 强制将内核数据写入文件，安全性最高，但性能上会比较低效，而且由于频繁的 IO 读写，磁盘的寿命会大大降低。</li>
<li>第三种配置策略是 <strong>everysec</strong>。即每秒通过 BIO 线程进行一次 fsync。这种策略在安全性、性能，以及磁盘寿命之间做较好的权衡，可以较好的满足线上业务需要。</li>
</ul>
<p>随着时间的推移，AOF 持续记录所有的写指令，<strong>AOF 会越来越大</strong>，而且会充斥大量的中间数据、过期数据，为了减少无效数据，提升恢复时间，<strong>可以定期对 AOF 进行 rewrite 操作</strong>。</p>
<ul>
<li>执行 bgrewiretaof 命令来进行</li>
<li>配置重写策略进行</li>
</ul>
<p><strong>AOF 进行 rewrite 流程：</strong></p>
<ul>
<li>首先会 fork 一个子进程。子进程轮询所有 <strong>RedisDB 快照</strong>，<strong>将所有内存数据转为 cmd，并写入临时文件</strong>。</li>
<li>在子进程 rewriteaof 时，主进程可以继续执行用户请求，执行完毕后将<strong>写指令写入旧的 AOF 文件和 rewrite 缓冲（增量数据指令）。</strong></li>
<li>子进程将 <strong>RedisDB 中数据落地完毕后</strong>，通知主进程。主进程从而<strong>将 AOF rewite 缓冲数据写入 AOF 临时文件</strong>，然后用新的 AOF 文件替换旧的 AOF 文件，最后通过 BIO 线程异步关闭旧的 AOF 文件。（<strong>即快照 + 增量数据</strong>）</li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li>可以记录全部的最新内存数据，最多也就是 1-2 秒的数据丢失。</li>
<li>AOF 通过 Redis 协议来追加记录数据，兼容性高，而且可以持续轻量级的保存最新数据。</li>
<li>因为是直接通过 Redis 协议存储，可读性也比较好。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：随着时间的增加，冗余数据增多，文件会持续变大，而且数据恢复需要读取所有命令并执行，恢复速度相对较慢。（定期rewrite）</p>
</li>
</ul>
<h5 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h5><p>Redis 在 4.0 版本之后，引入了混合持久化方式，而且在 5.0 版本后默认开启。</p>
<p>混合模式一体化使用 RDB 和 AOF，综合 RDB 和 AOF 的好处。即可包含全量数据，加载速度也比较快。可以使用 aof-use-rdb-preamble 配置来明确打开混合持久化模式。</p>
<p>混合持久化也是通过 bgrewriteaof 来实现的。当启用混合存储后，进行 bgrewriteaof 时，主进程首先依然是 fork 一个子进程，<strong>子进程首先将内存数据以 RDB 的二进制格式写入 AOF 临时文件中。然后，再将落地期间缓冲的新增写指令，以命令的方式追加到临时文件</strong>。</p>
<p><strong>优缺点</strong></p>
<ul>
<li><p>优点：包含全量数据，加载速度快。</p>
</li>
<li><p>缺点：头部的 RDB 格式兼容性和可读性较差。</p>
</li>
</ul>
<h4 id="Redis-BIO异步处理大任务"><a href="#Redis-BIO异步处理大任务" class="headerlink" title="Redis BIO异步处理大任务"></a><strong>Redis BIO异步处理大任务</strong></h4><p><strong>Redis</strong> 在运行过程中，不可避免的会产生一些运行慢的、容易引发阻塞的任务，而 Redis 的核心处理线程是单进程单线程模型，所有命令的接受与处理、数据淘汰等都在主线程中进行，这些任务处理速度非常快。如果核心单线程还要处理那些慢任务，在处理期间，势必会阻塞用户的正常请求，导致服务卡顿。</p>
<p>为此，<strong>Redis</strong> 引入了 <strong>BIO 后台线程</strong>，专门处理那些慢任务，从而保证和提升主线程的处理能力。</p>
<p><strong>Redis</strong> 的 BIO 线程采用<strong>生产者-消费者模型。主线程是生产者，生产各种慢任务，然后存放到任务队列中。</strong>BIO 线程是消费者，从队列获取任务并进行处理。</p>
<p>Redis 启动时，会创建<strong>三个任务队列，并对应构建 3 个 BIO 线程，三个 BIO 线程与 3 个任务队列之间一一对应</strong>，三个任务分别是：</p>
<ul>
<li><strong>close 关闭文件任务</strong>：rewriteaof 完成后，主线程需要关闭旧的 AOF 文件，就向 close 队列插入一个旧 AOF 文件的关闭任务。由 close 线程来处理。</li>
<li><strong>fysnc 任务</strong>：Redis 将 AOF 数据缓冲写入文件内核缓冲后，需要定期将系统内核缓冲数据写入磁盘，此时可以向 fsync 队列写入一个同步文件缓冲的任务，由 fsync 线程来处理。</li>
<li><strong>lazyfree 任务</strong>：Redis 在需要淘汰元素数大于 64 的聚合类数据类型时，如列表、集合、哈希等，就往延迟清理队列中写入待回收的对象，由 lazyfree 线程后续进行异步回收。</li>
</ul>
<p><strong>BIO 线程的整个处理流程：</strong></p>
<ul>
<li>当主线程有慢任务需要异步处理时。就会向对应的任务队列提交任务。提交任务时，首先申请内存空间，构建 BIO 任务。然后对队列锁进行加锁，在队列尾部追加新的 BIO 任务，最后尝试唤醒正在等待任务的 BIO 线程。</li>
<li>BIO 线程启动时或持续处理完所有任务，发现任务队列为空后，就会阻塞，并等待新任务的到来。当主线程有新任务后，主线程会提交任务，并唤醒 BIO 线程。BIO 线程随后开始轮询获取新任务，并进行处理。当处理完所有 BIO 任务后，则再次进入阻塞，等待下一轮唤醒。</li>
</ul>
<h4 id="Redis-多线程"><a href="#Redis-多线程" class="headerlink" title="Redis 多线程"></a>Redis 多线程</h4><p>Redis 自问世以来，广受好评，应用广泛。但相比， Memcached 单实例压测 TPS 可以高达百万，线上可以稳定跑 20-40 万而言，Redis 的单实例压测 TPS 不过 10-12 万，线上一般最高也就 2-4 万，<strong>仍相差一个数量级</strong>。</p>
<p>Redis 慢的<strong>主要原因是单进程单线程模型。</strong>虽然一些重量级操作也进行了分拆，如 RDB 的构建在子进程中进行，文件关闭、文件缓冲同步，以及大 key 清理都放在 BIO 线程异步处理，但还远远不够。</p>
<p>虽然可以通过<strong>多部署几个 Redis 实例来达到类似多线程的效果</strong>。但多实例部署则<strong>带来了运维复杂的问题</strong>，而且单机多实例部署，会相互影响，进一步增大运维的复杂度。</p>
<p>因此，Redis 即将在 6.0 版本引入多线程模型。Redis 的多线程模型，分为主线程和 IO 线程。</p>
<p>拭目以待….</p>
<blockquote>
<p>笔记来源：陈波 老师的 《300分钟吃透分布式缓存》课程</p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://charleyzzzz.github.io/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%89%EF%BC%89-Redis/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/" rel="tag">面试复习</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2021/03/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            消息队列
          
        </div>
      </a>
    
    
      <a href="/2021/03/15/%E7%BC%93%E5%AD%98%EF%BC%88%E4%BA%8C%EF%BC%89-Memcached/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">缓存（二）- Memcached</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: 'fV6hp5I755QPrJ9W3gpD596M-gzGzoHsz',
        app_key: '2BLVrJEhiPxBOjTvEyjpXD2c',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'monsterid',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> CharleyZZZZ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/timg.jpg" alt="Hello World !"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->


<script src="/js/clickLove.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>



    
  </div>
</body>

</html>